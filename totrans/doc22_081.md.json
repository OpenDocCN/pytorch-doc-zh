["```py\ntorch.testing.assert_close(actual, expected, *, allow_subclasses=True, rtol=None, atol=None, equal_nan=False, check_device=True, check_dtype=True, check_layout=True, check_stride=False, msg=None)\u00b6\n```", "```py\n>>> import functools\n>>> assert_equal = functools.partial(torch.testing.assert_close, rtol=0, atol=0)\n>>> assert_equal(1e-9, 1e-10)\nTraceback (most recent call last):\n...\nAssertionError: Scalars are not equal!\n\nExpected 1e-10 but got 1e-09.\nAbsolute difference: 9.000000000000001e-10\nRelative difference: 9.0 \n```", "```py\n>>> # tensor to tensor comparison\n>>> expected = torch.tensor([1e0, 1e-1, 1e-2])\n>>> actual = torch.acos(torch.cos(expected))\n>>> torch.testing.assert_close(actual, expected) \n```", "```py\n>>> # scalar to scalar comparison\n>>> import math\n>>> expected = math.sqrt(2.0)\n>>> actual = 2.0 / math.sqrt(2.0)\n>>> torch.testing.assert_close(actual, expected) \n```", "```py\n>>> # numpy array to numpy array comparison\n>>> import numpy as np\n>>> expected = np.array([1e0, 1e-1, 1e-2])\n>>> actual = np.arccos(np.cos(expected))\n>>> torch.testing.assert_close(actual, expected) \n```", "```py\n>>> # sequence to sequence comparison\n>>> import numpy as np\n>>> # The types of the sequences do not have to match. They only have to have the same\n>>> # length and their elements have to match.\n>>> expected = [torch.tensor([1.0]), 2.0, np.array(3.0)]\n>>> actual = tuple(expected)\n>>> torch.testing.assert_close(actual, expected) \n```", "```py\n>>> # mapping to mapping comparison\n>>> from collections import OrderedDict\n>>> import numpy as np\n>>> foo = torch.tensor(1.0)\n>>> bar = 2.0\n>>> baz = np.array(3.0)\n>>> # The types and a possible ordering of mappings do not have to match. They only\n>>> # have to have the same set of keys and their elements have to match.\n>>> expected = OrderedDict([(\"foo\", foo), (\"bar\", bar), (\"baz\", baz)])\n>>> actual = {\"baz\": baz, \"bar\": bar, \"foo\": foo}\n>>> torch.testing.assert_close(actual, expected) \n```", "```py\n>>> expected = torch.tensor([1.0, 2.0, 3.0])\n>>> actual = expected.clone()\n>>> # By default, directly related instances can be compared\n>>> torch.testing.assert_close(torch.nn.Parameter(actual), expected)\n>>> # This check can be made more strict with allow_subclasses=False\n>>> torch.testing.assert_close(\n...     torch.nn.Parameter(actual), expected, allow_subclasses=False\n... )\nTraceback (most recent call last):\n...\nTypeError: No comparison pair was able to handle inputs of type\n<class 'torch.nn.parameter.Parameter'> and <class 'torch.Tensor'>.\n>>> # If the inputs are not directly related, they are never considered close\n>>> torch.testing.assert_close(actual.numpy(), expected)\nTraceback (most recent call last):\n...\nTypeError: No comparison pair was able to handle inputs of type <class 'numpy.ndarray'>\nand <class 'torch.Tensor'>.\n>>> # Exceptions to these rules are Python scalars. They can be checked regardless of\n>>> # their type if check_dtype=False.\n>>> torch.testing.assert_close(1.0, 1, check_dtype=False) \n```", "```py\n>>> # NaN != NaN by default.\n>>> expected = torch.tensor(float(\"Nan\"))\n>>> actual = expected.clone()\n>>> torch.testing.assert_close(actual, expected)\nTraceback (most recent call last):\n...\nAssertionError: Scalars are not close!\n\nExpected nan but got nan.\nAbsolute difference: nan (up to 1e-05 allowed)\nRelative difference: nan (up to 1.3e-06 allowed)\n>>> torch.testing.assert_close(actual, expected, equal_nan=True) \n```", "```py\n>>> expected = torch.tensor([1.0, 2.0, 3.0])\n>>> actual = torch.tensor([1.0, 4.0, 5.0])\n>>> # The default error message can be overwritten.\n>>> torch.testing.assert_close(actual, expected, msg=\"Argh, the tensors are not close!\")\nTraceback (most recent call last):\n...\nAssertionError: Argh, the tensors are not close!\n>>> # If msg is a callable, it can be used to augment the generated message with\n>>> # extra information\n>>> torch.testing.assert_close(\n...     actual, expected, msg=lambda msg: f\"Header\\n\\n{msg}\\n\\nFooter\"\n... )\nTraceback (most recent call last):\n...\nAssertionError: Header\n\nTensor-likes are not close!\n\nMismatched elements: 2 / 3 (66.7%)\nGreatest absolute difference: 2.0 at index (1,) (up to 1e-05 allowed)\nGreatest relative difference: 1.0 at index (1,) (up to 1.3e-06 allowed)\n\nFooter \n```", "```py\ntorch.testing.make_tensor(*shape, dtype, device, low=None, high=None, requires_grad=False, noncontiguous=False, exclude_zero=False, memory_format=None)\u00b6\n```", "```py\n>>> from torch.testing import make_tensor\n>>> # Creates a float tensor with values in [-1, 1)\n>>> make_tensor((3,), device='cpu', dtype=torch.float32, low=-1, high=1)\ntensor([ 0.1205, 0.2282, -0.6380])\n>>> # Creates a bool tensor on CUDA\n>>> make_tensor((2, 2), device='cuda', dtype=torch.bool)\ntensor([[False, False],\n [False, True]], device='cuda:0') \n```", "```py\ntorch.testing.assert_allclose(actual, expected, rtol=None, atol=None, equal_nan=True, msg='')\u00b6\n```"]