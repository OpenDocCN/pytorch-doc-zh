["```py\nimport torch\nimport torchaudio\nimport torchaudio.functional as F\nimport torchaudio.transforms as T\n\nprint(torch.__version__)\nprint([torchaudio.__version__](https://docs.python.org/3/library/stdtypes.html#str \"builtins.str\")) \n```", "```py\n2.2.0\n2.2.0 \n```", "```py\nimport math\nimport timeit\n\nimport librosa\nimport matplotlib.colors as mcolors\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport resampy\nfrom IPython.display import Audio\n\npd.set_option(\"display.max_rows\", None)\npd.set_option(\"display.max_columns\", None)\n\n[DEFAULT_OFFSET](https://docs.python.org/3/library/functions.html#int \"builtins.int\") = 201\n\ndef _get_log_freq([sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), max_sweep_rate, offset):\n  \"\"\"Get freqs evenly spaced out in log-scale, between [0, max_sweep_rate // 2]\n\n offset is used to avoid negative infinity `log(offset + x)`.\n\n \"\"\"\n    start, stop = [math.log](https://docs.python.org/3/library/math.html#math.log \"math.log\")(offset), [math.log](https://docs.python.org/3/library/math.html#math.log \"math.log\")(offset + max_sweep_rate // 2)\n    return [torch.exp](https://pytorch.org/docs/stable/generated/torch.exp.html#torch.exp \"torch.exp\")([torch.linspace](https://pytorch.org/docs/stable/generated/torch.linspace.html#torch.linspace \"torch.linspace\")(start, stop, [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), dtype=[torch.double](https://pytorch.org/docs/stable/tensor_attributes.html#torch.dtype \"torch.dtype\"))) - offset\n\ndef _get_inverse_log_freq(freq, [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), offset):\n  \"\"\"Find the time where the given frequency is given by _get_log_freq\"\"\"\n    half = [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\") // 2\n    return [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\") * ([math.log](https://docs.python.org/3/library/math.html#math.log \"math.log\")(1 + freq / offset) / [math.log](https://docs.python.org/3/library/math.html#math.log \"math.log\")(1 + half / offset))\n\ndef _get_freq_ticks([sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), offset, f_max):\n    # Given the original sample rate used for generating the sweep,\n    # find the x-axis value where the log-scale major frequency values fall in\n    times, freq = [], []\n    for exp in range(2, 5):\n        for v in range(1, 10):\n            f = v * 10**exp\n            if f < [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\") // 2:\n                t = _get_inverse_log_freq(f, [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), offset) / [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\")\n                times.append(t)\n                freq.append(f)\n    t_max = _get_inverse_log_freq(f_max, [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), offset) / [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\")\n    times.append(t_max)\n    freq.append(f_max)\n    return times, freq\n\ndef get_sine_sweep([sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), offset=[DEFAULT_OFFSET](https://docs.python.org/3/library/functions.html#int \"builtins.int\")):\n    max_sweep_rate = [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\")\n    freq = _get_log_freq([sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), max_sweep_rate, offset)\n    delta = 2 * [math.pi](https://docs.python.org/3/library/functions.html#float \"builtins.float\") * freq / [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\")\n    cummulative = [torch.cumsum](https://pytorch.org/docs/stable/generated/torch.cumsum.html#torch.cumsum \"torch.cumsum\")(delta, dim=0)\n    signal = [torch.sin](https://pytorch.org/docs/stable/generated/torch.sin.html#torch.sin \"torch.sin\")(cummulative).unsqueeze(dim=0)\n    return signal\n\ndef plot_sweep(\n    [waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"),\n    [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"),\n    title,\n    max_sweep_rate=48000,\n    offset=[DEFAULT_OFFSET](https://docs.python.org/3/library/functions.html#int \"builtins.int\"),\n):\n    x_ticks = [100, 500, 1000, 5000, 10000, 20000, max_sweep_rate // 2]\n    y_ticks = [1000, 5000, 10000, 20000, [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\") // 2]\n\n    time, freq = _get_freq_ticks(max_sweep_rate, offset, [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\") // 2)\n    freq_x = [f if f in x_ticks and f <= max_sweep_rate // 2 else None for f in freq]\n    freq_y = [f for f in freq if f in y_ticks and 1000 <= f <= [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\") // 2]\n\n    figure, axis = plt.subplots(1, 1)\n    _, _, _, cax = axis.specgram([waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")[0].numpy(), Fs=[sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"))\n    plt.xticks(time, freq_x)\n    plt.yticks(freq_y, freq_y)\n    axis.set_xlabel(\"Original Signal Frequency (Hz, log scale)\")\n    axis.set_ylabel(\"Waveform Frequency (Hz)\")\n    axis.xaxis.grid(True, alpha=0.67)\n    axis.yaxis.grid(True, alpha=0.67)\n    figure.suptitle(f\"{title} (sample rate: {[sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\")} Hz)\")\n    plt.colorbar(cax) \n```", "```py\n/pytorch/audio/examples/tutorials/audio_resampling_tutorial.py:32: DeprecationWarning:\nPyarrow will become a required dependency of pandas in the next major release of pandas (pandas 3.0),\n(to allow more performant data types, such as the Arrow string type, and better interoperability with other libraries)\nbut was not found to be installed on your system.\nIf this would cause problems for you,\nplease provide us feedback at https://github.com/pandas-dev/pandas/issues/54466\n\n  import pandas as pd \n```", "```py\n[sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\") = 48000\n[waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = get_sine_sweep([sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"))\n\nplot_sweep([waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), title=\"Original Waveform\")\nAudio([waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\").numpy()[0], rate=[sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\")) \n```", "```py\n[resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\") = 32000\nresampler = [T.Resample](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module \"torch.nn.Module\")([sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), dtype=[waveform.dtype](https://pytorch.org/docs/stable/tensor_attributes.html#torch.dtype \"torch.dtype\"))\n[resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = resampler([waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"))\n\nplot_sweep([resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), title=\"Resampled Waveform\")\nAudio([resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\").numpy()[0], rate=[resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\")) \n```", "```py\n[sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\") = 48000\n[resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\") = 32000\n\n[resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = F.resample([waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), lowpass_filter_width=6)\nplot_sweep([resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), title=\"lowpass_filter_width=6\") \n```", "```py\n[resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = F.resample([waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), lowpass_filter_width=128)\nplot_sweep([resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), title=\"lowpass_filter_width=128\") \n```", "```py\n[sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\") = 48000\n[resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\") = 32000\n\n[resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = F.resample([waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), rolloff=0.99)\nplot_sweep([resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), title=\"rolloff=0.99\") \n```", "```py\n[resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = F.resample([waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), rolloff=0.8)\nplot_sweep([resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), title=\"rolloff=0.8\") \n```", "```py\n[sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\") = 48000\n[resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\") = 32000\n\n[resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = F.resample([waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), resampling_method=\"sinc_interp_hann\")\nplot_sweep([resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), title=\"Hann Window Default\") \n```", "```py\n[resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = F.resample([waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), resampling_method=\"sinc_interp_kaiser\")\nplot_sweep([resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), title=\"Kaiser Window Default\") \n```", "```py\n[sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\") = 48000\n[resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\") = 32000 \n```", "```py\n[resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = F.resample(\n    [waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"),\n    [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"),\n    [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"),\n    lowpass_filter_width=64,\n    rolloff=0.9475937167399596,\n    resampling_method=\"sinc_interp_kaiser\",\n    beta=14.769656459379492,\n)\nplot_sweep([resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), title=\"Kaiser Window Best (torchaudio)\") \n```", "```py\n[librosa_resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = [torch.from_numpy](https://pytorch.org/docs/stable/generated/torch.from_numpy.html#torch.from_numpy \"torch.from_numpy\")(\n    librosa.resample([waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\").squeeze().numpy(), orig_sr=[sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), target_sr=[resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), res_type=\"kaiser_best\")\n).unsqueeze(0)\nplot_sweep([librosa_resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), title=\"Kaiser Window Best (librosa)\") \n```", "```py\n[mse](https://docs.python.org/3/library/functions.html#float \"builtins.float\") = [torch.square](https://pytorch.org/docs/stable/generated/torch.square.html#torch.square \"torch.square\")([resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") - [librosa_resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")).mean().item()\nprint(\"torchaudio and librosa kaiser best MSE:\", [mse](https://docs.python.org/3/library/functions.html#float \"builtins.float\")) \n```", "```py\ntorchaudio and librosa kaiser best MSE: 2.0806901153660115e-06 \n```", "```py\n[resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = F.resample(\n    [waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"),\n    [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"),\n    [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"),\n    lowpass_filter_width=16,\n    rolloff=0.85,\n    resampling_method=\"sinc_interp_kaiser\",\n    beta=8.555504641634386,\n)\nplot_sweep([resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), title=\"Kaiser Window Fast (torchaudio)\") \n```", "```py\n[librosa_resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = [torch.from_numpy](https://pytorch.org/docs/stable/generated/torch.from_numpy.html#torch.from_numpy \"torch.from_numpy\")(\n    librosa.resample([waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\").squeeze().numpy(), orig_sr=[sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), target_sr=[resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), res_type=\"kaiser_fast\")\n).unsqueeze(0)\nplot_sweep([librosa_resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), title=\"Kaiser Window Fast (librosa)\") \n```", "```py\n[mse](https://docs.python.org/3/library/functions.html#float \"builtins.float\") = [torch.square](https://pytorch.org/docs/stable/generated/torch.square.html#torch.square \"torch.square\")([resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") - [librosa_resampled_waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")).mean().item()\nprint(\"torchaudio and librosa kaiser fast MSE:\", [mse](https://docs.python.org/3/library/functions.html#float \"builtins.float\")) \n```", "```py\ntorchaudio and librosa kaiser fast MSE: 2.5200744248601437e-05 \n```", "```py\nprint(f\"torchaudio: {[torchaudio.__version__](https://docs.python.org/3/library/stdtypes.html#str \"builtins.str\")}\")\nprint(f\"librosa: {[librosa.__version__](https://docs.python.org/3/library/stdtypes.html#str \"builtins.str\")}\")\nprint(f\"resampy: {[resampy.__version__](https://docs.python.org/3/library/stdtypes.html#str \"builtins.str\")}\") \n```", "```py\ntorchaudio: 2.2.0\nlibrosa: 0.10.0\nresampy: 0.2.2 \n```", "```py\ndef benchmark_resample_functional(\n    [waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"),\n    [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"),\n    [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"),\n    lowpass_filter_width=6,\n    rolloff=0.99,\n    resampling_method=\"sinc_interp_hann\",\n    beta=None,\n    iters=5,\n):\n    return (\n        [timeit.timeit](https://docs.python.org/3/library/timeit.html#timeit.timeit \"timeit.timeit\")(\n            stmt=\"\"\"\ntorchaudio.functional.resample(\n waveform,\n sample_rate,\n resample_rate,\n lowpass_filter_width=lowpass_filter_width,\n rolloff=rolloff,\n resampling_method=resampling_method,\n beta=beta,\n)\n \"\"\",\n            setup=\"import torchaudio\",\n            number=iters,\n            globals=locals(),\n        )\n        * 1000\n        / iters\n    ) \n```", "```py\ndef benchmark_resample_transforms(\n    [waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"),\n    [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"),\n    [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"),\n    lowpass_filter_width=6,\n    rolloff=0.99,\n    resampling_method=\"sinc_interp_hann\",\n    beta=None,\n    iters=5,\n):\n    return (\n        [timeit.timeit](https://docs.python.org/3/library/timeit.html#timeit.timeit \"timeit.timeit\")(\n            stmt=\"resampler(waveform)\",\n            setup=\"\"\"\nimport torchaudio\n\nresampler = torchaudio.transforms.Resample(\n sample_rate,\n resample_rate,\n lowpass_filter_width=lowpass_filter_width,\n rolloff=rolloff,\n resampling_method=resampling_method,\n dtype=waveform.dtype,\n beta=beta,\n)\nresampler.to(waveform.device)\n \"\"\",\n            number=iters,\n            globals=locals(),\n        )\n        * 1000\n        / iters\n    ) \n```", "```py\ndef benchmark_resample_librosa(\n    [waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"),\n    [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"),\n    [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"),\n    res_type=None,\n    iters=5,\n):\n    waveform_np = [waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\").squeeze().numpy()\n    return (\n        [timeit.timeit](https://docs.python.org/3/library/timeit.html#timeit.timeit \"timeit.timeit\")(\n            stmt=\"\"\"\nlibrosa.resample(\n waveform_np,\n orig_sr=sample_rate,\n target_sr=resample_rate,\n res_type=res_type,\n)\n \"\"\",\n            setup=\"import librosa\",\n            number=iters,\n            globals=locals(),\n        )\n        * 1000\n        / iters\n    ) \n```", "```py\ndef benchmark([sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\")):\n    times, rows = [], []\n    [waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = get_sine_sweep([sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\")).to([torch.float32](https://pytorch.org/docs/stable/tensor_attributes.html#torch.dtype \"torch.dtype\"))\n\n    args = ([waveform](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [sample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"), [resample_rate](https://docs.python.org/3/library/functions.html#int \"builtins.int\"))\n\n    # sinc 64 zero-crossings\n    f_time = benchmark_resample_functional(*args, lowpass_filter_width=64)\n    t_time = benchmark_resample_transforms(*args, lowpass_filter_width=64)\n    times.append([None, f_time, t_time])\n    rows.append(\"sinc (width 64)\")\n\n    # sinc 6 zero-crossings\n    f_time = benchmark_resample_functional(*args, lowpass_filter_width=16)\n    t_time = benchmark_resample_transforms(*args, lowpass_filter_width=16)\n    times.append([None, f_time, t_time])\n    rows.append(\"sinc (width 16)\")\n\n    # kaiser best\n    kwargs = {\n        \"lowpass_filter_width\": 64,\n        \"rolloff\": 0.9475937167399596,\n        \"resampling_method\": \"sinc_interp_kaiser\",\n        \"beta\": 14.769656459379492,\n    }\n    lib_time = benchmark_resample_librosa(*args, res_type=\"kaiser_best\")\n    f_time = benchmark_resample_functional(*args, **kwargs)\n    t_time = benchmark_resample_transforms(*args, **kwargs)\n    times.append([lib_time, f_time, t_time])\n    rows.append(\"kaiser_best\")\n\n    # kaiser fast\n    kwargs = {\n        \"lowpass_filter_width\": 16,\n        \"rolloff\": 0.85,\n        \"resampling_method\": \"sinc_interp_kaiser\",\n        \"beta\": 8.555504641634386,\n    }\n    lib_time = benchmark_resample_librosa(*args, res_type=\"kaiser_fast\")\n    f_time = benchmark_resample_functional(*args, **kwargs)\n    t_time = benchmark_resample_transforms(*args, **kwargs)\n    times.append([lib_time, f_time, t_time])\n    rows.append(\"kaiser_fast\")\n\n    df = pd.DataFrame(times, columns=[\"librosa\", \"functional\", \"transforms\"], index=rows)\n    return df \n```", "```py\ndef plot(df):\n    print(df.round(2))\n    ax = df.plot(kind=\"bar\")\n    plt.ylabel(\"Time Elapsed [ms]\")\n    plt.xticks(rotation=0, fontsize=10)\n    for cont, col, color in zip(ax.containers, df.columns, [mcolors.TABLEAU_COLORS](https://docs.python.org/3/library/stdtypes.html#dict \"builtins.dict\")):\n        label = [\"N/A\" if v != v else str(v) for v in df[col].round(2)]\n        ax.bar_label(cont, labels=label, color=color, fontweight=\"bold\", fontsize=\"x-small\") \n```", "```py\ndf = benchmark(48_000, 44_100)\nplot(df) \n```", "```py\n librosa  functional  transforms\nsinc (width 64)      NaN        0.81        0.38\nsinc (width 16)      NaN        0.71        0.32\nkaiser_best        80.86        1.25        0.37\nkaiser_fast         7.87        0.96        0.33 \n```", "```py\ndf = benchmark(16_000, 8_000)\nplot(df) \n```", "```py\n librosa  functional  transforms\nsinc (width 64)      NaN        1.27        1.09\nsinc (width 16)      NaN        0.50        0.36\nkaiser_best        11.24        1.33        1.17\nkaiser_fast         3.19        0.59        0.40 \n```", "```py\ndf = benchmark(44_100, 48_000)\nplot(df) \n```", "```py\n librosa  functional  transforms\nsinc (width 64)      NaN        0.84        0.35\nsinc (width 16)      NaN        0.70        0.35\nkaiser_best        32.97        1.08        0.37\nkaiser_fast         7.90        0.95        0.35 \n```", "```py\ndf = benchmark(8_000, 16_000)\nplot(df) \n```", "```py\n librosa  functional  transforms\nsinc (width 64)      NaN        0.67        0.47\nsinc (width 16)      NaN        0.36        0.20\nkaiser_best        11.14        0.70        0.48\nkaiser_fast         2.96        0.40        0.22 \n```"]