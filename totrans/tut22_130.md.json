["```py\nimport torch\n\n# use deeplabv3_resnet50 instead of resnet101 to reduce the model size\nmodel = torch.hub.load('pytorch/vision:v0.7.0', 'deeplabv3_resnet50', pretrained=True)\nmodel.eval()\n\nscriptedm = torch.jit.script(model)\ntorch.jit.save(scriptedm, \"deeplabv3_scripted.pt\") \n```", "```py\nfrom PIL import Image\nfrom torchvision import transforms\ninput_image = Image.open(\"deeplab.jpg\")\npreprocess = transforms.Compose([\n    transforms.ToTensor(),\n    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),\n])\n\ninput_tensor = preprocess(input_image)\ninput_batch = input_tensor.unsqueeze(0)\nwith torch.no_grad():\n    output = model(input_batch)['out'][0]\n\nprint(input_batch.shape)\nprint(output.shape) \n```", "```py\ntorch.Size([1, 3, 400, 400])\ntorch.Size([21, 400, 400]) \n```", "```py\nModule  module  =  null;\ntry  {\n  module  =  Module.load(assetFilePath(this,  \"deeplabv3_scripted.pt\"));\n}  catch  (IOException  e)  {\n  Log.e(\"ImageSegmentation\",  \"Error loading model!\",  e);\n  finish();\n} \n```", "```py\nfinal  Tensor  inputTensor  =  TensorImageUtils.bitmapToFloat32Tensor(bitmap,\n  TensorImageUtils.TORCHVISION_NORM_MEAN_RGB,\n  TensorImageUtils.TORCHVISION_NORM_STD_RGB);\nfinal  float[]  inputs  =  inputTensor.getDataAsFloatArray();\n\nMap<String,  IValue>  outTensors  =\n  module.forward(IValue.from(inputTensor)).toDictStringKey();\n\n// the key \"out\" of the output tensor contains the semantic masks\n// see https://pytorch.org/hub/pytorch_vision_deeplabv3_resnet101\nfinal  Tensor  outputTensor  =  outTensors.get(\"out\").toTensor();\nfinal  float[]  outputs  =  outputTensor.getDataAsFloatArray();\n\nint  width  =  bitmap.getWidth();\nint  height  =  bitmap.getHeight(); \n```", "```py\nint[]  intValues  =  new  int[width  *  height];\n// go through each element in the output of size [WIDTH, HEIGHT] and\n// set different color for different classnum\nfor  (int  j  =  0;  j  <  width;  j++)  {\n  for  (int  k  =  0;  k  <  height;  k++)  {\n  // maxi: the index of the 21 CLASSNUM with the max probability\n  int  maxi  =  0,  maxj  =  0,  maxk  =  0;\n  double  maxnum  =  -100000.0;\n  for  (int  i=0;  i  <  CLASSNUM;  i++)  {\n  if  (outputs[i*(width*height)  +  j*width  +  k]  >  maxnum)  {\n  maxnum  =  outputs[i*(width*height)  +  j*width  +  k];\n  maxi  =  i;  maxj  =  j;  maxk=  k;\n  }\n  }\n  // color coding for person (red), dog (green), sheep (blue)\n  // black color for background and other classes\n  if  (maxi  ==  PERSON)\n  intValues[maxj*width  +  maxk]  =  0xFFFF0000;  // red\n  else  if  (maxi  ==  DOG)\n  intValues[maxj*width  +  maxk]  =  0xFF00FF00;  // green\n  else  if  (maxi  ==  SHEEP)\n  intValues[maxj*width  +  maxk]  =  0xFF0000FF;  // blue\n  else\n  intValues[maxj*width  +  maxk]  =  0xFF000000;  // black\n  }\n} \n```", "```py\nprivate  static  final  int  CLASSNUM  =  21;\nprivate  static  final  int  DOG  =  12;\nprivate  static  final  int  PERSON  =  15;\nprivate  static  final  int  SHEEP  =  17; \n```", "```py\nBitmap  bmpSegmentation  =  Bitmap.createScaledBitmap(bitmap,  width,  height,  true);\nBitmap  outputBitmap  =  bmpSegmentation.copy(bmpSegmentation.getConfig(),  true);\noutputBitmap.setPixels(intValues,  0,  outputBitmap.getWidth(),  0,  0,\n  outputBitmap.getWidth(),  outputBitmap.getHeight());\nimageView.setImageBitmap(outputBitmap); \n```"]