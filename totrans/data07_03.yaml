- en: Map-style DataPipes¶
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pytorch.org/data/beta/torchdata.datapipes.map.html](https://pytorch.org/data/beta/torchdata.datapipes.map.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A Map-style DataPipe is one that implements the `__getitem__()` and `__len__()`
    protocols, and represents a map from (possibly non-integral) indices/keys to data
    samples. This is a close equivalent of `Dataset` from the PyTorch core library.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when accessed with `mapdatapipe[idx]`, could read the `idx`-th
    image and its corresponding label from a folder on the disk.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Map-style DataPipe.
  prefs: []
  type: TYPE_NORMAL
- en: All datasets that represent a map from keys to data samples should subclass
    this. Subclasses should overwrite `__getitem__()`, supporting fetching a data
    sample for a given, unique key. Subclasses can also optionally overwrite `__len__()`,
    which is expected to return the size of the dataset by many `Sampler` implementations
    and the default options of `DataLoader`.
  prefs: []
  type: TYPE_NORMAL
- en: These DataPipes can be invoked in two ways, using the class constructor or applying
    their functional form onto an existing MapDataPipe (recommend, available to most
    but not all DataPipes).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`DataLoader` by default constructs an index sampler that yields integral indices.
    To make it work with a map-style DataPipe with non-integral indices/keys, a custom
    sampler must be provided.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By design, there are fewer `MapDataPipe` than `IterDataPipe` to avoid duplicate
    implementations of the same functionalities as `MapDataPipe`. We encourage users
    to use the built-in `IterDataPipe` for various functionalities, and convert it
    to `MapDataPipe` as needed using [`IterToMapConverter`](generated/torchdata.datapipes.map.IterToMapConverter.html#torchdata.datapipes.map.IterToMapConverter
    "torchdata.datapipes.map.IterToMapConverter") or `.to_map_datapipe()`. If you
    have any question about usage or best practices while using `MapDataPipe`, feel
    free to ask on the PyTorch forum under the [‘data’ category](https://discuss.pytorch.org/c/data/37).
  prefs: []
  type: TYPE_NORMAL
- en: We are open to add additional `MapDataPipe` where the operations can be lazily
    executed and `__len__` can be known in advance. Feel free to make suggestions
    with description of your use case in [this Github issue](https://github.com/pytorch/pytorch/issues/57031).
    Feedback about our design choice is also welcomed in that Github issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the list of available Map-style DataPipes:'
  prefs: []
  type: TYPE_NORMAL
- en: List of MapDataPipes[¶](#list-of-mapdatapipes "Permalink to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`Batcher`](generated/torchdata.datapipes.map.Batcher.html#torchdata.datapipes.map.Batcher
    "torchdata.datapipes.map.Batcher") | Create mini-batches of data (functional name:
    `batch`). |'
  prefs: []
  type: TYPE_TB
- en: '| [`Concater`](generated/torchdata.datapipes.map.Concater.html#torchdata.datapipes.map.Concater
    "torchdata.datapipes.map.Concater") | Concatenate multiple Map DataPipes (functional
    name: `concat`). |'
  prefs: []
  type: TYPE_TB
- en: '| [`InMemoryCacheHolder`](generated/torchdata.datapipes.map.InMemoryCacheHolder.html#torchdata.datapipes.map.InMemoryCacheHolder
    "torchdata.datapipes.map.InMemoryCacheHolder") | Stores elements from the source
    DataPipe in memory (functional name: `in_memory_cache`). |'
  prefs: []
  type: TYPE_TB
- en: '| [`IterToMapConverter`](generated/torchdata.datapipes.map.IterToMapConverter.html#torchdata.datapipes.map.IterToMapConverter
    "torchdata.datapipes.map.IterToMapConverter") | Lazily load data from `IterDataPipe`
    to construct a `MapDataPipe` with the key-value pair generated by `key_value_fn`
    (functional name: `to_map_datapipe`). |'
  prefs: []
  type: TYPE_TB
- en: '| [`Mapper`](generated/torchdata.datapipes.map.Mapper.html#torchdata.datapipes.map.Mapper
    "torchdata.datapipes.map.Mapper") | Apply the input function over each item from
    the source DataPipe (functional name: `map`). |'
  prefs: []
  type: TYPE_TB
- en: '| [`SequenceWrapper`](generated/torchdata.datapipes.map.SequenceWrapper.html#torchdata.datapipes.map.SequenceWrapper
    "torchdata.datapipes.map.SequenceWrapper") | Wraps a sequence object into a MapDataPipe.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`Shuffler`](generated/torchdata.datapipes.map.Shuffler.html#torchdata.datapipes.map.Shuffler
    "torchdata.datapipes.map.Shuffler") | Shuffle the input MapDataPipe via its indices
    (functional name: `shuffle`). |'
  prefs: []
  type: TYPE_TB
- en: '| [`UnZipper`](generated/torchdata.datapipes.map.UnZipper.html#torchdata.datapipes.map.UnZipper
    "torchdata.datapipes.map.UnZipper") | Takes in a DataPipe of Sequences, unpacks
    each Sequence, and return the elements in separate DataPipes based on their position
    in the Sequence (functional name: `unzip`). |'
  prefs: []
  type: TYPE_TB
- en: '| [`Zipper`](generated/torchdata.datapipes.map.Zipper.html#torchdata.datapipes.map.Zipper
    "torchdata.datapipes.map.Zipper") | Aggregates elements into a tuple from each
    of the input DataPipes (functional name: `zip`). |'
  prefs: []
  type: TYPE_TB
