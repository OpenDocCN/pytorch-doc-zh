- en: Extending TorchScript with Custom C++ Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pytorch.org/tutorials/advanced/torch_script_custom_classes.html](https://pytorch.org/tutorials/advanced/torch_script_custom_classes.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This tutorial is a follow-on to the [custom operator](torch_script_custom_ops.html)
    tutorial, and introduces the API we’ve built for binding C++ classes into TorchScript
    and Python simultaneously. The API is very similar to [pybind11](https://github.com/pybind/pybind11),
    and most of the concepts will transfer over if you’re familiar with that system.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing and Binding the Class in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this tutorial, we are going to define a simple C++ class that maintains
    persistent state in a member variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: '`torch/custom_class.h` is the header you need to include to extend TorchScript
    with your custom class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that whenever we are working with instances of the custom class, we do
    it via instances of `c10::intrusive_ptr<>`. Think of `intrusive_ptr` as a smart
    pointer like `std::shared_ptr`, but the reference count is stored directly in
    the object, as opposed to a separate metadata block (as is done in `std::shared_ptr`.
    `torch::Tensor` internally uses the same pointer type; and custom classes have
    to also use this pointer type so that we can consistently manage different object
    types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second thing to notice is that the user-defined class must inherit from
    `torch::CustomClassHolder`. This ensures that the custom class has space to store
    the reference count.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let’s take a look at how we will make this class visible to TorchScript,
    a process called *binding* the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Building the Example as a C++ Project With CMake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we’re going to build the above C++ code with the [CMake](https://cmake.org)
    build system. First, take all the C++ code we’ve covered so far and place it in
    a file called `class.cpp`. Then, write a simple `CMakeLists.txt` file and place
    it in the same directory. Here is what `CMakeLists.txt` should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, create a `build` directory. Your file tree should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We assume you’ve setup your environment in the same way as described in the
    [previous tutorial](torch_script_custom_ops.html). Go ahead and invoke cmake and
    then make to build the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'What you’ll find is there is now (among other things) a dynamic library file
    present in the build directory. On Linux, this is probably named `libcustom_class.so`.
    So the file tree should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Using the C++ Class from Python and TorchScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our class and its registration compiled into an `.so` file,
    we can load that .so into Python and try it out. Here’s a script that demonstrates
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Saving, Loading, and Running TorchScript Code Using Custom Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also use custom-registered C++ classes in a C++ process using libtorch.
    As an example, let’s define a simple `nn.Module` that instantiates and calls a
    method on our MyStackClass class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`foo.pt` in our filesystem now contains the serialized TorchScript program
    we’ve just defined.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we’re going to define a new CMake project to show how you can load this
    model and its required .so file. For a full treatment of how to do this, please
    have a look at the [Loading a TorchScript Model in C++ Tutorial](https://pytorch.org/tutorials/advanced/cpp_export.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly to before, let’s create a file structure containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice we’ve copied over the serialized `foo.pt` file, as well as the source
    tree from the `custom_class_project` above. We will be adding the `custom_class_project`
    as a dependency to this C++ project so that we can build the custom class into
    the binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s populate `infer.cpp` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And similarly let’s define our CMakeLists.txt file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You know the drill: `cd build`, `cmake`, and `make`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we can run our exciting C++ binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Incredible!
  prefs: []
  type: TYPE_NORMAL
- en: Moving Custom Classes To/From IValues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s also possible that you may need to move custom classes into or out of
    `IValue``s, such as when you take or return ``IValue``s from TorchScript methods
    or you want to instantiate a custom class attribute in C++. For creating an ``IValue`
    from a custom C++ class instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '`torch::make_custom_class<T>()` provides an API similar to c10::intrusive_ptr<T>
    in that it will take whatever set of arguments you provide to it, call the constructor
    of T that matches that set of arguments, and wrap that instance up and return
    it. However, instead of returning just a pointer to a custom class object, it
    returns an `IValue` wrapping the object. You can then pass this `IValue` directly
    to TorchScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the event that you already have an `intrusive_ptr` pointing to your class,
    you can directly construct an IValue from it using the constructor `IValue(intrusive_ptr<T>)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For converting `IValue` back to custom classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IValue::toCustomClass<T>()` will return an `intrusive_ptr<T>` pointing to
    the custom class that the `IValue` contains. Internally, this function is checking
    that `T` is registered as a custom class and that the `IValue` does in fact contain
    a custom class. You can check whether the `IValue` contains a custom class manually
    by calling `isCustomClass()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining Serialization/Deserialization Methods for Custom C++ Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you try to save a `ScriptModule` with a custom-bound C++ class as an attribute,
    you’ll get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is because TorchScript cannot automatically figure out what information
    save from your C++ class. You must specify that manually. The way to do that is
    to define `__getstate__` and `__setstate__` methods on the class using the special
    `def_pickle` method on `class_`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The semantics of `__getstate__` and `__setstate__` in TorchScript are equivalent
    to that of the Python pickle module. You can [read more](https://github.com/pytorch/pytorch/blob/master/torch/csrc/jit/docs/serialization.md#getstate-and-setstate)
    about how we use these methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the `def_pickle` call we can add to the registration
    of `MyStackClass` to include serialization methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We take a different approach from pybind11 in the pickle API. Whereas pybind11
    as a special function `pybind11::pickle()` which you pass into `class_::def()`,
    we have a separate method `def_pickle` for this purpose. This is because the name
    `torch::jit::pickle` was already taken, and we didn’t want to cause confusion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have defined the (de)serialization behavior in this way, our script
    can now run successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Defining Custom Operators that Take or Return Bound C++ Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you’ve defined a custom C++ class, you can also use that class as an argument
    or return from a custom operator (i.e. free functions). Suppose you have the following
    free function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can register it running the following code inside your `TORCH_LIBRARY`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the [custom op tutorial](https://pytorch.org/tutorials/advanced/torch_script_custom_ops.html)
    for more details on the registration API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is done, you can use the op like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Registration of an operator that takes a C++ class as an argument requires that
    the custom class has already been registered. You can enforce this by making sure
    the custom class registration and your free function definitions are in the same
    `TORCH_LIBRARY` block, and that the custom class registration comes first. In
    the future, we may relax this requirement, so that these can be registered in
    any order.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This tutorial walked you through how to expose a C++ class to TorchScript (and
    by extension Python), how to register its methods, how to use that class from
    Python and TorchScript, and how to save and load code using the class and run
    that code in a standalone C++ process. You are now ready to extend your TorchScript
    models with C++ classes that interface with third party C++ libraries or implement
    any other use case that requires the lines between Python, TorchScript and C++
    to blend smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: As always, if you run into any problems or have questions, you can use our [forum](https://discuss.pytorch.org/)
    or [GitHub issues](https://github.com/pytorch/pytorch/issues) to get in touch.
    Also, our [frequently asked questions (FAQ) page](https://pytorch.org/cppdocs/notes/faq.html)
    may have helpful information.
  prefs: []
  type: TYPE_NORMAL
