- en: torch.testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pytorch.org/docs/stable/testing.html](https://pytorch.org/docs/stable/testing.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Asserts that `actual` and `expected` are close.
  prefs: []
  type: TYPE_NORMAL
- en: If `actual` and `expected` are strided, non-quantized, real-valued, and finite,
    they are considered close if
  prefs: []
  type: TYPE_NORMAL
- en: $\lvert
    \text{actual} - \text{expected} \rvert \le \texttt{atol} + \texttt{rtol} \cdot
    \lvert \text{expected} \rvert$∣actual−expected∣≤atol+rtol⋅∣expected∣
  prefs: []
  type: TYPE_NORMAL
- en: Non-finite values (`-inf` and `inf`) are only considered close if and only if
    they are equal. `NaN`’s are only considered equal to each other if `equal_nan`
    is `True`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, they are only considered close if they have the same
  prefs: []
  type: TYPE_NORMAL
- en: '[`device`](generated/torch.Tensor.device.html#torch.Tensor.device "torch.Tensor.device")
    (if `check_device` is `True`),'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dtype` (if `check_dtype` is `True`),'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout` (if `check_layout` is `True`), and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: stride (if `check_stride` is `True`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If either `actual` or `expected` is a meta tensor, only the attribute checks
    will be performed.
  prefs: []
  type: TYPE_NORMAL
- en: If `actual` and `expected` are sparse (either having COO, CSR, CSC, BSR, or
    BSC layout), their strided members are checked individually. Indices, namely `indices`
    for COO, `crow_indices` and `col_indices` for CSR and BSR, or `ccol_indices` and
    `row_indices` for CSC and BSC layouts, respectively, are always checked for equality
    whereas the values are checked for closeness according to the definition above.
  prefs: []
  type: TYPE_NORMAL
- en: If `actual` and `expected` are quantized, they are considered close if they
    have the same [`qscheme()`](generated/torch.Tensor.qscheme.html#torch.Tensor.qscheme
    "torch.Tensor.qscheme") and the result of [`dequantize()`](generated/torch.Tensor.dequantize.html#torch.Tensor.dequantize
    "torch.Tensor.dequantize") is close according to the definition above.
  prefs: []
  type: TYPE_NORMAL
- en: '`actual` and `expected` can be [`Tensor`](tensors.html#torch.Tensor "torch.Tensor")’s
    or any tensor-or-scalar-likes from which [`torch.Tensor`](tensors.html#torch.Tensor
    "torch.Tensor")’s can be constructed with [`torch.as_tensor()`](generated/torch.as_tensor.html#torch.as_tensor
    "torch.as_tensor"). Except for Python scalars the input types have to be directly
    related. In addition, `actual` and `expected` can be [`Sequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence
    "(in Python v3.12)")’s or [`Mapping`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping
    "(in Python v3.12)")’s in which case they are considered close if their structure
    matches and all their elements are considered close according to the above definition.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Python scalars are an exception to the type relation requirement, because their
    `type()`, i.e. [`int`](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)"), [`float`](https://docs.python.org/3/library/functions.html#float
    "(in Python v3.12)"), and [`complex`](https://docs.python.org/3/library/functions.html#complex
    "(in Python v3.12)"), is equivalent to the `dtype` of a tensor-like. Thus, Python
    scalars of different types can be checked, but require `check_dtype=False`.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**actual** (*Any*) – Actual input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**expected** (*Any*) – Expected input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**allow_subclasses** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")) – If `True` (default) and except for Python scalars, inputs
    of directly related types are allowed. Otherwise type equality is required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rtol** (*Optional**[*[*float*](https://docs.python.org/3/library/functions.html#float
    "(in Python v3.12)")*]*) – Relative tolerance. If specified `atol` must also be
    specified. If omitted, default values based on the `dtype` are selected with the
    below table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**atol** (*Optional**[*[*float*](https://docs.python.org/3/library/functions.html#float
    "(in Python v3.12)")*]*) – Absolute tolerance. If specified `rtol` must also be
    specified. If omitted, default values based on the `dtype` are selected with the
    below table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**equal_nan** (*Union**[*[*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]*) – If `True`, two `NaN` values will be considered equal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**check_device** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")) – If `True` (default), asserts that corresponding tensors
    are on the same [`device`](generated/torch.Tensor.device.html#torch.Tensor.device
    "torch.Tensor.device"). If this check is disabled, tensors on different [`device`](generated/torch.Tensor.device.html#torch.Tensor.device
    "torch.Tensor.device")’s are moved to the CPU before being compared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**check_dtype** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")) – If `True` (default), asserts that corresponding tensors
    have the same `dtype`. If this check is disabled, tensors with different `dtype`’s
    are promoted to a common `dtype` (according to [`torch.promote_types()`](generated/torch.promote_types.html#torch.promote_types
    "torch.promote_types")) before being compared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**check_layout** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")) – If `True` (default), asserts that corresponding tensors
    have the same `layout`. If this check is disabled, tensors with different `layout`’s
    are converted to strided tensors before being compared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**check_stride** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")) – If `True` and corresponding tensors are strided, asserts
    that they have the same stride.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**msg** (*Optional**[**Union**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*,* *Callable**[**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]**,* [*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]**]**]*) – Optional error message to use in case a failure
    occurs during the comparison. Can also passed as callable in which case it will
    be called with the generated message and should return the new message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raises
  prefs: []
  type: TYPE_NORMAL
- en: '[**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError
    "(in Python v3.12)") – If no [`torch.Tensor`](tensors.html#torch.Tensor "torch.Tensor")
    can be constructed from an input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError
    "(in Python v3.12)") – If only `rtol` or `atol` is specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**AssertionError**](https://docs.python.org/3/library/exceptions.html#AssertionError
    "(in Python v3.12)") – If corresponding inputs are not Python scalars and are
    not directly related.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**AssertionError**](https://docs.python.org/3/library/exceptions.html#AssertionError
    "(in Python v3.12)") – If `allow_subclasses` is `False`, but corresponding inputs
    are not Python scalars and have different types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**AssertionError**](https://docs.python.org/3/library/exceptions.html#AssertionError
    "(in Python v3.12)") – If the inputs are [`Sequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence
    "(in Python v3.12)")’s, but their length does not match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**AssertionError**](https://docs.python.org/3/library/exceptions.html#AssertionError
    "(in Python v3.12)") – If the inputs are [`Mapping`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping
    "(in Python v3.12)")’s, but their set of keys do not match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**AssertionError**](https://docs.python.org/3/library/exceptions.html#AssertionError
    "(in Python v3.12)") – If corresponding tensors do not have the same [`shape`](generated/torch.Tensor.shape.html#torch.Tensor.shape
    "torch.Tensor.shape").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**AssertionError**](https://docs.python.org/3/library/exceptions.html#AssertionError
    "(in Python v3.12)") – If `check_layout` is `True`, but corresponding tensors
    do not have the same `layout`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**AssertionError**](https://docs.python.org/3/library/exceptions.html#AssertionError
    "(in Python v3.12)") – If only one of corresponding tensors is quantized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**AssertionError**](https://docs.python.org/3/library/exceptions.html#AssertionError
    "(in Python v3.12)") – If corresponding tensors are quantized, but have different
    [`qscheme()`](generated/torch.Tensor.qscheme.html#torch.Tensor.qscheme "torch.Tensor.qscheme")’s.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**AssertionError**](https://docs.python.org/3/library/exceptions.html#AssertionError
    "(in Python v3.12)") – If `check_device` is `True`, but corresponding tensors
    are not on the same [`device`](generated/torch.Tensor.device.html#torch.Tensor.device
    "torch.Tensor.device").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**AssertionError**](https://docs.python.org/3/library/exceptions.html#AssertionError
    "(in Python v3.12)") – If `check_dtype` is `True`, but corresponding tensors do
    not have the same `dtype`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**AssertionError**](https://docs.python.org/3/library/exceptions.html#AssertionError
    "(in Python v3.12)") – If `check_stride` is `True`, but corresponding strided
    tensors do not have the same stride.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**AssertionError**](https://docs.python.org/3/library/exceptions.html#AssertionError
    "(in Python v3.12)") – If the values of corresponding tensors are not close according
    to the definition above.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following table displays the default `rtol` and `atol` for different `dtype`’s.
    In case of mismatching `dtype`’s, the maximum of both tolerances is used.
  prefs: []
  type: TYPE_NORMAL
- en: '| `dtype` | `rtol` | `atol` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `float16` | `1e-3` | `1e-5` |'
  prefs: []
  type: TYPE_TB
- en: '| `bfloat16` | `1.6e-2` | `1e-5` |'
  prefs: []
  type: TYPE_TB
- en: '| `float32` | `1.3e-6` | `1e-5` |'
  prefs: []
  type: TYPE_TB
- en: '| `float64` | `1e-7` | `1e-7` |'
  prefs: []
  type: TYPE_TB
- en: '| `complex32` | `1e-3` | `1e-5` |'
  prefs: []
  type: TYPE_TB
- en: '| `complex64` | `1.3e-6` | `1e-5` |'
  prefs: []
  type: TYPE_TB
- en: '| `complex128` | `1e-7` | `1e-7` |'
  prefs: []
  type: TYPE_TB
- en: '| `quint8` | `1.3e-6` | `1e-5` |'
  prefs: []
  type: TYPE_TB
- en: '| `quint2x4` | `1.3e-6` | `1e-5` |'
  prefs: []
  type: TYPE_TB
- en: '| `quint4x2` | `1.3e-6` | `1e-5` |'
  prefs: []
  type: TYPE_TB
- en: '| `qint8` | `1.3e-6` | `1e-5` |'
  prefs: []
  type: TYPE_TB
- en: '| `qint32` | `1.3e-6` | `1e-5` |'
  prefs: []
  type: TYPE_TB
- en: '| other | `0.0` | `0.0` |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '[`assert_close()`](#torch.testing.assert_close "torch.testing.assert_close")
    is highly configurable with strict default settings. Users are encouraged to [`partial()`](https://docs.python.org/3/library/functools.html#functools.partial
    "(in Python v3.12)") it to fit their use case. For example, if an equality check
    is needed, one might define an `assert_equal` that uses zero tolerances for every
    `dtype` by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Creates a tensor with the given `shape`, `device`, and `dtype`, and filled with
    values uniformly drawn from `[low, high)`.
  prefs: []
  type: TYPE_NORMAL
- en: If `low` or `high` are specified and are outside the range of the `dtype`’s
    representable finite values then they are clamped to the lowest or highest representable
    finite value, respectively. If `None`, then the following table describes the
    default values for `low` and `high`, which depend on `dtype`.
  prefs: []
  type: TYPE_NORMAL
- en: '| `dtype` | `low` | `high` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| boolean type | `0` | `2` |'
  prefs: []
  type: TYPE_TB
- en: '| unsigned integral type | `0` | `10` |'
  prefs: []
  type: TYPE_TB
- en: '| signed integral types | `-9` | `10` |'
  prefs: []
  type: TYPE_TB
- en: '| floating types | `-9` | `9` |'
  prefs: []
  type: TYPE_TB
- en: '| complex types | `-9` | `9` |'
  prefs: []
  type: TYPE_TB
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**shape** (*Tuple**[*[*int*](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.12)")*,* *...**]*) – Single integer or a sequence of integers defining
    the shape of the output tensor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dtype** ([`torch.dtype`](tensor_attributes.html#torch.dtype "torch.dtype"))
    – The data type of the returned tensor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**device** (*Union**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*,* [*torch.device*](tensor_attributes.html#torch.device "torch.device")*]*)
    – The device of the returned tensor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**low** (*Optional**[**Number**]*) – Sets the lower limit (inclusive) of the
    given range. If a number is provided it is clamped to the least representable
    finite value of the given dtype. When `None` (default), this value is determined
    based on the `dtype` (see the table above). Default: `None`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**high** (*Optional**[**Number**]*) –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sets the upper limit (exclusive) of the given range. If a number is provided
    it is clamped to the greatest representable finite value of the given dtype. When
    `None` (default) this value is determined based on the `dtype` (see the table
    above). Default: `None`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Deprecated since version 2.1: Passing `low==high` to [`make_tensor()`](#torch.testing.make_tensor
    "torch.testing.make_tensor") for floating or complex types is deprecated since
    2.1 and will be removed in 2.3\. Use [`torch.full()`](generated/torch.full.html#torch.full
    "torch.full") instead.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**requires_grad** (*Optional**[*[*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*]*) – If autograd should record operations on the returned
    tensor. Default: `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**noncontiguous** (*Optional**[*[*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*]*) – If True, the returned tensor will be noncontiguous.
    This argument is ignored if the constructed tensor has fewer than two elements.
    Mutually exclusive with `memory_format`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**exclude_zero** (*Optional**[*[*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*]*) – If `True` then zeros are replaced with the dtype’s
    small positive value depending on the `dtype`. For bool and integer types zero
    is replaced with one. For floating point types it is replaced with the dtype’s
    smallest positive normal number (the “tiny” value of the `dtype`’s `finfo()` object),
    and for complex types it is replaced with a complex number whose real and imaginary
    parts are both the smallest positive normal number representable by the complex
    type. Default `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**memory_format** (*Optional**[*[*torch.memory_format*](tensor_attributes.html#torch.memory_format
    "torch.memory_format")*]*) – The memory format of the returned tensor. Mutually
    exclusive with `noncontiguous`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raises
  prefs: []
  type: TYPE_NORMAL
- en: '[**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError
    "(in Python v3.12)") – If `requires_grad=True` is passed for integral dtype'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError
    "(in Python v3.12)") – If `low >= high`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError
    "(in Python v3.12)") – If either `low` or `high` is `nan`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**ValueError**](https://docs.python.org/3/library/exceptions.html#ValueError
    "(in Python v3.12)") – If both `noncontiguous` and `memory_format` are passed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**TypeError**](https://docs.python.org/3/library/exceptions.html#TypeError
    "(in Python v3.12)") – If `dtype` isn’t supported by this function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Tensor*](tensors.html#torch.Tensor "torch.Tensor")'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: '[`torch.testing.assert_allclose()`](#torch.testing.assert_allclose "torch.testing.assert_allclose")
    is deprecated since `1.12` and will be removed in a future release. Please use
    [`torch.testing.assert_close()`](#torch.testing.assert_close "torch.testing.assert_close")
    instead. You can find detailed upgrade instructions [here](https://github.com/pytorch/pytorch/issues/61844).'
  prefs: []
  type: TYPE_NORMAL
