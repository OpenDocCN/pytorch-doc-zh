- en: Model ensembling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pytorch.org/tutorials/intermediate/ensembling.html](https://pytorch.org/tutorials/intermediate/ensembling.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Click [here](#sphx-glr-download-intermediate-ensembling-py) to download the
    full example code
  prefs: []
  type: TYPE_NORMAL
- en: This tutorial illustrates how to vectorize model ensembling using `torch.vmap`.
  prefs: []
  type: TYPE_NORMAL
- en: What is model ensembling?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Model ensembling combines the predictions from multiple models together. Traditionally
    this is done by running each model on some inputs separately and then combining
    the predictions. However, if you’re running models with the same architecture,
    then it may be possible to combine them together using `torch.vmap`. `vmap` is
    a function transform that maps functions across dimensions of the input tensors.
    One of its use cases is eliminating for-loops and speeding them up through vectorization.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s demonstrate how to do this using an ensemble of simple MLPs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This tutorial requires PyTorch 2.0.0 or later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s generate a batch of dummy data and pretend that we’re working with an
    MNIST dataset. Thus, the dummy images are 28 by 28, and we have a minibatch of
    size 64\. Furthermore, lets say we want to combine the predictions from 10 different
    models.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have a couple of options for generating predictions. Maybe we want to give
    each model a different randomized minibatch of data. Alternatively, maybe we want
    to run the same minibatch of data through each model (e.g. if we were testing
    the effect of different model initializations).
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 1: different minibatch for each model'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Option 2: Same minibatch'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using `vmap` to vectorize the ensemble
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s use `vmap` to speed up the for-loop. We must first prepare the models
    for use with `vmap`.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s combine the states of the model together by stacking each parameter.
    For example, `model[i].fc1.weight` has shape `[784, 128]`; we are going to stack
    the `.fc1.weight` of each of the 10 models to produce a big weight of shape `[10,
    784, 128]`.
  prefs: []
  type: TYPE_NORMAL
- en: PyTorch offers the `torch.func.stack_module_state` convenience function to do
    this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to define a function to `vmap` over. The function should, given
    parameters and buffers and inputs, run the model using those parameters, buffers,
    and inputs. We’ll use `torch.func.functional_call` to help out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Option 1: get predictions using a different minibatch for each model.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, `vmap` maps a function across the first dimension of all inputs
    to the passed-in function. After using `stack_module_state`, each of the `params`
    and buffers have an additional dimension of size ‘num_models’ at the front, and
    minibatches has a dimension of size ‘num_models’.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Option 2: get predictions using the same minibatch of data.'
  prefs: []
  type: TYPE_NORMAL
- en: '`vmap` has an `in_dims` argument that specifies which dimensions to map over.
    By using `None`, we tell `vmap` we want the same minibatch to apply for all of
    the 10 models.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick note: there are limitations around what types of functions can be transformed
    by `vmap`. The best functions to transform are ones that are pure functions: a
    function where the outputs are only determined by the inputs that have no side
    effects (e.g. mutation). `vmap` is unable to handle mutation of arbitrary Python
    data structures, but it is able to handle many in-place PyTorch operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Curious about performance numbers? Here’s how the numbers look.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There’s a large speedup using `vmap`!
  prefs: []
  type: TYPE_NORMAL
- en: In general, vectorization with `vmap` should be faster than running a function
    in a for-loop and competitive with manual batching. There are some exceptions
    though, like if we haven’t implemented the `vmap` rule for a particular operation
    or if the underlying kernels weren’t optimized for older hardware (GPUs). If you
    see any of these cases, please let us know by opening an issue on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: '**Total running time of the script:** ( 0 minutes 0.798 seconds)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Download Python source code: ensembling.py`](../_downloads/626f23350a6d0b457ded1932a69ec7eb/ensembling.py)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Download Jupyter notebook: ensembling.ipynb`](../_downloads/1342193c7104875f1847417466d1417c/ensembling.ipynb)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Gallery generated by Sphinx-Gallery](https://sphinx-gallery.github.io)'
  prefs: []
  type: TYPE_NORMAL
