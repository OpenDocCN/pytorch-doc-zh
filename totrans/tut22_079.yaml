- en: Model ensembling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pytorch.org/tutorials/intermediate/ensembling.html](https://pytorch.org/tutorials/intermediate/ensembling.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Click [here](#sphx-glr-download-intermediate-ensembling-py) to download the
    full example code
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: This tutorial illustrates how to vectorize model ensembling using `torch.vmap`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: What is model ensembling?
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Model ensembling combines the predictions from multiple models together. Traditionally
    this is done by running each model on some inputs separately and then combining
    the predictions. However, if you’re running models with the same architecture,
    then it may be possible to combine them together using `torch.vmap`. `vmap` is
    a function transform that maps functions across dimensions of the input tensors.
    One of its use cases is eliminating for-loops and speeding them up through vectorization.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Let’s demonstrate how to do this using an ensemble of simple MLPs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: This tutorial requires PyTorch 2.0.0 or later.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s generate a batch of dummy data and pretend that we’re working with an
    MNIST dataset. Thus, the dummy images are 28 by 28, and we have a minibatch of
    size 64\. Furthermore, lets say we want to combine the predictions from 10 different
    models.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have a couple of options for generating predictions. Maybe we want to give
    each model a different randomized minibatch of data. Alternatively, maybe we want
    to run the same minibatch of data through each model (e.g. if we were testing
    the effect of different model initializations).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 1: different minibatch for each model'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Option 2: Same minibatch'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using `vmap` to vectorize the ensemble
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s use `vmap` to speed up the for-loop. We must first prepare the models
    for use with `vmap`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s combine the states of the model together by stacking each parameter.
    For example, `model[i].fc1.weight` has shape `[784, 128]`; we are going to stack
    the `.fc1.weight` of each of the 10 models to produce a big weight of shape `[10,
    784, 128]`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: PyTorch offers the `torch.func.stack_module_state` convenience function to do
    this.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we need to define a function to `vmap` over. The function should, given
    parameters and buffers and inputs, run the model using those parameters, buffers,
    and inputs. We’ll use `torch.func.functional_call` to help out:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Option 1: get predictions using a different minibatch for each model.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: By default, `vmap` maps a function across the first dimension of all inputs
    to the passed-in function. After using `stack_module_state`, each of the `params`
    and buffers have an additional dimension of size ‘num_models’ at the front, and
    minibatches has a dimension of size ‘num_models’.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Option 2: get predictions using the same minibatch of data.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '`vmap` has an `in_dims` argument that specifies which dimensions to map over.
    By using `None`, we tell `vmap` we want the same minibatch to apply for all of
    the 10 models.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A quick note: there are limitations around what types of functions can be transformed
    by `vmap`. The best functions to transform are ones that are pure functions: a
    function where the outputs are only determined by the inputs that have no side
    effects (e.g. mutation). `vmap` is unable to handle mutation of arbitrary Python
    data structures, but it is able to handle many in-place PyTorch operations.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Curious about performance numbers? Here’s how the numbers look.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There’s a large speedup using `vmap`!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: In general, vectorization with `vmap` should be faster than running a function
    in a for-loop and competitive with manual batching. There are some exceptions
    though, like if we haven’t implemented the `vmap` rule for a particular operation
    or if the underlying kernels weren’t optimized for older hardware (GPUs). If you
    see any of these cases, please let us know by opening an issue on GitHub.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**Total running time of the script:** ( 0 minutes 0.798 seconds)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[`Download Python source code: ensembling.py`](../_downloads/626f23350a6d0b457ded1932a69ec7eb/ensembling.py)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[`Download Jupyter notebook: ensembling.ipynb`](../_downloads/1342193c7104875f1847417466d1417c/ensembling.ipynb)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[`下载 Jupyter 笔记本: ensembling.ipynb`](../_downloads/1342193c7104875f1847417466d1417c/ensembling.ipynb)'
- en: '[Gallery generated by Sphinx-Gallery](https://sphinx-gallery.github.io)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[Sphinx-Gallery 生成的画廊](https://sphinx-gallery.github.io)'
