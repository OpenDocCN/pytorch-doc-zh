- en: torch.fx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pytorch.org/docs/stable/fx.html](https://pytorch.org/docs/stable/fx.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## Overview'
  prefs: []
  type: TYPE_NORMAL
- en: 'FX is a toolkit for developers to use to transform `nn.Module` instances. FX
    consists of three main components: a **symbolic tracer,** an **intermediate representation**,
    and **Python code generation**. A demonstration of these components in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The **symbolic tracer** performs “symbolic execution” of the Python code. It
    feeds fake values, called Proxies, through the code. Operations on theses Proxies
    are recorded. More information about symbolic tracing can be found in the [`symbolic_trace()`](#torch.fx.symbolic_trace
    "torch.fx.symbolic_trace") and [`Tracer`](#torch.fx.Tracer "torch.fx.Tracer")
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The **intermediate representation** is the container for the operations that
    were recorded during symbolic tracing. It consists of a list of Nodes that represent
    function inputs, callsites (to functions, methods, or [`torch.nn.Module`](generated/torch.nn.Module.html#torch.nn.Module
    "torch.nn.Module") instances), and return values. More information about the IR
    can be found in the documentation for [`Graph`](#torch.fx.Graph "torch.fx.Graph").
    The IR is the format on which transformations are applied.
  prefs: []
  type: TYPE_NORMAL
- en: '**Python code generation** is what makes FX a Python-to-Python (or Module-to-Module)
    transformation toolkit. For each Graph IR, we can create valid Python code matching
    the Graph’s semantics. This functionality is wrapped up in [`GraphModule`](#torch.fx.GraphModule
    "torch.fx.GraphModule"), which is a [`torch.nn.Module`](generated/torch.nn.Module.html#torch.nn.Module
    "torch.nn.Module") instance that holds a [`Graph`](#torch.fx.Graph "torch.fx.Graph")
    as well as a `forward` method generated from the Graph.'
  prefs: []
  type: TYPE_NORMAL
- en: Taken together, this pipeline of components (symbolic tracing -> intermediate
    representation -> transforms -> Python code generation) constitutes the Python-to-Python
    transformation pipeline of FX. In addition, these components can be used separately.
    For example, symbolic tracing can be used in isolation to capture a form of the
    code for analysis (and not transformation) purposes. Code generation can be used
    for programmatically generating models, for example from a config file. There
    are many uses for FX!
  prefs: []
  type: TYPE_NORMAL
- en: 'Several example transformations can be found at the [examples](https://github.com/pytorch/examples/tree/master/fx)
    repository.  ## Writing Transformations[](#writing-transformations "Permalink
    to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: What is an FX transform? Essentially, it’s a function that looks like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Your transform will take in a [`torch.nn.Module`](generated/torch.nn.Module.html#torch.nn.Module
    "torch.nn.Module"), acquire a [`Graph`](#torch.fx.Graph "torch.fx.Graph") from
    it, do some modifications, and return a new [`torch.nn.Module`](generated/torch.nn.Module.html#torch.nn.Module
    "torch.nn.Module"). You should think of the [`torch.nn.Module`](generated/torch.nn.Module.html#torch.nn.Module
    "torch.nn.Module") that your FX transform returns as identical to a regular [`torch.nn.Module`](generated/torch.nn.Module.html#torch.nn.Module
    "torch.nn.Module") – you can pass it to another FX transform, you can pass it
    to TorchScript, or you can run it. Ensuring that the inputs and outputs of your
    FX transform are a [`torch.nn.Module`](generated/torch.nn.Module.html#torch.nn.Module
    "torch.nn.Module") will allow for composability.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to modify an existing [`GraphModule`](#torch.fx.GraphModule
    "torch.fx.GraphModule") instead of creating a new one, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that you MUST call [`GraphModule.recompile()`](#torch.fx.GraphModule.recompile
    "torch.fx.GraphModule.recompile") to bring the generated `forward()` method on
    the `GraphModule` in sync with the modified [`Graph`](#torch.fx.Graph "torch.fx.Graph").
  prefs: []
  type: TYPE_NORMAL
- en: Given that you’ve passed in a [`torch.nn.Module`](generated/torch.nn.Module.html#torch.nn.Module
    "torch.nn.Module") that has been traced into a [`Graph`](#torch.fx.Graph "torch.fx.Graph"),
    there are now two primary approaches you can take to building a new [`Graph`](#torch.fx.Graph
    "torch.fx.Graph").
  prefs: []
  type: TYPE_NORMAL
- en: A Quick Primer on Graphs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Full treatment of the semantics of graphs can be found in the [`Graph`](#torch.fx.Graph
    "torch.fx.Graph") documentation, but we are going to cover the basics here. A
    [`Graph`](#torch.fx.Graph "torch.fx.Graph") is a data structure that represents
    a method on a [`GraphModule`](#torch.fx.GraphModule "torch.fx.GraphModule"). The
    information that this requires is:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the inputs to the method?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the operations that run inside the method?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the output (i.e. return) value from the method?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All three of these concepts are represented with [`Node`](#torch.fx.Node "torch.fx.Node")
    instances. Let’s see what we mean by that with a short example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we define a module `MyModule` for demonstration purposes, instantiate
    it, symbolically trace it, then call the [`Graph.print_tabular()`](#torch.fx.Graph.print_tabular
    "torch.fx.Graph.print_tabular") method to print out a table showing the nodes
    of this [`Graph`](#torch.fx.Graph "torch.fx.Graph"):'
  prefs: []
  type: TYPE_NORMAL
- en: '| opcode | name | target | args | kwargs |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| placeholder | x | x | () | {} |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| get_attr | linear_weight | linear.weight | () | {} |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| call_function | add_1 | <built-in function add> | (x, linear_weight) | {}
    |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| call_module | linear_1 | linear | (add_1,) | {} |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| call_method | relu_1 | relu | (linear_1,) | {} |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| call_function | sum_1 | <built-in method sum …> | (relu_1,) | {‘dim’: -1}
    |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| call_function | topk_1 | <built-in method topk …> | (sum_1, 3) | {} |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| output | output | output | (topk_1,) | {} |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: We can use this information to answer the questions we posed above.
  prefs: []
  type: TYPE_NORMAL
- en: What are the inputs to the method? In FX, method inputs are specified via special
    `placeholder` nodes. In this case, we have a single `placeholder` node with a
    `target` of `x`, meaning we have a single (non-self) argument named x.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the operations within the method? The `get_attr`, `call_function`,
    `call_module`, and `call_method` nodes represent the operations in the method.
    A full treatment of the semantics of all of these can be found in the [`Node`](#torch.fx.Node
    "torch.fx.Node") documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the return value of the method? The return value in a [`Graph`](#torch.fx.Graph
    "torch.fx.Graph") is specified by a special `output` node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given that we now know the basics of how code is represented in FX, we can now
    explore how we would edit a [`Graph`](#torch.fx.Graph "torch.fx.Graph").
  prefs: []
  type: TYPE_NORMAL
- en: Graph Manipulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Direct Graph Manipulation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One approach to building this new [`Graph`](#torch.fx.Graph "torch.fx.Graph")
    is to directly manipulate your old one. To aid in this, we can simply take the
    [`Graph`](#torch.fx.Graph "torch.fx.Graph") we obtain from symbolic tracing and
    modify it. For example, let’s say we desire to replace [`torch.add()`](generated/torch.add.html#torch.add
    "torch.add") calls with [`torch.mul()`](generated/torch.mul.html#torch.mul "torch.mul")
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can also do more involved [`Graph`](#torch.fx.Graph "torch.fx.Graph") rewrites,
    such as deleting or appending nodes. To aid in these transformations, FX has utility
    functions for transforming the graph that can be found in the [`Graph`](#torch.fx.Graph
    "torch.fx.Graph") documentation. An example of using these APIs to append a `torch.relu()`
    call can be found below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For simple transformations that only consist of substitutions, you can also
    make use of the [subgraph rewriter.](https://github.com/pytorch/pytorch/blob/main/torch/fx/subgraph_rewriter.py)
  prefs: []
  type: TYPE_NORMAL
- en: Subgraph Rewriting With replace_pattern()[](#subgraph-rewriting-with-replace-pattern
    "Permalink to this heading")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: FX also provides another level of automation on top of direct graph manipulation.
    The [`replace_pattern()`](#torch.fx.replace_pattern "torch.fx.replace_pattern")
    API is essentially a “find/replace” tool for editing [`Graph`](#torch.fx.Graph
    "torch.fx.Graph")s. It allows you to specify a `pattern` and `replacement` function
    and it will trace through those functions, find instances of the group of operations
    in the `pattern` graph, and replace those instances with copies of the `replacement`
    graph. This can help to greatly automate tedious graph manipulation code, which
    can get unwieldy as the transformations get more complex.
  prefs: []
  type: TYPE_NORMAL
- en: Graph Manipulation Examples[](#graph-manipulation-examples "Permalink to this
    heading")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Replace one op](https://github.com/pytorch/examples/blob/master/fx/replace_op.py)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Conv/Batch Norm fusion](https://github.com/pytorch/pytorch/blob/40cbf342d3c000712da92cfafeaca651b3e0bd3e/torch/fx/experimental/optimization.py#L50)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[replace_pattern: Basic usage](https://github.com/pytorch/examples/blob/master/fx/subgraph_rewriter_basic_use.py)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quantization](https://pytorch.org/docs/main/quantization.html#prototype-fx-graph-mode-quantization)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Invert Transformation](https://github.com/pytorch/examples/blob/master/fx/invert.py)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy/Retracing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way of manipulating [`Graph`](#torch.fx.Graph "torch.fx.Graph")s is
    by reusing the [`Proxy`](#torch.fx.Proxy "torch.fx.Proxy") machinery used in symbolic
    tracing. For example, let’s imagine that we wanted to write a transformation that
    decomposed PyTorch functions into smaller operations. It would transform every
    `F.relu(x)` call into `(x > 0) * x`. One possibility would be to perform the requisite
    graph rewriting to insert the comparison and multiplication after the `F.relu`,
    and then clean up the original `F.relu`. However, we can automate this process
    by using [`Proxy`](#torch.fx.Proxy "torch.fx.Proxy") objects to automatically
    record operations into the [`Graph`](#torch.fx.Graph "torch.fx.Graph").
  prefs: []
  type: TYPE_NORMAL
- en: To use this method, we write the operations that we want inserted as regular
    PyTorch code and invoke that code with [`Proxy`](#torch.fx.Proxy "torch.fx.Proxy")
    objects as arguments. These [`Proxy`](#torch.fx.Proxy "torch.fx.Proxy") objects
    will capture the operations that are performed on them and append them to the
    [`Graph`](#torch.fx.Graph "torch.fx.Graph").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In addition to avoiding explicit graph manipulation, using [`Proxy`](#torch.fx.Proxy
    "torch.fx.Proxy")s also allows you to specify your rewrite rules as native Python
    code. For transformations that require a large amount of rewrite rules (such as
    vmap or grad), this can often improve readability and maintainability of the rules.
    Note that while calling [`Proxy`](#torch.fx.Proxy "torch.fx.Proxy") we also passed
    a tracer pointing to the underlying variable graph. This is done so if in case
    the operations in graph are n-ary (e.g. add is a binary operator) the call to
    [`Proxy`](#torch.fx.Proxy "torch.fx.Proxy") does not create multiple instances
    of a graph tracer which can lead to unexpected runtime errors. We recommend this
    method of using [`Proxy`](#torch.fx.Proxy "torch.fx.Proxy") especially when the
    underlying operators can not be safely assumed to be unary.
  prefs: []
  type: TYPE_NORMAL
- en: A worked example of using [`Proxy`](#torch.fx.Proxy "torch.fx.Proxy")s for [`Graph`](#torch.fx.Graph
    "torch.fx.Graph") manipulation can be found [here](https://github.com/pytorch/examples/blob/master/fx/proxy_based_graph_creation.py).
  prefs: []
  type: TYPE_NORMAL
- en: The Interpreter Pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A useful code organizational pattern in FX is to loop over all the [`Node`](#torch.fx.Node
    "torch.fx.Node")s in a [`Graph`](#torch.fx.Graph "torch.fx.Graph") and execute
    them. This can be used for several things including runtime analysis of values
    flowing through the graph or transformation of the code via retracing with [`Proxy`](#torch.fx.Proxy
    "torch.fx.Proxy")s. For example, suppose we want to run a [`GraphModule`](#torch.fx.GraphModule
    "torch.fx.GraphModule") and record the [`torch.Tensor`](tensors.html#torch.Tensor
    "torch.Tensor") shape and dtype properties on the nodes as we see them at runtime.
    That might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a full interpreter for FX is not that complicated but it can
    be very useful. To ease using this pattern, we provide the [`Interpreter`](#torch.fx.Interpreter
    "torch.fx.Interpreter") class, which encompasses the above logic in a way that
    certain aspects of the interpreter’s execution can be overridden via method overrides.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to executing operations, we can also generate a new Graph by feeding
    [`Proxy`](#torch.fx.Proxy "torch.fx.Proxy") values through an interpreter. Similarly,
    we provide the [`Transformer`](#torch.fx.Transformer "torch.fx.Transformer") class
    to encompass this pattern. [`Transformer`](#torch.fx.Transformer "torch.fx.Transformer")
    behaves similarly to [`Interpreter`](#torch.fx.Interpreter "torch.fx.Interpreter"),
    but instead of calling the `run` method to get a concrete output value from the
    Module, you would call the [`Transformer.transform()`](#torch.fx.Transformer.transform
    "torch.fx.Transformer.transform") method to return a new [`GraphModule`](#torch.fx.GraphModule
    "torch.fx.GraphModule") which was subject to any transformation rules you installed
    as overridden methods.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of the Interpreter Pattern[](#examples-of-the-interpreter-pattern
    "Permalink to this heading")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Shape Propagation](https://github.com/pytorch/pytorch/blob/master/torch/fx/passes/shape_prop.py)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Performance Profiler](https://github.com/pytorch/tutorials/pull/1319)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Often in the course of authoring transformations, our code will not be quite
    right. In this case, we may need to do some debugging. The key is to work backwards:
    first, check the results of invoking the generated module to prove or disprove
    correctness. Then, inspect and debug the generated code. Then, debug the process
    of transformations that led to the generated code.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not familiar with debuggers, please see the auxiliary section [Available
    Debuggers](#available-debuggers).
  prefs: []
  type: TYPE_NORMAL
- en: Common Pitfalls in Transform Authoring[](#common-pitfalls-in-transform-authoring
    "Permalink to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nondeterministic `set` iteration order. In Python, the `set` datatype is unordered.
    Using `set` to contain collections of objects like `Node`s, for example, can cause
    unexpected nondeterminism. An example is iterating over a set of `Node`s to insert
    them into a `Graph`. Because the `set` data type is unordered, the ordering of
    the operations in the output program will be nondeterministic and can change across
    program invocations. The recommended alternative is to use a `dict` data type,
    which is [insertion ordered](https://mail.python.org/pipermail/python-dev/2017-December/151283.html)
    as of Python 3.7 (and as of cPython 3.6). A `dict` can be used equivalently to
    a set by storing values to be deduplicated in the keys of the `dict`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking Correctness of Modules[](#checking-correctness-of-modules "Permalink
    to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because the output of most deep learning modules consists of floating point
    [`torch.Tensor`](tensors.html#torch.Tensor "torch.Tensor") instances, checking
    for equivalence between the results of two [`torch.nn.Module`](generated/torch.nn.Module.html#torch.nn.Module
    "torch.nn.Module") is not as straightforward as doing a simple equality check.
    To motivate this, let’s use an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we’ve tried to check equality of the values of two deep learning models
    with the `==` equality operator. However, this is not well- defined both due to
    the issue of that operator returning a tensor and not a bool, but also because
    comparison of floating point values should use a margin of error (or epsilon)
    to account for the non-commutativity of floating point operations (see [here](https://floating-point-gui.de/errors/comparison/)
    for more details). We can use [`torch.allclose()`](generated/torch.allclose.html#torch.allclose
    "torch.allclose") instead, which will give us an approximate comparison taking
    into account a relative and absolute tolerance threshold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is the first tool in our toolbox to check if transformed modules are behaving
    as we expect compared to a reference implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the Generated Code[](#debugging-the-generated-code "Permalink to
    this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because FX generates the `forward()` function on [`GraphModule`](#torch.fx.GraphModule
    "torch.fx.GraphModule")s, using traditional debugging techniques like `print`
    statements or `pdb` is not as straightforward. Luckily, we have several techniques
    we can use for debugging the generated code.
  prefs: []
  type: TYPE_NORMAL
- en: Use `pdb`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Invoke `pdb` to step into the running program. Although the code that represents
    the [`Graph`](#torch.fx.Graph "torch.fx.Graph") is not in any source file, we
    can still step into it manually using `pdb` when the forward pass is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '#### Print the Generated Code[](#print-the-generated-code "Permalink to this
    heading")'
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to run the same code multiple times, then it can be a bit tedious
    to step to the right code with `pdb`. In that case, one approach is to simply
    copy-paste the generated `forward` pass into your code and examine it from there.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Use the `to_folder` Function From `GraphModule`[](#use-the-to-folder-function-from-graphmodule
    "Permalink to this heading")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[`GraphModule.to_folder()`](#torch.fx.GraphModule.to_folder "torch.fx.GraphModule.to_folder")
    is a method in `GraphModule` that allows you to dump out the generated FX code
    to a folder. Although copying the forward pass into the code often suffices as
    in [Print the Generated Code](#print-the-generated-code), it may be easier to
    examine modules and parameters using `to_folder`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After running the above example, we can then look at the code within `foo/module.py`
    and modify it as desired (e.g. adding `print` statements or using `pdb`) to debug
    the generated code.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the Transformation[](#debugging-the-transformation "Permalink to
    this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we’ve identified that a transformation is creating incorrect code,
    it’s time to debug the transformation itself. First, we’ll check the [Limitations
    of Symbolic Tracing](#limitations-of-symbolic-tracing) section in the documentation.
    Once we verify that tracing is working as expected, the goal becomes figuring
    out what went wrong during our `GraphModule` transformation. There may be a quick
    answer in [Writing Transformations](#writing-transformations), but, if not, there
    are several ways to examine our traced module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using the utility functions above, we can compare our traced Module before and
    after we’ve applied our transformations. Sometimes, a simple visual comparison
    is enough to trace down a bug. If it’s still not clear what’s going wrong, a debugger
    like `pdb` can be a good next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going off of the example above, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using the above example, let’s say that the call to `print(traced)` showed us
    that there was an error in our transforms. We want to find what goes wrong using
    a debugger. We start a `pdb` session. We can see what’s happening during the transform
    by breaking on `transform_graph(traced)`, then pressing `s` to “step into” the
    call to `transform_graph(traced)`.
  prefs: []
  type: TYPE_NORMAL
- en: We may also have good luck by editing the `print_tabular` method to print different
    attributes of the Nodes in the Graph. (For example, we might want to see the Node’s
    `input_nodes` and `users`.)
  prefs: []
  type: TYPE_NORMAL
- en: '### Available Debuggers'
  prefs: []
  type: TYPE_NORMAL
- en: The most common Python debugger is [pdb](https://docs.python.org/3/library/pdb.html).
    You can start your program in “debug mode” with `pdb` by typing `python -m pdb
    FILENAME.py` into the command line, where `FILENAME` is the name of the file you
    want to debug. After that, you can use the `pdb` [debugger commands](https://docs.python.org/3/library/pdb.html#debugger-commands)
    to move through your running program stepwise. It’s common to set a breakpoint
    (`b LINE-NUMBER`) when you start `pdb`, then call `c` to run the program until
    that point. This prevents you from having to step through each line of execution
    (using `s` or `n`) to get to the part of the code you want to examine. Alternatively,
    you can write `import pdb; pdb.set_trace()` before the line you want to break
    at. If you add `pdb.set_trace()`, your program will automatically start in debug
    mode when you run it. (In other words, you can just type `python FILENAME.py`
    into the command line instead of `python -m pdb FILENAME.py`.) Once you’re running
    your file in debug mode, you can step through the code and examine your program’s
    internal state using certain commands. There are many excellent tutorials on `pdb`
    online, including RealPython’s [“Python Debugging With Pdb”](https://realpython.com/python-debugging-pdb/).
  prefs: []
  type: TYPE_NORMAL
- en: 'IDEs like PyCharm or VSCode usually have a debugger built in. In your IDE,
    you can choose to either a) use `pdb` by pulling up a terminal window in your
    IDE (e.g. View → Terminal in VSCode), or b) use the built-in debugger (usually
    a graphical wrapper around `pdb`).  ## Limitations of Symbolic Tracing[](#limitations-of-symbolic-tracing
    "Permalink to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: FX uses a system of **symbolic tracing** (a.k.a [symbolic execution](https://en.wikipedia.org/wiki/Symbolic_execution))
    to capture the semantics of programs in a transformable/analyzable form. The system
    is **tracing** in that it executes the program (really a [`torch.nn.Module`](generated/torch.nn.Module.html#torch.nn.Module
    "torch.nn.Module") or function) to record operations. It is **symbolic** in that
    the data flowing through the program during this execution is not real data, but
    rather symbols ([`Proxy`](#torch.fx.Proxy "torch.fx.Proxy") in FX parlance).
  prefs: []
  type: TYPE_NORMAL
- en: Although symbolic tracing works for most neural net code, it has some limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Control Flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main limitation of symbolic tracing is it does not currently support *dynamic
    control flow*. That is, loops or `if` statements where the condition may depend
    on the input values of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s examine the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The condition to the `if` statement relies on the value of `x.sum()`, which
    relies on the value of `x`, a function input. Since `x` can change (i.e. if you
    pass a new input tensor to the traced function), this is *dynamic control flow*.
    The traceback walks back up through your code to show you where this situation
    happens.
  prefs: []
  type: TYPE_NORMAL
- en: Static Control Flow
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On the other hand, so-called *static control flow* is supported. Static control
    flow is loops or `if` statements whose value cannot change across invocations.
    Typically, in PyTorch programs, this control flow arises for code making decisions
    about a model’s architecture based on hyper-parameters. As a concrete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The if-statement `if self.do_activation` does not depend on any function inputs,
    thus it is static. `do_activation` can be considered to be a hyper-parameter,
    and the traces of different instances of `MyModule` with different values for
    that parameter have different code. This is a valid pattern that is supported
    by symbolic tracing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many instances of dynamic control flow are semantically static control flow.
    These instances can be made to support symbolic tracing by removing the data dependencies
    on input values, for example by moving values to `Module` attributes or by binding
    concrete values to arguments during symbolic tracing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the case of truly dynamic control flow, the sections of the program that
    contain this code can be traced as calls to the Method (see [Customizing Tracing
    with the Tracer class](#customizing-tracing)) or function (see [`wrap()`](#torch.fx.wrap
    "torch.fx.wrap")) rather than tracing through them.
  prefs: []
  type: TYPE_NORMAL
- en: Non-`torch` Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'FX uses `__torch_function__` as the mechanism by which it intercepts calls
    (see the [technical overview](https://github.com/pytorch/pytorch/blob/master/torch/fx/OVERVIEW.md#technical-details)
    for more information about this). Some functions, such as builtin Python functions
    or those in the `math` module, are not covered by `__torch_function__`, but we
    would still like to capture them in symbolic tracing. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The error tells us that the built-in function `len` is not supported. We can
    make it so that functions like this are recorded in the trace as direct calls
    using the [`wrap()`](#torch.fx.wrap "torch.fx.wrap") API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '### Customizing Tracing with the `Tracer` class[](#customizing-tracing-with-the-tracer-class
    "Permalink to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Tracer`](#torch.fx.Tracer "torch.fx.Tracer") class is the class that
    underlies the implementation of `symbolic_trace`. The behavior of tracing can
    be customized by subclassing Tracer, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Leaf Modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Leaf Modules are the modules that appear as calls in the symbolic trace rather
    than being traced through. The default set of leaf modules is the set of standard
    `torch.nn` module instances. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The set of leaf modules can be customized by overriding [`Tracer.is_leaf_module()`](#torch.fx.Tracer.is_leaf_module
    "torch.fx.Tracer.is_leaf_module").
  prefs: []
  type: TYPE_NORMAL
- en: Miscellanea
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tensor constructors (e.g. `torch.zeros`, `torch.ones`, `torch.rand`, `torch.randn`,
    `torch.sparse_coo_tensor`) are currently not traceable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deterministic constructors (`zeros`, `ones`) can be used and the value they
    produce will be embedded in the trace as a constant. This is only problematic
    if the arguments to these constructors refers to dynamic input sizes. In this
    case, `ones_like` or `zeros_like` may be a viable substitute.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Nondeterministic constructors (`rand`, `randn`) will have a single random value
    embedded in the trace. This is likely not the intended behavior. One workaround
    is to wrap `torch.randn` in a `torch.fx.wrap` function and call that instead.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
- en: This behavior may be fixed in a future release.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Type annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python 3-style type annotations (e.g. `func(x : torch.Tensor, y : int) -> torch.Tensor`)
    are supported and will be preserved by symbolic tracing.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python 2-style comment type annotations `# type: (torch.Tensor, int) -> torch.Tensor`
    are not currently supported.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotations on local names within a function are not currently supported.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Gotcha around `training` flag and submodules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using functionals like `torch.nn.functional.dropout`, it will be common
    for the training argument to be passed in as `self.training`. During FX tracing,
    this will likely be baked in as a constant value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
- en: However, when the standard `nn.Dropout()` submodule is used, the training flag
    is encapsulated and–because of the preservation of the `nn.Module` object model–can
    be changed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
- en: Because of this difference, consider marking modules that interact with the
    `training` flag dynamically as leaf modules.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: API Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Symbolic tracing API
  prefs: []
  type: TYPE_NORMAL
- en: Given an `nn.Module` or function instance `root`, this function will return
    a `GraphModule` constructed by recording operations seen while tracing through
    `root`.
  prefs: []
  type: TYPE_NORMAL
- en: '`concrete_args` allows you to partially specialize your function, whether it’s
    to remove control flow or data structures.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'FX can typically not trace through this due to the presence of control flow.
    However, we can use concrete_args to specialize on the value of b to trace through
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that although you can still pass in different values of b, they will be
    ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use concrete_args to eliminate data-structure handling from our
    function. This will use pytrees to flatten your input. To avoid overspecializing,
    pass in fx.PH for values that shouldn’t be specialized. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**root** (*Union**[*[*torch.nn.Module*](generated/torch.nn.Module.html#torch.nn.Module
    "torch.nn.Module")*,* *Callable**]*) – Module or function to be traced and converted
    into a Graph representation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**concrete_args** (*Optional**[**Dict**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*,* *any**]**]*) – Inputs to be partially specialized'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: a Module created from the recorded operations from `root`.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[GraphModule](#torch.fx.GraphModule "torch.fx.GraphModule")'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This function can be called at module-level scope to register fn_or_name as
    a “leaf function”. A “leaf function” will be preserved as a CallFunction node
    in the FX trace instead of being traced through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This function can also equivalently be used as a decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: A wrapped function can be thought of a “leaf function”, analogous to the concept
    of “leaf modules”, that is, they are functions that are left as calls in the FX
    trace rather than traced through.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**fn_or_name** (*Union**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*,* *Callable**]*) – The function or name of the global function
    to insert into the graph when it’s called'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: GraphModule is an nn.Module generated from an fx.Graph. Graphmodule has a `graph`
    attribute, as well as `code` and `forward` attributes generated from that `graph`.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: When `graph` is reassigned, `code` and `forward` will be automatically regenerated.
    However, if you edit the contents of the `graph` without reassigning the `graph`
    attribute itself, you must call `recompile()` to update the generated code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Construct a GraphModule.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**root** (*Union**[*[*torch.nn.Module*](generated/torch.nn.Module.html#torch.nn.Module
    "torch.nn.Module")*,* *Dict**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*,* *Any**]*) – `root` can either be an nn.Module instance
    or a Dict mapping strings to any attribute type. In the case that `root` is a
    Module, any references to Module-based objects (via qualified name) in the Graph’s
    Nodes’ `target` field will be copied over from the respective place within `root`’s
    Module hierarchy into the GraphModule’s module hierarchy. In the case that `root`
    is a dict, the qualified name found in a Node’s `target` will be looked up directly
    in the dict’s keys. The object mapped to by the Dict will be copied over into
    the appropriate place within the GraphModule’s module hierarchy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**graph** ([*Graph*](#torch.fx.Graph "torch.fx.Graph")) – `graph` contains
    the nodes this GraphModule should use for code generation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**class_name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")) – `name` denotes the name of this GraphModule for debugging
    purposes. If it’s unset, all error messages will report as originating from `GraphModule`.
    It may be helpful to set this to `root`’s original name or a name that makes sense
    within the context of your transform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Adds the given submodule to `self`.
  prefs: []
  type: TYPE_NORMAL
- en: This installs empty Modules where none exist yet if they are subpaths of `target`.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**target** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – The fully-qualified string name of the new submodule (See example
    in `nn.Module.get_submodule` for how to specify a fully-qualified string.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**m** ([*Module*](generated/torch.nn.Module.html#torch.nn.Module "torch.nn.modules.module.Module"))
    – The submodule itself; the actual object we want to install in the current Module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: Whether or not the submodule could be inserted. For
  prefs: []
  type: TYPE_NORMAL
- en: this method to return True, each object in the chain denoted by `target` must
    either a) not exist yet, or b) reference an `nn.Module` (not a parameter or other
    attribute)
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.12)")'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Return the Python code generated from the `Graph` underlying this `GraphModule`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Deletes all unused submodules from `self`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Module is considered “used” if any one of the following is true: 1\. It has
    children that are used 2\. Its forward is called directly via a `call_module`
    node 3\. It has a non-Module attribute that is used from a `get_attr` node'
  prefs: []
  type: TYPE_NORMAL
- en: This method can be called to clean up an `nn.Module` without manually calling
    `delete_submodule` on each unused submodule.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Deletes the given submodule from `self`.
  prefs: []
  type: TYPE_NORMAL
- en: The module will not be deleted if `target` is not a valid target.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**target** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – The fully-qualified string name of the new submodule (See example
    in `nn.Module.get_submodule` for how to specify a fully-qualified string.)'
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: Whether or not the target string referenced a
  prefs: []
  type: TYPE_NORMAL
- en: submodule we want to delete. A return value of `False` means that the `target`
    was not a valid reference to a submodule.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.12)")'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Return the `Graph` underlying this `GraphModule`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Return the Python code generated for current GraphModule and its children GraphModules
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: This API is experimental and is *NOT* backward-compatible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Recompile this GraphModule from its `graph` attribute. This should be called
    after editing the contained `graph`, otherwise the generated code of this `GraphModule`
    will be out of date.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '*PythonCode*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Dumps out module to `folder` with `module_name` so that it can be
  prefs: []
  type: TYPE_NORMAL
- en: imported with `from <folder> import <module_name>`
  prefs: []
  type: TYPE_NORMAL
- en: 'Args:'
  prefs: []
  type: TYPE_NORMAL
- en: 'folder (Union[str, os.PathLike]): The folder to write the code out to'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'module_name (str): Top-level name to use for the `Module` while'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: writing out the code
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: This API is experimental and is *NOT* backward-compatible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`Graph` is the main data structure used in the FX Intermediate Representation.
    It consists of a series of `Node` s, each representing callsites (or other syntactic
    constructs). The list of `Node` s, taken together, constitute a valid Python function.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the following code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Will produce the following Graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: For the semantics of operations represented in the `Graph`, please see [`Node`](#torch.fx.Node
    "torch.fx.Node").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Construct an empty Graph.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Insert a `call_function` `Node` into the `Graph`. A `call_function` node represents
    a call to a Python callable, specified by `the_function`.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**the_function** (*Callable**[**...**,* *Any**]*) – The function to be called.
    Can be any PyTorch operator, Python function, or member of the `builtins` or `operator`
    namespaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**args** (*Optional**[**Tuple**[**Argument**,* *...**]**]*) – The positional
    arguments to be passed to the called function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kwargs** (*Optional**[**Dict**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*,* *Argument**]**]*) – The keyword arguments to be passed
    to the called function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**type_expr** (*Optional**[**Any**]*) – an optional type annotation representing
    the Python type the output of this node will have.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: The newly created and inserted `call_function` node.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Node*](#torch.fx.Node "torch.fx.node.Node")'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The same insertion point and type expression rules apply for this method as
    [`Graph.create_node()`](#torch.fx.Graph.create_node "torch.fx.Graph.create_node").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Insert a `call_method` `Node` into the `Graph`. A `call_method` node represents
    a call to a given method on the 0th element of `args`.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**method_name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")) – The name of the method to apply to the self argument.
    For example, if args[0] is a `Node` representing a `Tensor`, then to call `relu()`
    on that `Tensor`, pass `relu` to `method_name`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**args** (*Optional**[**Tuple**[**Argument**,* *...**]**]*) – The positional
    arguments to be passed to the called method. Note that this *should* include a
    `self` argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kwargs** (*Optional**[**Dict**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*,* *Argument**]**]*) – The keyword arguments to be passed
    to the called method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**type_expr** (*Optional**[**Any**]*) – an optional type annotation representing
    the Python type the output of this node will have.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: The newly created and inserted `call_method` node.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Node*](#torch.fx.Node "torch.fx.node.Node")'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The same insertion point and type expression rules apply for this method as
    [`Graph.create_node()`](#torch.fx.Graph.create_node "torch.fx.Graph.create_node").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Insert a `call_module` `Node` into the `Graph`. A `call_module` node represents
    a call to the forward() function of a `Module` in the `Module` hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**module_name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")) – The qualified name of the `Module` in the `Module` hierarchy
    to be called. For example, if the traced `Module` has a submodule named `foo`,
    which has a submodule named `bar`, the qualified name `foo.bar` should be passed
    as `module_name` to call that module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**args** (*Optional**[**Tuple**[**Argument**,* *...**]**]*) – The positional
    arguments to be passed to the called method. Note that this should *not* include
    a `self` argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kwargs** (*Optional**[**Dict**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*,* *Argument**]**]*) – The keyword arguments to be passed
    to the called method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**type_expr** (*Optional**[**Any**]*) – an optional type annotation representing
    the Python type the output of this node will have.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: The newly-created and inserted `call_module` node.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Node*](#torch.fx.Node "torch.fx.node.Node")'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The same insertion point and type expression rules apply for this method as
    [`Graph.create_node()`](#torch.fx.Graph.create_node "torch.fx.Graph.create_node").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Create a `Node` and add it to the `Graph` at the current insert-point. Note
    that the current insert-point can be set via [`Graph.inserting_before()`](#torch.fx.Graph.inserting_before
    "torch.fx.Graph.inserting_before") and [`Graph.inserting_after()`](#torch.fx.Graph.inserting_after
    "torch.fx.Graph.inserting_after").
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**op** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python
    v3.12)")) – the opcode for this Node. One of ‘call_function’, ‘call_method’, ‘get_attr’,
    ‘call_module’, ‘placeholder’, or ‘output’. The semantics of these opcodes are
    described in the `Graph` docstring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**args** (*Optional**[**Tuple**[**Argument**,* *...**]**]*) – is a tuple of
    arguments to this node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kwargs** (*Optional**[**Dict**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*,* *Argument**]**]*) – the kwargs of this Node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**name** (*Optional**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]*) – an optional string name for the `Node`. This will influence
    the name of the value assigned to in the Python generated code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**type_expr** (*Optional**[**Any**]*) – an optional type annotation representing
    the Python type the output of this node will have.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: The newly-created and inserted node.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Node*](#torch.fx.Node "torch.fx.node.Node")'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Remove all dead code from the graph, based on each node’s number of users, and
    whether the nodes have any side effects. The graph must be topologically sorted
    before calling.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: Whether the graph was changed as a result of the pass.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.12)")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: Before dead code is eliminated, a from a = x + 1 below has no users and thus
    can be eliminated from the graph without having an effect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: After dead code is eliminated, a = x + 1 has been removed, and the rest of forward
    remains.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Dead code elimination has some heuristics to avoid removing side-effectful nodes
    (see Node.is_impure) but in general coverage is very bad, so you should assume
    that this method is not sound to call unless you know that your FX graph consists
    entirely of functional operations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Erases a `Node` from the `Graph`. Throws an exception if there are still users
    of that node in the `Graph`.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**to_erase** ([*Node*](#torch.fx.Node "torch.fx.Node")) – The `Node` to erase
    from the `Graph`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Insert a `get_attr` node into the Graph. A `get_attr` `Node` represents the
    fetch of an attribute from the `Module` hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**qualified_name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")) – the fully-qualified name of the attribute to be retrieved.
    For example, if the traced Module has a submodule named `foo`, which has a submodule
    named `bar`, which has an attribute named `baz`, the qualified name `foo.bar.baz`
    should be passed as `qualified_name`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**type_expr** (*Optional**[**Any**]*) – an optional type annotation representing
    the Python type the output of this node will have.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: The newly-created and inserted `get_attr` node.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Node*](#torch.fx.Node "torch.fx.node.Node")'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The same insertion point and type expression rules apply for this method as
    `Graph.create_node`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Copy all nodes from a given graph into `self`.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**g** ([*Graph*](#torch.fx.Graph "torch.fx.Graph")) – The source graph from
    which to copy Nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**val_map** (*Dict**[*[*Node*](#torch.fx.Node "torch.fx.Node")*,* [*Node*](#torch.fx.Node
    "torch.fx.Node")*]*) – a dictionary that will be populated with a mapping from
    nodes in `g` to nodes in `self`. Note that `val_map` can be passed in with values
    in it already to override copying of certain values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: The value in `self` that is now equivalent to the output value in `g`, if `g`
    had an `output` node. `None` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Optional*](https://docs.python.org/3/library/typing.html#typing.Optional
    "(in Python v3.12)")[[*Union*](https://docs.python.org/3/library/typing.html#typing.Union
    "(in Python v3.12)")[[*Tuple*](https://docs.python.org/3/library/typing.html#typing.Tuple
    "(in Python v3.12)")[[*Any*](https://docs.python.org/3/library/typing.html#typing.Any
    "(in Python v3.12)"), …], [*List*](https://docs.python.org/3/library/typing.html#typing.List
    "(in Python v3.12)")[[*Any*](https://docs.python.org/3/library/typing.html#typing.Any
    "(in Python v3.12)")], [*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict
    "(in Python v3.12)")[[str](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)"), [*Any*](https://docs.python.org/3/library/typing.html#typing.Any
    "(in Python v3.12)")], [slice](https://docs.python.org/3/library/functions.html#slice
    "(in Python v3.12)"), [range](https://docs.python.org/3/library/stdtypes.html#range
    "(in Python v3.12)"), [Node](#torch.fx.Node "torch.fx.Node"), [str](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)"), [int](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.12)"), [float](https://docs.python.org/3/library/functions.html#float
    "(in Python v3.12)"), [bool](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)"), [complex](https://docs.python.org/3/library/functions.html#complex
    "(in Python v3.12)"), [*dtype*](tensor_attributes.html#torch.dtype "torch.dtype"),
    [*Tensor*](tensors.html#torch.Tensor "torch.Tensor"), [*device*](tensor_attributes.html#torch.device
    "torch.device"), [*memory_format*](tensor_attributes.html#torch.memory_format
    "torch.memory_format"), [*layout*](tensor_attributes.html#torch.layout "torch.layout"),
    *OpOverload*]]'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Set the point at which create_node and companion methods will insert into the
    graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'When used within a ‘with’ statement, this will temporary set the insert point
    and then restore it when the with statement exits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Args:'
  prefs: []
  type: TYPE_NORMAL
- en: 'n (Optional[Node]): The node before which to insert. If None this will insert
    after'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: the beginning of the entire graph.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: A resource manager that will restore the insert point on `__exit__`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Set the point at which create_node and companion methods will insert into the
    graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'When used within a ‘with’ statement, this will temporary set the insert point
    and then restore it when the with statement exits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Args:'
  prefs: []
  type: TYPE_NORMAL
- en: 'n (Optional[Node]): The node before which to insert. If None this will insert
    before'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: the beginning of the entire graph.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: A resource manager that will restore the insert point on `__exit__`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Runs various checks on this Graph to make sure it is well-formed. In particular:
    - Checks Nodes have correct ownership (owned by this graph) - Checks Nodes appear
    in topological order - If this Graph has an owning GraphModule, checks that targets
    exist in that GraphModule'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy a node from one graph into another. `arg_transform` needs to transform
    arguments from the graph of node to the graph of self. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**node** ([*Node*](#torch.fx.Node "torch.fx.Node")) – The node to copy into
    `self`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**arg_transform** (*Callable**[**[*[*Node*](#torch.fx.Node "torch.fx.Node")*]**,*
    *Argument**]*) – A function that transforms `Node` arguments in node’s `args`
    and `kwargs` into the equivalent argument in `self`. In the simplest case, this
    should retrieve a value out of a table mapping Nodes in the original graph to
    `self`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Node*](#torch.fx.Node "torch.fx.node.Node")'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Get the list of Nodes that constitute this Graph.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this `Node` list representation is a doubly-linked list. Mutations
    during iteration (e.g. delete a Node, add a Node) are safe.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: A doubly-linked list of Nodes. Note that `reversed` can be called on this list
    to switch iteration order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Register a transformer function when python code is generated
  prefs: []
  type: TYPE_NORMAL
- en: 'Args:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'make_transformer (Callable[[Optional[TransformCodeFunc]], TransformCodeFunc]):'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a function that returns a code transformer to be registered. This function is
    called by on_generate_code to obtain the code transformer.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This function is also given as its input the currently registered code transformer
    (or None if nothing is registered), in case it is not desirable to overwrite it.
    This is useful to chain code transformers together.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a context manager that when used in a with statement, to automatically restore
    the previously registered code transformer.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Example:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This function can also be used as a context manager, with the benefit to automatically
    restores the previously registered code transformer:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: This API is experimental and is *NOT* backward-compatible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Insert an `output` `Node` into the `Graph`. An `output` node represents a `return`
    statement in Python code. `result` is the value that should be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**result** (*Argument*) – The value to be returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**type_expr** (*Optional**[**Any**]*) – an optional type annotation representing
    the Python type the output of this node will have.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The same insertion point and type expression rules apply for this method as
    `Graph.create_node`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Insert a `placeholder` node into the Graph. A `placeholder` represents a function
    input.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – A name for the input value. This corresponds to the name of
    the positional argument to the function this `Graph` represents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**type_expr** (*Optional**[**Any**]*) – an optional type annotation representing
    the Python type the output of this node will have. This is needed in some cases
    for proper code generation (e.g. when the function is used subsequently in TorchScript
    compilation).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**default_value** (*Any*) – The default value this function argument should
    take on. NOTE: to allow for None as a default value, inspect.Signature.empty should
    be passed as this argument to specify that the parameter does _not_ have a default
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Node*](#torch.fx.Node "torch.fx.node.Node")'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The same insertion point and type expression rules apply for this method as
    `Graph.create_node`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Prints the intermediate representation of the graph in tabular format. Note
    that this API requires the `tabulate` module to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Processes args so that they can be passed to the FX graph.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: This API is experimental and is *NOT* backward-compatible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: This API is experimental and is *NOT* backward-compatible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Turn this `Graph` into valid Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**root_module** ([*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")) – The name of the root module on which to look-up qualified
    name targets. This is usually ‘self’.'
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: 'src: the Python source code representing the object globals: a dictionary of
    global names in src -> the objects that they reference.'
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: A PythonCode object, consisting of two fields
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: This API is experimental and is *NOT* backward-compatible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '`Node` is the data structure that represents individual operations within a
    `Graph`. For the most part, Nodes represent callsites to various entities, such
    as operators, methods, and Modules (some exceptions include nodes that specify
    function inputs and outputs). Each `Node` has a function specified by its `op`
    property. The `Node` semantics for each value of `op` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`placeholder` represents a function input. The `name` attribute specifies the
    name this value will take on. `target` is similarly the name of the argument.
    `args` holds either: 1) nothing, or 2) a single argument denoting the default
    parameter of the function input. `kwargs` is don’t-care. Placeholders correspond
    to the function parameters (e.g. `x`) in the graph printout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_attr` retrieves a parameter from the module hierarchy. `name` is similarly
    the name the result of the fetch is assigned to. `target` is the fully-qualified
    name of the parameter’s position in the module hierarchy. `args` and `kwargs`
    are don’t-care'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`call_function` applies a free function to some values. `name` is similarly
    the name of the value to assign to. `target` is the function to be applied. `args`
    and `kwargs` represent the arguments to the function, following the Python calling
    convention'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`call_module` applies a module in the module hierarchy’s `forward()` method
    to given arguments. `name` is as previous. `target` is the fully-qualified name
    of the module in the module hierarchy to call. `args` and `kwargs` represent the
    arguments to invoke the module on, *excluding the self argument*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`call_method` calls a method on a value. `name` is as similar. `target` is
    the string name of the method to apply to the `self` argument. `args` and `kwargs`
    represent the arguments to invoke the module on, *including the self argument*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output` contains the output of the traced function in its `args[0]` attribute.
    This corresponds to the “return” statement in the Graph printout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Return all Nodes that are inputs to this Node. This is equivalent to iterating
    over `args` and `kwargs` and only collecting the values that are Nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: List of `Nodes` that appear in the `args` and `kwargs` of this `Node`, in that
    order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Insert `x` after this node in the list of nodes in the graph. Equivalent to
    `self.next.prepend(x)`
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**x** ([*Node*](#torch.fx.Node "torch.fx.Node")) – The node to put after this
    node. Must be a member of the same graph.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The tuple of arguments to this `Node`. The interpretation of arguments depends
    on the node’s opcode. See the [`Node`](#torch.fx.Node "torch.fx.Node") docstring
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment to this property is allowed. All accounting of uses and users is
    updated automatically on assignment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Return a descriptive string representation of `self`.
  prefs: []
  type: TYPE_NORMAL
- en: This method can be used with no arguments as a debugging utility.
  prefs: []
  type: TYPE_NORMAL
- en: This function is also used internally in the `__str__` method of `Graph`. Together,
    the strings in `placeholder_names` and `maybe_return_typename` make up the signature
    of the autogenerated `forward` function in this Graph’s surrounding GraphModule.
    `placeholder_names` and `maybe_return_typename` should not be used otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**placeholder_names** ([*Optional*](https://docs.python.org/3/library/typing.html#typing.Optional
    "(in Python v3.12)")*[*[*List*](https://docs.python.org/3/library/typing.html#typing.List
    "(in Python v3.12)")*[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]**]*) – A list that will store formatted strings representing
    the placeholders in the generated `forward` function. Internal use only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**maybe_return_typename** ([*Optional*](https://docs.python.org/3/library/typing.html#typing.Optional
    "(in Python v3.12)")*[*[*List*](https://docs.python.org/3/library/typing.html#typing.List
    "(in Python v3.12)")*[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]**]*) – A single-element list that will store a formatted
    string representing the output of the generated `forward` function. Internal use
    only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: If 1) we’re using `format_node` as an internal helper
  prefs: []
  type: TYPE_NORMAL
- en: in the `__str__` method of `Graph`, and 2) `self` is a placeholder Node, return
    `None`. Otherwise, return a descriptive string representation of the current Node.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Insert an positional argument to the argument list with given index.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**idx** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")) – The index of the element in `self.args` to be inserted before.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**arg** (*Argument*) – The new argument value to insert into `args`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Returns whether this op is impure, i.e. if its op is a placeholder or output,
    or if a call_function or call_module which is impure.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: If the op is impure or not.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.12)")'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: This API is experimental and is *NOT* backward-compatible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The dict of keyword arguments to this `Node`. The interpretation of arguments
    depends on the node’s opcode. See the [`Node`](#torch.fx.Node "torch.fx.Node")
    docstring for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment to this property is allowed. All accounting of uses and users is
    updated automatically on assignment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Returns the next `Node` in the linked list of Nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: The next `Node` in the linked list of Nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Returns normalized arguments to Python targets. This means that args/kwargs
    will be matched up to the module/functional’s signature and return exclusively
    kwargs in positional order if normalize_to_only_use_kwargs is true. Also populates
    default values. Does not support positional-only parameters or varargs parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Supports module calls.
  prefs: []
  type: TYPE_NORMAL
- en: May require arg_types and kwarg_types in order to disambiguate overloads.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**root** ([*torch.nn.Module*](generated/torch.nn.Module.html#torch.nn.Module
    "torch.nn.Module")) – Module upon which to resolve module targets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**arg_types** (*Optional**[**Tuple**[**Any**]**]*) – Tuple of arg types for
    the args'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kwarg_types** (*Optional**[**Dict**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*,* *Any**]**]*) – Dict of arg types for the kwargs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**normalize_to_only_use_kwargs** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")) – Whether to normalize to only use kwargs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: Returns NamedTuple ArgsKwargsPair, or None if not successful.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Optional*](https://docs.python.org/3/library/typing.html#typing.Optional
    "(in Python v3.12)")[*ArgsKwargsPair*]'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: This API is experimental and is *NOT* backward-compatible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert x before this node in the list of nodes in the graph. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**x** ([*Node*](#torch.fx.Node "torch.fx.Node")) – The node to put before this
    node. Must be a member of the same graph.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Returns the previous `Node` in the linked list of Nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: The previous `Node` in the linked list of Nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Replace all uses of `self` in the Graph with the Node `replace_with`.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**replace_with** ([*Node*](#torch.fx.Node "torch.fx.Node")) – The node to replace
    all uses of `self` with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**delete_user_cb** (*Callable*) – Callback that is called to determine whether
    a given user of the self node should be removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**propagate_meta** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")) – Whether or not to copy all properties on the .meta field
    of the original node onto the replacement node. For safety, this is only valid
    to do if the replacement node doesn’t already have an existing .meta field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: The list of Nodes on which this change was made.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python
    v3.12)")[[*Node*](#torch.fx.Node "torch.fx.node.Node")]'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Loop through input nodes of `self`, and replace all instances of `old_input`
    with `new_input`.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**old_input** ([*Node*](#torch.fx.Node "torch.fx.Node")) – The old input node
    to be replaced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**new_input** ([*Node*](#torch.fx.Node "torch.fx.Node")) – The new input node
    to replace `old_input`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Return the Python stack trace that was recorded during tracing, if any. When
    traced with fx.Tracer, this property is usually populated by Tracer.create_proxy.
    To record stack traces during tracing for debug purposes, set record_stack_traces
    = True on the Tracer instance. When traced with dynamo, this property will be
    populated by default by OutputGraph.create_proxy.
  prefs: []
  type: TYPE_NORMAL
- en: stack_trace would have the innermost frame at the end of the string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Update an existing positional argument to contain the new value `arg`. After
    calling, `self.args[idx] == arg`.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**idx** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")) – The index into `self.args` of the element to update'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**arg** (*Argument*) – The new argument value to write into `args`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Update an existing keyword argument to contain the new value `arg`. After calling,
    `self.kwargs[key] == arg`.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**key** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python
    v3.12)")) – The key in `self.kwargs` of the element to update'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**arg** (*Argument*) – The new argument value to write into `kwargs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '`Tracer` is the class that implements the symbolic tracing functionality of
    `torch.fx.symbolic_trace`. A call to `symbolic_trace(m)` is equivalent to `Tracer().trace(m)`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Tracer can be subclassed to override various behaviors of the tracing process.
    The different behaviors that can be overridden are described in the docstrings
    of the methods on this class.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Method that specifies the behavior of this `Tracer` when it encounters a call
    to an `nn.Module` instance.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the behavior is to check if the called module is a leaf module via
    `is_leaf_module`. If it is, emit a `call_module` node referring to `m` in the
    `Graph`. Otherwise, call the `Module` normally, tracing through the operations
    in its `forward` function.
  prefs: []
  type: TYPE_NORMAL
- en: This method can be overridden to–for example–create nested traced GraphModules,
    or any other behavior you would want while tracing across `Module` boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**m** ([*Module*](generated/torch.nn.Module.html#torch.nn.Module "torch.nn.Module"))
    – The module for which a call is being emitted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**forward** (*Callable*) – The forward() method of the `Module` to be invoked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**args** (*Tuple*) – args of the module callsite'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kwargs** (*Dict*) – kwargs of the module callsite'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: The return value from the Module call. In the case that a `call_module` node
    was emitted, this is a `Proxy` value. Otherwise, it is whatever value was returned
    from the `Module` invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Any*](https://docs.python.org/3/library/typing.html#typing.Any "(in Python
    v3.12)")'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: A method to specify the behavior of tracing when preparing values to be used
    as arguments to nodes in the `Graph`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the behavior includes:'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through collection types (e.g. tuple, list, dict) and recursively call
    `create_args` on the elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given a Proxy object, return a reference to the underlying IR `Node`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Given a non-Proxy Tensor object, emit IR for various cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a Parameter, emit a `get_attr` node referring to that Parameter
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: For a non-Parameter Tensor, store the Tensor away in a special attribute referring
    to that attribute.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: This method can be overridden to support more types.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**a** (*Any*) – The value to be emitted as an `Argument` in the `Graph`.'
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: The value `a` converted into the appropriate `Argument`
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Optional*](https://docs.python.org/3/library/typing.html#typing.Optional
    "(in Python v3.12)")[[*Union*](https://docs.python.org/3/library/typing.html#typing.Union
    "(in Python v3.12)")[[*Tuple*](https://docs.python.org/3/library/typing.html#typing.Tuple
    "(in Python v3.12)")[[*Any*](https://docs.python.org/3/library/typing.html#typing.Any
    "(in Python v3.12)"), …], [*List*](https://docs.python.org/3/library/typing.html#typing.List
    "(in Python v3.12)")[[*Any*](https://docs.python.org/3/library/typing.html#typing.Any
    "(in Python v3.12)")], [*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict
    "(in Python v3.12)")[[str](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)"), [*Any*](https://docs.python.org/3/library/typing.html#typing.Any
    "(in Python v3.12)")], [slice](https://docs.python.org/3/library/functions.html#slice
    "(in Python v3.12)"), [range](https://docs.python.org/3/library/stdtypes.html#range
    "(in Python v3.12)"), [Node](#torch.fx.Node "torch.fx.Node"), [str](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)"), [int](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.12)"), [float](https://docs.python.org/3/library/functions.html#float
    "(in Python v3.12)"), [bool](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)"), [complex](https://docs.python.org/3/library/functions.html#complex
    "(in Python v3.12)"), [*dtype*](tensor_attributes.html#torch.dtype "torch.dtype"),
    [*Tensor*](tensors.html#torch.Tensor "torch.Tensor"), [*device*](tensor_attributes.html#torch.device
    "torch.device"), [*memory_format*](tensor_attributes.html#torch.memory_format
    "torch.memory_format"), [*layout*](tensor_attributes.html#torch.layout "torch.layout"),
    *OpOverload*]]'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Create `placeholder` nodes corresponding to the signature of the `root` Module.
    This method introspects root’s signature and emits those nodes accordingly, also
    supporting `*args` and `**kwargs`.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: This API is experimental and is *NOT* backward-compatible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Inserts a graph node given target, args, kwargs, and name.
  prefs: []
  type: TYPE_NORMAL
- en: This method can be overridden to do extra checking, validation, or modification
    of values used in node creation. For example, one might want to disallow in-place
    operations from being recorded.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Node*](#torch.fx.Node "torch.fx.node.Node")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Create a Node from the given arguments, then return the Node wrapped in a Proxy
    object.
  prefs: []
  type: TYPE_NORMAL
- en: If kind = ‘placeholder’, then we’re creating a Node that represents the parameter
    of a function. If we need to encode a default parameter, we use the `args` tuple.
    `args` is otherwise empty for `placeholder` Nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Method that specifies the behavior of this `Tracer` when we call getattr on
    a call to an `nn.Module` instance.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the behavior is to return a proxy value for the attribute. It also
    stores the proxy value in the `parameter_proxy_cache`, so that future calls will
    reuse the proxy rather than creating a new one.
  prefs: []
  type: TYPE_NORMAL
- en: This method can be overridden to –for example– not return proxies when querying
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**attr** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – The name of the attribute being queried'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**attr_val** (*Any*) – The value of the attribute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**parameter_proxy_cache** (*Dict**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*,* *Any**]*) – A cache of attr names to proxies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: The return value from the getattr call.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: This API is experimental and is *NOT* backward-compatible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: A method to specify whether a given `nn.Module` is a “leaf” module.
  prefs: []
  type: TYPE_NORMAL
- en: Leaf modules are the atomic units that appear in the IR, referenced by `call_module`
    calls. By default, Modules in the PyTorch standard library namespace (torch.nn)
    are leaf modules. All other modules are traced through and their constituent ops
    are recorded, unless specified otherwise via this parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**m** ([*Module*](generated/torch.nn.Module.html#torch.nn.Module "torch.nn.Module"))
    – The module being queried about'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**module_qualified_name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")) – The path to root of this module. For example, if you have
    a module hierarchy where submodule `foo` contains submodule `bar`, which contains
    submodule `baz`, that module will appear with the qualified name `foo.bar.baz`
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.12)")'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Called when a proxy object is being iterated over, such as
  prefs: []
  type: TYPE_NORMAL
- en: when used in control flow. Normally we don’t know what to do because we don’t
    know the value of the proxy, but a custom tracer can attach more information to
    the graph node using create_node and can choose to return an iterator.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Iterator*](https://docs.python.org/3/library/typing.html#typing.Iterator
    "(in Python v3.12)")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Called when a proxy object is has the keys() method called.
  prefs: []
  type: TYPE_NORMAL
- en: This is what happens when ** is called on a proxy. This should return an iterator
    it ** is suppose to work in your custom tracer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Any*](https://docs.python.org/3/library/typing.html#typing.Any "(in Python
    v3.12)")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Helper method to find the qualified name of `mod` in the Module hierarchy of
    `root`. For example, if `root` has a submodule named `foo`, which has a submodule
    named `bar`, passing `bar` into this function will return the string “foo.bar”.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**mod** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python
    v3.12)")) – The `Module` to retrieve the qualified name for.'
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Proxy*](#torch.fx.Proxy "torch.fx.proxy.Proxy")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Called when a proxy object is being converted to a boolean, such as
  prefs: []
  type: TYPE_NORMAL
- en: when used in control flow. Normally we don’t know what to do because we don’t
    know the value of the proxy, but a custom tracer can attach more information to
    the graph node using create_node and can choose to return a value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.12)")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Trace `root` and return the corresponding FX `Graph` representation. `root`
    can either be an `nn.Module` instance or a Python callable.
  prefs: []
  type: TYPE_NORMAL
- en: Note that after this call, `self.root` may be different from the `root` passed
    in here. For example, when a free function is passed to `trace()`, we will create
    an `nn.Module` instance to use as the root and add embedded constants to.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**root** (*Union**[*[*Module*](generated/torch.nn.Module.html#torch.nn.Module
    "torch.nn.Module")*,* *Callable**]*) – Either a `Module` or a function to be traced
    through. Backwards-compatibility for this parameter is guaranteed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**concrete_args** (*Optional**[**Dict**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*,* *any**]**]*) – Concrete arguments that should not be treated
    as Proxies. This parameter is experimental and its backwards-compatibility is
    *NOT* guaranteed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: A `Graph` representing the semantics of the passed-in `root`.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Graph*](#torch.fx.Graph "torch.fx.graph.Graph")'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '`Proxy` objects are `Node` wrappers that flow through the program during symbolic
    tracing and record all the operations (`torch` function calls, method calls, operators)
    that they touch into the growing FX Graph.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re doing graph transforms, you can wrap your own `Proxy` method around
    a raw `Node` so that you can use the overloaded operators to add additional things
    to a `Graph`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Proxy` objects cannot be iterated. In other words, the symbolic tracer will
    throw an error if a `Proxy` is used in a loop or as an `*args`/`**kwargs` function
    argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main ways around this: 1\. Factor out the untraceable logic into
    a top-level function and use `fx.wrap` on it. 2\. If the control flow is static
    (i.e. the loop trip count is based on some hyperparameter), the code can be kept
    in its original position and refactored into something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: For a more detailed description into the Proxy internals, check out the “Proxy”
    section in torch/fx/OVERVIEW.md
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: An Interpreter executes an FX graph Node-by-Node. This pattern can be useful
    for many things, including writing code transformations as well as analysis passes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods in the Interpreter class can be overridden to customize the behavior
    of execution. The map of overrideable methods in terms of call hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to swap all instances of `torch.neg` with `torch.sigmoid` and
    vice versa (including their `Tensor` method equivalents). We could subclass Interpreter
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**module** ([*GraphModule*](#torch.fx.GraphModule "torch.fx.GraphModule"))
    – The module to be executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**garbage_collect_values** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")) – Whether to delete values after their last use within the
    Module’s execution. This ensures optimal memory usage during execution. This can
    be disabled to, for example, examine all of the intermediate values in the execution
    by looking at the `Interpreter.env` attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Run module via interpretation and return the result. This uses the “boxed” calling
    convention, where you pass a list of arguments, which will be cleared by the interpreter.
    This ensures that input tensors are promptly deallocated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Execute a `call_function` node and return the result.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**target** (*Target*) – The call target for this node. See [Node](https://pytorch.org/docs/master/fx.html#torch.fx.Node)
    for details on semantics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**args** (*Tuple*) – Tuple of positional args for this invocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kwargs** (*Dict*) – Dict of keyword arguments for this invocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Any*](https://docs.python.org/3/library/typing.html#typing.Any "(in Python
    v3.12)")'
  prefs: []
  type: TYPE_NORMAL
- en: Return
  prefs: []
  type: TYPE_NORMAL
- en: 'Any: The value returned by the function invocation'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Execute a `call_method` node and return the result.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**target** (*Target*) – The call target for this node. See [Node](https://pytorch.org/docs/master/fx.html#torch.fx.Node)
    for details on semantics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**args** (*Tuple*) – Tuple of positional args for this invocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kwargs** (*Dict*) – Dict of keyword arguments for this invocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Any*](https://docs.python.org/3/library/typing.html#typing.Any "(in Python
    v3.12)")'
  prefs: []
  type: TYPE_NORMAL
- en: Return
  prefs: []
  type: TYPE_NORMAL
- en: 'Any: The value returned by the method invocation'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Execute a `call_module` node and return the result.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**target** (*Target*) – The call target for this node. See [Node](https://pytorch.org/docs/master/fx.html#torch.fx.Node)
    for details on semantics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**args** (*Tuple*) – Tuple of positional args for this invocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kwargs** (*Dict*) – Dict of keyword arguments for this invocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Any*](https://docs.python.org/3/library/typing.html#typing.Any "(in Python
    v3.12)")'
  prefs: []
  type: TYPE_NORMAL
- en: Return
  prefs: []
  type: TYPE_NORMAL
- en: 'Any: The value returned by the module invocation'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Fetch the concrete values of `args` and `kwargs` of node `n` from the current
    execution environment.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**n** ([*Node*](#torch.fx.Node "torch.fx.Node")) – The node for which `args`
    and `kwargs` should be fetched.'
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: '`args` and `kwargs` with concrete values for `n`.'
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: Tuple[Tuple, Dict]
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Fetch an attribute from the `Module` hierarchy of `self.module`.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**target** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – The fully-qualified name of the attribute to fetch'
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: The value of the attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: Any
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Execute a `get_attr` node. Will retrieve an attribute value from the `Module`
    hierarchy of `self.module`.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**target** (*Target*) – The call target for this node. See [Node](https://pytorch.org/docs/master/fx.html#torch.fx.Node)
    for details on semantics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**args** (*Tuple*) – Tuple of positional args for this invocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kwargs** (*Dict*) – Dict of keyword arguments for this invocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: The value of the attribute that was retrieved
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: Any
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Recursively descend through `args` and look up the concrete value for each `Node`
    in the current execution environment.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**args** (*Argument*) – Data structure within which to look up concrete values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**n** ([*Node*](#torch.fx.Node "torch.fx.Node")) – Node to which `args` belongs.
    This is only used for error reporting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Optional*](https://docs.python.org/3/library/typing.html#typing.Optional
    "(in Python v3.12)")[[*Union*](https://docs.python.org/3/library/typing.html#typing.Union
    "(in Python v3.12)")[[*Tuple*](https://docs.python.org/3/library/typing.html#typing.Tuple
    "(in Python v3.12)")[[*Any*](https://docs.python.org/3/library/typing.html#typing.Any
    "(in Python v3.12)"), …], [*List*](https://docs.python.org/3/library/typing.html#typing.List
    "(in Python v3.12)")[[*Any*](https://docs.python.org/3/library/typing.html#typing.Any
    "(in Python v3.12)")], [*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict
    "(in Python v3.12)")[[str](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)"), [*Any*](https://docs.python.org/3/library/typing.html#typing.Any
    "(in Python v3.12)")], [slice](https://docs.python.org/3/library/functions.html#slice
    "(in Python v3.12)"), [range](https://docs.python.org/3/library/stdtypes.html#range
    "(in Python v3.12)"), [*Node*](#torch.fx.Node "torch.fx.node.Node"), [str](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)"), [int](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.12)"), [float](https://docs.python.org/3/library/functions.html#float
    "(in Python v3.12)"), [bool](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)"), [complex](https://docs.python.org/3/library/functions.html#complex
    "(in Python v3.12)"), [*dtype*](tensor_attributes.html#torch.dtype "torch.dtype"),
    [*Tensor*](tensors.html#torch.Tensor "torch.Tensor"), [*device*](tensor_attributes.html#torch.device
    "torch.device"), [*memory_format*](tensor_attributes.html#torch.memory_format
    "torch.memory_format"), [*layout*](tensor_attributes.html#torch.layout "torch.layout"),
    *OpOverload*]]'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Execute an `output` node. This really just retrieves the value referenced by
    the `output` node and returns it.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**target** (*Target*) – The call target for this node. See [Node](https://pytorch.org/docs/master/fx.html#torch.fx.Node)
    for details on semantics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**args** (*Tuple*) – Tuple of positional args for this invocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kwargs** (*Dict*) – Dict of keyword arguments for this invocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: The return value referenced by the output node
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: Any
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute a `placeholder` node. Note that this is stateful: `Interpreter` maintains
    an internal iterator over arguments passed to `run` and this method returns next()
    on that iterator.'
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**target** (*Target*) – The call target for this node. See [Node](https://pytorch.org/docs/master/fx.html#torch.fx.Node)
    for details on semantics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**args** (*Tuple*) – Tuple of positional args for this invocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kwargs** (*Dict*) – Dict of keyword arguments for this invocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: The argument value that was retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: Any
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Run module via interpretation and return the result.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '***args** – The arguments to the Module to run, in positional order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**initial_env** (*Optional**[**Dict**[*[*Node*](#torch.fx.Node "torch.fx.Node")*,*
    *Any**]**]*) – An optional starting environment for execution. This is a dict
    mapping Node to any value. This can be used, for example, to pre-populate results
    for certain Nodes so as to do only partial evaluation within the interpreter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**enable_io_processing** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")) – If true, we process the inputs and outputs with graph’s
    process_inputs and process_outputs function first before using them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: The value returned from executing the Module
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: Any
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Run a specific node `n` and return the result. Calls into placeholder, get_attr,
    call_function, call_method, call_module, or output depending on `node.op`
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**n** ([*Node*](#torch.fx.Node "torch.fx.Node")) – The Node to execute'
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: The result of executing `n`
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: Any
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '`Transformer` is a special type of interpreter that produces a new `Module`.
    It exposes a `transform()` method that returns the transformed `Module`. `Transformer`
    does not require arguments to run, as `Interpreter` does. `Transformer` works
    entirely symbolically.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to swap all instances of `torch.neg` with `torch.sigmoid` and
    vice versa (including their `Tensor` method equivalents). We could subclass `Transformer`
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**module** ([*GraphModule*](#torch.fx.GraphModule "torch.fx.GraphModule"))
    – The `Module` to be transformed.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Any*](https://docs.python.org/3/library/typing.html#typing.Any "(in Python
    v3.12)")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Any*](https://docs.python.org/3/library/typing.html#typing.Any "(in Python
    v3.12)")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Execute a `get_attr` node. In `Transformer`, this is overridden to insert a
    new `get_attr` node into the output graph.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**target** (*Target*) – The call target for this node. See [Node](https://pytorch.org/docs/master/fx.html#torch.fx.Node)
    for details on semantics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**args** (*Tuple*) – Tuple of positional args for this invocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kwargs** (*Dict*) – Dict of keyword arguments for this invocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Proxy*](#torch.fx.Proxy "torch.fx.proxy.Proxy")'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Execute a `placeholder` node. In `Transformer`, this is overridden to insert
    a new `placeholder` into the output graph.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**target** (*Target*) – The call target for this node. See [Node](https://pytorch.org/docs/master/fx.html#torch.fx.Node)
    for details on semantics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**args** (*Tuple*) – Tuple of positional args for this invocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kwargs** (*Dict*) – Dict of keyword arguments for this invocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*Proxy*](#torch.fx.Proxy "torch.fx.proxy.Proxy")'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Transform `self.module` and return the transformed `GraphModule`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: '[*GraphModule*](#torch.fx.GraphModule "torch.fx.graph_module.GraphModule")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Matches all possible non-overlapping sets of operators and their data dependencies
    (`pattern`) in the Graph of a GraphModule (`gm`), then replaces each of these
    matched subgraphs with another subgraph (`replacement`).
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**gm** ([*GraphModule*](#torch.fx.GraphModule "torch.fx.graph_module.GraphModule"))
    – The GraphModule that wraps the Graph to operate on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pattern** ([*Union*](https://docs.python.org/3/library/typing.html#typing.Union
    "(in Python v3.12)")*[*[*Callable*](https://docs.python.org/3/library/typing.html#typing.Callable
    "(in Python v3.12)")*,* [*GraphModule*](#torch.fx.GraphModule "torch.fx.graph_module.GraphModule")*]*)
    – The subgraph to match in `gm` for replacement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**replacement** ([*Union*](https://docs.python.org/3/library/typing.html#typing.Union
    "(in Python v3.12)")*[*[*Callable*](https://docs.python.org/3/library/typing.html#typing.Callable
    "(in Python v3.12)")*,* [*GraphModule*](#torch.fx.GraphModule "torch.fx.graph_module.GraphModule")*]*)
    – The subgraph to replace `pattern` with'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of `Match` objects representing the places in the original graph that
    `pattern` was matched to. The list is empty if there are no matches. `Match` is
    defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Return type
  prefs: []
  type: TYPE_NORMAL
- en: List[Match]
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: The above code will first match `pattern` in the `forward` method of `traced_module`.
    Pattern-matching is done based on use-def relationships, not node names. For example,
    if you had `p = torch.cat([a, b])` in `pattern`, you could match `m = torch.cat([a,
    b])` in the original `forward` function, despite the variable names being different
    (`p` vs `m`).
  prefs: []
  type: TYPE_NORMAL
- en: The `return` statement in `pattern` is matched based on its value only; it may
    or may not match to the `return` statement in the larger graph. In other words,
    the pattern doesn’t have to extend to the end of the larger graph.
  prefs: []
  type: TYPE_NORMAL
- en: When the pattern is matched, it will be removed from the larger function and
    replaced by `replacement`. If there are multiple matches for `pattern` in the
    larger function, each non-overlapping match will be replaced. In the case of a
    match overlap, the first found match in the set of overlapping matches will be
    replaced. (“First” here being defined as the first in a topological ordering of
    the Nodes’ use-def relationships. In most cases, the first Node is the parameter
    that appears directly after `self`, while the last Node is whatever the function
    returns.)
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to note is that the parameters of the `pattern` Callable
    must be used in the Callable itself, and the parameters of the `replacement` Callable
    must match the pattern. The first rule is why, in the above code block, the `forward`
    function has parameters `x, w1, w2`, but the `pattern` function only has parameters
    `w1, w2`. `pattern` doesn’t use `x`, so it shouldn’t specify `x` as a parameter.
    As an example of the second rule, consider replacing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `replacement` needs the same number of parameters as `pattern`
    (both `x` and `y`), even though the parameter `y` isn’t used in `replacement`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After calling `subgraph_rewriter.replace_pattern`, the generated Python code
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Backwards-compatibility for this API is guaranteed.
  prefs: []
  type: TYPE_NORMAL
