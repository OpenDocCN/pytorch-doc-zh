- en: torchrec.sparse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pytorch.org/torchrec/torchrec.sparse.html](https://pytorch.org/torchrec/torchrec.sparse.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Torchrec Jagged Tensors
  prefs: []
  type: TYPE_NORMAL
- en: 'It has 3 classes: JaggedTensor, KeyedJaggedTensor, KeyedTensor.'
  prefs: []
  type: TYPE_NORMAL
- en: JaggedTensor
  prefs: []
  type: TYPE_NORMAL
- en: It represents an (optionally weighted) jagged tensor. A JaggedTensor is a tensor
    with a jagged dimension which is dimension whose slices may be of different lengths.
    See KeyedJaggedTensor docstring for full example and further information.
  prefs: []
  type: TYPE_NORMAL
- en: KeyedJaggedTensor
  prefs: []
  type: TYPE_NORMAL
- en: KeyedJaggedTensor has additional “Key” information. Keyed on first dimesion,
    and jagged on last dimension. Please refer to KeyedJaggedTensor docstring for
    full example and further information.
  prefs: []
  type: TYPE_NORMAL
- en: KeyedTensor
  prefs: []
  type: TYPE_NORMAL
- en: KeyedTensor holds a concatenated list of dense tensors each of which can be
    accessed by a key. Keyed dimension can be variable length (length_per_key). Common
    use cases uses include storage of pooled embeddings of different dimensions. Please
    refer to KeyedTensor docstring for full example and further information.
  prefs: []
  type: TYPE_NORMAL
- en: '## torchrec.sparse.jagged_tensor[](#module-torchrec.sparse.jagged_tensor "Permalink
    to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Bases: `Module`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Converts a dict of JaggedTensors to KeyedJaggedTensor. Args:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: passing in jt_dict'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '“Feature0”: JaggedTensor([[V0,V1],None,V2]), “Feature1”: JaggedTensor([V3,V4,[V5,V6,V7]]),'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:: kjt with content: # 0 1 2 <– dim_1 # “Feature0” [V0,V1] None [V2]
    # “Feature1” [V3] [V4] [V5,V6,V7] # ^ # dim_0'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**jt_dict** – a dict of JaggedTensor'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: KeyedJaggedTensor
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Bases: `Module`'
  prefs: []
  type: TYPE_NORMAL
- en: Converts a KeyedJaggedTensor to a dict of JaggedTensors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Args:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '0 1 2 <– dim_1 # “Feature0” [V0,V1] None [V2] # “Feature1” [V3] [V4] [V5,V6,V7]
    # ^ # dim_0'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: would return
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '“Feature0”: JaggedTensor([[V0,V1],None,V2]), “Feature1”: JaggedTensor([V3,V4,[V5,V6,V7]]),'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Converts a KeyedJaggedTensor into a dict of JaggedTensors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**keyed_jagged_tensor** ([*KeyedJaggedTensor*](#torchrec.sparse.jagged_tensor.KeyedJaggedTensor
    "torchrec.sparse.jagged_tensor.KeyedJaggedTensor")) – tensor to convert'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: Dict[str, JaggedTensor]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Bases: `Pipelineable`'
  prefs: []
  type: TYPE_NORMAL
- en: Represents an (optionally weighted) jagged tensor.
  prefs: []
  type: TYPE_NORMAL
- en: A JaggedTensor is a tensor with a *jagged dimension* which is dimension whose
    slices may be of different lengths. See KeyedJaggedTensor for full example.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation is torch.jit.script-able.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We will NOT do input validation as it’s expensive, you should always pass in
    the valid lengths, offsets, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**values** (*torch.Tensor*) – values tensor in dense representation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**weights** (*Optional**[**torch.Tensor**]*) – if values have weights. Tensor
    with same shape as values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lengths** (*Optional**[**torch.Tensor**]*) – jagged slices, represented as
    lengths.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**offsets** (*Optional**[**torch.Tensor**]*) – jagged slices, represented as
    cumulative offsets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Constructs JaggedTensor from dense values/weights of shape (B, N,).
  prefs: []
  type: TYPE_NORMAL
- en: Note that lengths and offsets are still of shape (B,).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**values** (*List**[**torch.Tensor**]*) – a list of tensors for dense representation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**weights** (*Optional**[**List**[**torch.Tensor**]**]*) – if values have weights,
    tensor with the same shape as values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: JaggedTensor created from 2D dense tensor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[JaggedTensor](#torchrec.sparse.jagged_tensor.JaggedTensor "torchrec.sparse.jagged_tensor.JaggedTensor")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Constructs JaggedTensor from dense values/weights of shape (B, N,).
  prefs: []
  type: TYPE_NORMAL
- en: Note that lengths is still of shape (B,).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: See [https://pytorch.org/docs/stable/generated/torch.Tensor.record_stream.html](https://pytorch.org/docs/stable/generated/torch.Tensor.record_stream.html)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Please be aware that according to [https://pytorch.org/docs/stable/generated/torch.Tensor.to.html](https://pytorch.org/docs/stable/generated/torch.Tensor.to.html),
    to might return self or a copy of self. So please remember to use to with the
    assignment operator, for example, in = in.to(new_device).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Constructs a dense-representation of the JT’s values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: list of tensors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: List[torch.Tensor]
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Constructs a dense-representation of the JT’s weights.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: list of tensors, None if no weights.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: Optional[List[torch.Tensor]]
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Constructs a 2D dense tensor from the JT’s values of shape (B, N,).
  prefs: []
  type: TYPE_NORMAL
- en: Note that B is the length of self.lengths() and N is the longest feature length
    or desired_length.
  prefs: []
  type: TYPE_NORMAL
- en: If desired_length > length we will pad with padding_value, otherwise we will
    select the last value at desired_length.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**desired_length** (*int*) – the length of the tensor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**padding_value** (*float*) – padding value if we need to pad.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: 2d dense tensor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: torch.Tensor
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Constructs a 2D dense tensor from the JT’s weights of shape (B, N,).
  prefs: []
  type: TYPE_NORMAL
- en: Note that B is the length of self.lengths() and N is the longest feature length
    or desired_length.
  prefs: []
  type: TYPE_NORMAL
- en: If desired_length > length we will pad with padding_value, otherwise we will
    select the last value at desired_length.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**desired_length** (*int*) – the length of the tensor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**padding_value** (*float*) – padding value if we need to pad.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: 2d dense tensor, None if no weights.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: Optional[torch.Tensor]
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Bases: `ABCMeta`, `ProxyableClassMeta`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Bases: `Pipelineable`'
  prefs: []
  type: TYPE_NORMAL
- en: Represents an (optionally weighted) keyed jagged tensor.
  prefs: []
  type: TYPE_NORMAL
- en: A KeyedJaggedTensor is a tensor with a *jagged dimension* which is dimension
    whose slices may be of different lengths. Keyed on first dimension and jagged
    on the last dimension.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation is torch.jit.script-able.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**keys** (*List**[**str**]*) – keys to the jagged Tensor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**values** (*torch.Tensor*) – values tensor in dense representation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**weights** (*Optional**[**torch.Tensor**]*) – if the values have weights.
    Tensor with the same shape as values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lengths** (*Optional**[**torch.Tensor**]*) – jagged slices, represented as
    lengths.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**offsets** (*Optional**[**torch.Tensor**]*) – jagged slices, represented as
    cumulative offsets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**stride** (*Optional**[**int**]*) – number of examples per batch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**stride_per_key_per_rank** (*Optional**[**List**[**List**[**int**]**]**]*)
    – batch size (number of examples) per key per rank, with the outer list representing
    the keys and the inner list representing the values. Each value in the inner list
    represents the number of examples in the batch from the rank of its index in a
    distributed context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**length_per_key** (*Optional**[**List**[**int**]**]*) – start length for each
    key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**offset_per_key** (*Optional**[**List**[**int**]**]*) – start offset for each
    key and final offset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**index_per_key** (*Optional**[**Dict**[**str**,* *int**]**]*) – index for
    each key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jt_dict** (*Optional**[**Dict**[**str**,* [*JaggedTensor*](#torchrec.sparse.jagged_tensor.JaggedTensor
    "torchrec.sparse.jagged_tensor.JaggedTensor")*]**]*) –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**inverse_indices** (*Optional**[**Tuple**[**List**[**str**]**,* *torch.Tensor**]**]*)
    – inverse indices to expand deduplicated embedding output for variable stride
    per key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Constructs a KeyedJaggedTensor from a Dict[str, JaggedTensor], but this function
    will ONLY work if the JaggedTensors all have the same “implicit” batch_size dimension.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, we can visualize JaggedTensors as 2-D tensors of the format of [batch_size
    x variable_feature_dim]. In case, we have some batch without a feature value,
    the input JaggedTensor could just not include any values.
  prefs: []
  type: TYPE_NORMAL
- en: But KeyedJaggedTensor (by default) typically pad “None” so that all the JaggedTensors
    stored in the KeyedJaggedTensor have the same batch_size dimension. That is, in
    the case, the JaggedTensor input didn’t automatically pad for the empty batches,
    this function would error / not work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the visualization of the following KeyedJaggedTensor: # 0 1 2 <– dim_1
    # “Feature0” [V0,V1] None [V2] # “Feature1” [V3] [V4] [V5,V6,V7] # ^ # dim_0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the inputs for this KeyedJaggedTensor would have looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: 'values: torch.Tensor = [V0, V1, V2, V3, V4, V5, V6, V7] # V == any tensor datatype
    weights: torch.Tensor = [W0, W1, W2, W3, W4, W5, W6, W7] # W == any tensor datatype
    lengths: torch.Tensor = [2, 0, 1, 1, 1, 3] # representing the jagged slice offsets:
    torch.Tensor = [0, 2, 2, 3, 4, 5, 8] # offsets from 0 for each jagged slice keys:
    List[str] = [“Feature0”, “Feature1”] # correspond to each value of dim_0 index_per_key:
    Dict[str, int] = {“Feature0”: 0, “Feature1”: 1} # index for each key offset_per_key:
    List[int] = [0, 3, 8] # start offset for each key and final offset'
  prefs: []
  type: TYPE_NORMAL
- en: Now if the input jt_dict = {
  prefs: []
  type: TYPE_NORMAL
- en: '“Feature0” [V0,V1] [V2] # “Feature1” [V3] [V4] [V5,V6,V7]'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '} and the “None” is left out from each JaggedTensor, then this function would
    fail as we would not correctly be able to pad “None” as it does not technically
    know the correct batch / place to pad within the JaggedTensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, the lengths Tensor inferred by this function would be [2, 1, 1,
    1, 3] indicating variable batch_size dim_1 violates the existing assumption /
    precondition that KeyedJaggedTensor’s should have fixed batch_size dimension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: See [https://pytorch.org/docs/stable/generated/torch.Tensor.record_stream.html](https://pytorch.org/docs/stable/generated/torch.Tensor.record_stream.html)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Please be aware that according to [https://pytorch.org/docs/stable/generated/torch.Tensor.to.html](https://pytorch.org/docs/stable/generated/torch.Tensor.to.html),
    to might return self or a copy of self. So please remember to use to with the
    assignment operator, for example, in = in.to(new_device).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Bases: `Pipelineable`'
  prefs: []
  type: TYPE_NORMAL
- en: KeyedTensor holds a concatenated list of dense tensors, each of which can be
    accessed by a key.
  prefs: []
  type: TYPE_NORMAL
- en: The keyed dimension can be of variable length (length_per_key). Common use cases
    uses include storage of pooled embeddings of different dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation is torch.jit.script-able.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**keys** (*List**[**str**]*) – list of keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**length_per_key** (*List**[**int**]*) – length of each key along key dimension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**values** (*torch.Tensor*) – dense tensor, concatenated typically along key
    dimension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**key_dim** (*int*) – key dimension, zero indexed - defaults to 1 (typically
    B is 0-dimension).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: See [https://pytorch.org/docs/stable/generated/torch.Tensor.record_stream.html](https://pytorch.org/docs/stable/generated/torch.Tensor.record_stream.html)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Please be aware that according to [https://pytorch.org/docs/stable/generated/torch.Tensor.to.html](https://pytorch.org/docs/stable/generated/torch.Tensor.to.html),
    to might return self or a copy of self. So please remember to use to with the
    assignment operator, for example, in = in.to(new_device).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This function checks if two JaggedTensors are equal by comparing their internal
    representations. The comparison is done by comparing the values of the internal
    representations themselves. For optional fields, None values are treated as equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**jt_1** ([*JaggedTensor*](#torchrec.sparse.jagged_tensor.JaggedTensor "torchrec.sparse.jagged_tensor.JaggedTensor"))
    – the first JaggedTensor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jt_2** ([*JaggedTensor*](#torchrec.sparse.jagged_tensor.JaggedTensor "torchrec.sparse.jagged_tensor.JaggedTensor"))
    – the second JaggedTensor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: True if both JaggedTensors have the same values
  prefs: []
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This function checks if two KeyedJaggedTensors are equal by comparing their
    internal representations. The comparison is done by comparing the values of the
    internal representations themselves. For optional fields, None values are treated
    as equal. We compare the keys by ensuring that they have the same length and that
    the corresponding keys are the same order and same values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**kjt_1** ([*KeyedJaggedTensor*](#torchrec.sparse.jagged_tensor.KeyedJaggedTensor
    "torchrec.sparse.jagged_tensor.KeyedJaggedTensor")) – the first KeyedJaggedTensor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kjt_2** ([*KeyedJaggedTensor*](#torchrec.sparse.jagged_tensor.KeyedJaggedTensor
    "torchrec.sparse.jagged_tensor.KeyedJaggedTensor")) – the second KeyedJaggedTensor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: True if both KeyedJaggedTensors have the same values
  prefs: []
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'bool  ## Module contents[](#module-0 "Permalink to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Torchrec Jagged Tensors
  prefs: []
  type: TYPE_NORMAL
- en: 'It has 3 classes: JaggedTensor, KeyedJaggedTensor, KeyedTensor.'
  prefs: []
  type: TYPE_NORMAL
- en: JaggedTensor
  prefs: []
  type: TYPE_NORMAL
- en: It represents an (optionally weighted) jagged tensor. A JaggedTensor is a tensor
    with a jagged dimension which is dimension whose slices may be of different lengths.
    See KeyedJaggedTensor docstring for full example and further information.
  prefs: []
  type: TYPE_NORMAL
- en: KeyedJaggedTensor
  prefs: []
  type: TYPE_NORMAL
- en: KeyedJaggedTensor has additional “Key” information. Keyed on first dimesion,
    and jagged on last dimension. Please refer to KeyedJaggedTensor docstring for
    full example and further information.
  prefs: []
  type: TYPE_NORMAL
- en: KeyedTensor
  prefs: []
  type: TYPE_NORMAL
- en: KeyedTensor holds a concatenated list of dense tensors each of which can be
    accessed by a key. Keyed dimension can be variable length (length_per_key). Common
    use cases uses include storage of pooled embeddings of different dimensions. Please
    refer to KeyedTensor docstring for full example and further information.
  prefs: []
  type: TYPE_NORMAL
