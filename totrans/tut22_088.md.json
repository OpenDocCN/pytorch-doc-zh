["```py\ntorch::Tensor  warp_perspective(torch::Tensor  image,  torch::Tensor  warp)  {\n  // BEGIN image_mat\n  cv::Mat  image_mat(/*rows=*/image.size(0),\n  /*cols=*/image.size(1),\n  /*type=*/CV_32FC1,\n  /*data=*/image.data_ptr<float>());\n  // END image_mat\n\n  // BEGIN warp_mat\n  cv::Mat  warp_mat(/*rows=*/warp.size(0),\n  /*cols=*/warp.size(1),\n  /*type=*/CV_32FC1,\n  /*data=*/warp.data_ptr<float>());\n  // END warp_mat\n\n  // BEGIN output_mat\n  cv::Mat  output_mat;\n  cv::warpPerspective(image_mat,  output_mat,  warp_mat,  /*dsize=*/{8,  8});\n  // END output_mat\n\n  // BEGIN output_tensor\n  torch::Tensor  output  =  torch::from_blob(output_mat.ptr<float>(),  /*sizes=*/{8,  8});\n  return  output.clone();\n  // END output_tensor\n} \n```", "```py\n cv::Mat  image_mat(/*rows=*/image.size(0),\n  /*cols=*/image.size(1),\n  /*type=*/CV_32FC1,\n  /*data=*/image.data_ptr<float>()); \n```", "```py\n cv::Mat  warp_mat(/*rows=*/warp.size(0),\n  /*cols=*/warp.size(1),\n  /*type=*/CV_32FC1,\n  /*data=*/warp.data_ptr<float>()); \n```", "```py\n cv::Mat  output_mat;\n  cv::warpPerspective(image_mat,  output_mat,  warp_mat,  /*dsize=*/{8,  8}); \n```", "```py\n torch::Tensor  output  =  torch::from_blob(output_mat.ptr<float>(),  /*sizes=*/{8,  8});\n  return  output.clone(); \n```", "```py\nTORCH_LIBRARY(my_ops,  m)  {\n  m.def(\"warp_perspective\",  warp_perspective);\n} \n```", "```py\nconda install -c pytorch pytorch\nconda install opencv \n```", "```py\nwarp-perspective/\n  op.cpp\n  CMakeLists.txt \n```", "```py\ncmake_minimum_required(VERSION  3.1  FATAL_ERROR)\nproject(warp_perspective)\n\nfind_package(Torch  REQUIRED)\nfind_package(OpenCV  REQUIRED)\n\n# Define our library target\nadd_library(warp_perspective  SHARED  op.cpp)\n# Enable C++14\ntarget_compile_features(warp_perspective  PRIVATE  cxx_std_14)\n# Link against LibTorch\ntarget_link_libraries(warp_perspective  \"${TORCH_LIBRARIES}\")\n# Link against OpenCV\ntarget_link_libraries(warp_perspective  opencv_core  opencv_imgproc) \n```", "```py\n$  mkdir  build\n$  cd  build\n$  cmake  -DCMAKE_PREFIX_PATH=\"$(python  -c  'import torch.utils; print(torch.utils.cmake_prefix_path)')\"  ..\n--  The  C  compiler  identification  is  GNU  5.4.0\n--  The  CXX  compiler  identification  is  GNU  5.4.0\n--  Check  for  working  C  compiler:  /usr/bin/cc\n--  Check  for  working  C  compiler:  /usr/bin/cc  --  works\n--  Detecting  C  compiler  ABI  info\n--  Detecting  C  compiler  ABI  info  -  done\n--  Detecting  C  compile  features\n--  Detecting  C  compile  features  -  done\n--  Check  for  working  CXX  compiler:  /usr/bin/c++\n--  Check  for  working  CXX  compiler:  /usr/bin/c++  --  works\n--  Detecting  CXX  compiler  ABI  info\n--  Detecting  CXX  compiler  ABI  info  -  done\n--  Detecting  CXX  compile  features\n--  Detecting  CXX  compile  features  -  done\n--  Looking  for  pthread.h\n--  Looking  for  pthread.h  -  found\n--  Looking  for  pthread_create\n--  Looking  for  pthread_create  -  not  found\n--  Looking  for  pthread_create  in  pthreads\n--  Looking  for  pthread_create  in  pthreads  -  not  found\n--  Looking  for  pthread_create  in  pthread\n--  Looking  for  pthread_create  in  pthread  -  found\n--  Found  Threads:  TRUE\n--  Found  torch:  /libtorch/lib/libtorch.so\n--  Configuring  done\n--  Generating  done\n--  Build  files  have  been  written  to:  /warp_perspective/build\n$  make  -j\nScanning  dependencies  of  target  warp_perspective\n[  50%]  Building  CXX  object  CMakeFiles/warp_perspective.dir/op.cpp.o\n[100%]  Linking  CXX  shared  library  libwarp_perspective.so\n[100%]  Built  target  warp_perspective \n```", "```py\nimport torch\ntorch.ops.load_library(\"build/libwarp_perspective.so\")\nprint(torch.ops.my_ops.warp_perspective) \n```", "```py\n<built-in method my_ops::warp_perspective of PyCapsule object at 0x7f618fc6fa50> \n```", "```py\nimport torch\ntorch.ops.load_library(\"build/libwarp_perspective.so\")\nprint(torch.ops.my_ops.warp_perspective(torch.randn(32, 32), torch.rand(3, 3))) \n```", "```py\ntensor([[0.0000, 0.3218, 0.4611,  ..., 0.4636, 0.4636, 0.4636],\n      [0.3746, 0.0978, 0.5005,  ..., 0.4636, 0.4636, 0.4636],\n      [0.3245, 0.0169, 0.0000,  ..., 0.4458, 0.4458, 0.4458],\n      ...,\n      [0.1862, 0.1862, 0.1692,  ..., 0.0000, 0.0000, 0.0000],\n      [0.1862, 0.1862, 0.1692,  ..., 0.0000, 0.0000, 0.0000],\n      [0.1862, 0.1862, 0.1692,  ..., 0.0000, 0.0000, 0.0000]]) \n```", "```py\ndef compute(x, y, z):\n    return x.matmul(y) + torch.relu(z) \n```", "```py\ninputs = [torch.randn(4, 8), torch.randn(8, 5), torch.randn(4, 5)]\ntrace = torch.jit.trace(compute, inputs)\nprint(trace.graph) \n```", "```py\ngraph(%x : Float(4:8, 8:1),\n      %y : Float(8:5, 5:1),\n      %z : Float(4:5, 5:1)):\n  %3 : Float(4:5, 5:1) = aten::matmul(%x, %y) # test.py:10:0\n  %4 : Float(4:5, 5:1) = aten::relu(%z) # test.py:10:0\n  %5 : int = prim::Constant[value=1]() # test.py:10:0\n  %6 : Float(4:5, 5:1) = aten::add(%3, %4, %5) # test.py:10:0\n  return (%6) \n```", "```py\ndef compute(x, y, z):\n    x = torch.ops.my_ops.warp_perspective(x, torch.eye(3))\n    return x.matmul(y) + torch.relu(z) \n```", "```py\ninputs = [torch.randn(4, 8), torch.randn(8, 5), torch.randn(8, 5)]\ntrace = torch.jit.trace(compute, inputs)\nprint(trace.graph) \n```", "```py\ngraph(%x.1 : Float(4:8, 8:1),\n      %y : Float(8:5, 5:1),\n      %z : Float(8:5, 5:1)):\n  %3 : int = prim::Constant[value=3]() # test.py:25:0\n  %4 : int = prim::Constant[value=6]() # test.py:25:0\n  %5 : int = prim::Constant[value=0]() # test.py:25:0\n  %6 : Device = prim::Constant[value=\"cpu\"]() # test.py:25:0\n  %7 : bool = prim::Constant[value=0]() # test.py:25:0\n  %8 : Float(3:3, 3:1) = aten::eye(%3, %4, %5, %6, %7) # test.py:25:0\n  %x : Float(8:8, 8:1) = my_ops::warp_perspective(%x.1, %8) # test.py:25:0\n  %10 : Float(8:5, 5:1) = aten::matmul(%x, %y) # test.py:26:0\n  %11 : Float(8:5, 5:1) = aten::relu(%z) # test.py:26:0\n  %12 : int = prim::Constant[value=1]() # test.py:26:0\n  %13 : Float(8:5, 5:1) = aten::add(%10, %11, %12) # test.py:26:0\n  return (%13) \n```", "```py\ndef compute(x, y):\n  if bool(x[0][0] == 42):\n      z = 5\n  else:\n      z = 10\n  return x.matmul(y) + z \n```", "```py\n@torch.jit.script\ndef compute(x, y):\n  if bool(x[0][0] == 42):\n      z = 5\n  else:\n      z = 10\n  return x.matmul(y) + z \n```", "```py\n>>> compute.graph\ngraph(%x : Dynamic\n %y : Dynamic) {\n %14 : int = prim::Constant[value=1]()\n %2 : int = prim::Constant[value=0]()\n %7 : int = prim::Constant[value=42]()\n %z.1 : int = prim::Constant[value=5]()\n %z.2 : int = prim::Constant[value=10]()\n %4 : Dynamic = aten::select(%x, %2, %2)\n %6 : Dynamic = aten::select(%4, %2, %2)\n %8 : Dynamic = aten::eq(%6, %7)\n %9 : bool = prim::TensorToBool(%8)\n %z : int = prim::If(%9)\n block0() {\n -> (%z.1)\n }\n block1() {\n -> (%z.2)\n }\n %13 : Dynamic = aten::matmul(%x, %y)\n %15 : Dynamic = aten::add(%13, %z, %14)\n return (%15);\n} \n```", "```py\ntorch.ops.load_library(\"libwarp_perspective.so\")\n\n@torch.jit.script\ndef compute(x, y):\n  if bool(x[0] == 42):\n      z = 5\n  else:\n      z = 10\n  x = torch.ops.my_ops.warp_perspective(x, torch.eye(3))\n  return x.matmul(y) + z \n```", "```py\n>>> compute.graph\ngraph(%x.1 : Dynamic\n %y : Dynamic) {\n %20 : int = prim::Constant[value=1]()\n %16 : int[] = prim::Constant[value=[0, -1]]()\n %14 : int = prim::Constant[value=6]()\n %2 : int = prim::Constant[value=0]()\n %7 : int = prim::Constant[value=42]()\n %z.1 : int = prim::Constant[value=5]()\n %z.2 : int = prim::Constant[value=10]()\n %13 : int = prim::Constant[value=3]()\n %4 : Dynamic = aten::select(%x.1, %2, %2)\n %6 : Dynamic = aten::select(%4, %2, %2)\n %8 : Dynamic = aten::eq(%6, %7)\n %9 : bool = prim::TensorToBool(%8)\n %z : int = prim::If(%9)\n block0() {\n -> (%z.1)\n }\n block1() {\n -> (%z.2)\n }\n %17 : Dynamic = aten::eye(%13, %14, %2, %16)\n %x : Dynamic = my_ops::warp_perspective(%x.1, %17)\n %19 : Dynamic = aten::matmul(%x, %y)\n %21 : Dynamic = aten::add(%19, %z, %20)\n return (%21);\n } \n```", "```py\n#include  <torch/script.h> // One-stop header.\n\n#include  <iostream>\n#include  <memory>\n\nint  main(int  argc,  const  char*  argv[])  {\n  if  (argc  !=  2)  {\n  std::cerr  <<  \"usage: example-app <path-to-exported-script-module>\\n\";\n  return  -1;\n  }\n\n  // Deserialize the ScriptModule from a file using torch::jit::load().\n  torch::jit::script::Module  module  =  torch::jit::load(argv[1]);\n\n  std::vector<torch::jit::IValue>  inputs;\n  inputs.push_back(torch::randn({4,  8}));\n  inputs.push_back(torch::randn({8,  5}));\n\n  torch::Tensor  output  =  module.forward(std::move(inputs)).toTensor();\n\n  std::cout  <<  output  <<  std::endl;\n} \n```", "```py\ncmake_minimum_required(VERSION  3.1  FATAL_ERROR)\nproject(example_app)\n\nfind_package(Torch  REQUIRED)\n\nadd_executable(example_app  main.cpp)\ntarget_link_libraries(example_app  \"${TORCH_LIBRARIES}\")\ntarget_compile_features(example_app  PRIVATE  cxx_range_for) \n```", "```py\n$  mkdir  build\n$  cd  build\n$  cmake  -DCMAKE_PREFIX_PATH=\"$(python  -c  'import torch.utils; print(torch.utils.cmake_prefix_path)')\"  ..\n--  The  C  compiler  identification  is  GNU  5.4.0\n--  The  CXX  compiler  identification  is  GNU  5.4.0\n--  Check  for  working  C  compiler:  /usr/bin/cc\n--  Check  for  working  C  compiler:  /usr/bin/cc  --  works\n--  Detecting  C  compiler  ABI  info\n--  Detecting  C  compiler  ABI  info  -  done\n--  Detecting  C  compile  features\n--  Detecting  C  compile  features  -  done\n--  Check  for  working  CXX  compiler:  /usr/bin/c++\n--  Check  for  working  CXX  compiler:  /usr/bin/c++  --  works\n--  Detecting  CXX  compiler  ABI  info\n--  Detecting  CXX  compiler  ABI  info  -  done\n--  Detecting  CXX  compile  features\n--  Detecting  CXX  compile  features  -  done\n--  Looking  for  pthread.h\n--  Looking  for  pthread.h  -  found\n--  Looking  for  pthread_create\n--  Looking  for  pthread_create  -  not  found\n--  Looking  for  pthread_create  in  pthreads\n--  Looking  for  pthread_create  in  pthreads  -  not  found\n--  Looking  for  pthread_create  in  pthread\n--  Looking  for  pthread_create  in  pthread  -  found\n--  Found  Threads:  TRUE\n--  Found  torch:  /libtorch/lib/libtorch.so\n--  Configuring  done\n--  Generating  done\n--  Build  files  have  been  written  to:  /example_app/build\n$  make  -j\nScanning  dependencies  of  target  example_app\n[  50%]  Building  CXX  object  CMakeFiles/example_app.dir/main.cpp.o\n[100%]  Linking  CXX  executable  example_app\n[100%]  Built  target  example_app \n```", "```py\n$  ./example_app\nusage:  example_app  <path-to-exported-script-module> \n```", "```py\ntorch.ops.load_library(\"libwarp_perspective.so\")\n\n@torch.jit.script\ndef compute(x, y):\n  if bool(x[0][0] == 42):\n      z = 5\n  else:\n      z = 10\n  x = torch.ops.my_ops.warp_perspective(x, torch.eye(3))\n  return x.matmul(y) + z\n\ncompute.save(\"example.pt\") \n```", "```py\n$  ./example_app  example.pt\nterminate  called  after  throwing  an  instance  of  'torch::jit::script::ErrorReport'\nwhat():\nSchema  not  found  for  node.  File  a  bug  report.\nNode:  %16  :  Dynamic  =  my_ops::warp_perspective(%0,  %19) \n```", "```py\nexample_app/\n  CMakeLists.txt\n  main.cpp\n  warp_perspective/\n    CMakeLists.txt\n    op.cpp \n```", "```py\ncmake_minimum_required(VERSION  3.1  FATAL_ERROR)\nproject(example_app)\n\nfind_package(Torch  REQUIRED)\n\nadd_subdirectory(warp_perspective)\n\nadd_executable(example_app  main.cpp)\ntarget_link_libraries(example_app  \"${TORCH_LIBRARIES}\")\ntarget_link_libraries(example_app  -Wl,--no-as-needed  warp_perspective)\ntarget_compile_features(example_app  PRIVATE  cxx_range_for) \n```", "```py\nfind_package(OpenCV  REQUIRED)\nadd_library(warp_perspective  SHARED  op.cpp)\ntarget_compile_features(warp_perspective  PRIVATE  cxx_range_for)\ntarget_link_libraries(warp_perspective  PRIVATE  \"${TORCH_LIBRARIES}\")\ntarget_link_libraries(warp_perspective  PRIVATE  opencv_core  opencv_photo) \n```", "```py\n$  mkdir  build\n$  cd  build\n$  cmake  -DCMAKE_PREFIX_PATH=\"$(python  -c  'import torch.utils; print(torch.utils.cmake_prefix_path)')\"  ..\n--  The  C  compiler  identification  is  GNU  5.4.0\n--  The  CXX  compiler  identification  is  GNU  5.4.0\n--  Check  for  working  C  compiler:  /usr/bin/cc\n--  Check  for  working  C  compiler:  /usr/bin/cc  --  works\n--  Detecting  C  compiler  ABI  info\n--  Detecting  C  compiler  ABI  info  -  done\n--  Detecting  C  compile  features\n--  Detecting  C  compile  features  -  done\n--  Check  for  working  CXX  compiler:  /usr/bin/c++\n--  Check  for  working  CXX  compiler:  /usr/bin/c++  --  works\n--  Detecting  CXX  compiler  ABI  info\n--  Detecting  CXX  compiler  ABI  info  -  done\n--  Detecting  CXX  compile  features\n--  Detecting  CXX  compile  features  -  done\n--  Looking  for  pthread.h\n--  Looking  for  pthread.h  -  found\n--  Looking  for  pthread_create\n--  Looking  for  pthread_create  -  not  found\n--  Looking  for  pthread_create  in  pthreads\n--  Looking  for  pthread_create  in  pthreads  -  not  found\n--  Looking  for  pthread_create  in  pthread\n--  Looking  for  pthread_create  in  pthread  -  found\n--  Found  Threads:  TRUE\n--  Found  torch:  /libtorch/lib/libtorch.so\n--  Configuring  done\n--  Generating  done\n--  Build  files  have  been  written  to:  /warp_perspective/example_app/build\n$  make  -j\nScanning  dependencies  of  target  warp_perspective\n[  25%]  Building  CXX  object  warp_perspective/CMakeFiles/warp_perspective.dir/op.cpp.o\n[  50%]  Linking  CXX  shared  library  libwarp_perspective.so\n[  50%]  Built  target  warp_perspective\nScanning  dependencies  of  target  example_app\n[  75%]  Building  CXX  object  CMakeFiles/example_app.dir/main.cpp.o\n[100%]  Linking  CXX  executable  example_app\n[100%]  Built  target  example_app \n```", "```py\n$  ./example_app  example.pt\n11.4125  5.8262  9.5345  8.6111  12.3997\n  7.4683  13.5969  9.0850  11.0698  9.4008\n  7.4597  15.0926  12.5727  8.9319  9.0666\n  9.4834  11.1747  9.0162  10.9521  8.6269\n10.0000  10.0000  10.0000  10.0000  10.0000\n10.0000  10.0000  10.0000  10.0000  10.0000\n10.0000  10.0000  10.0000  10.0000  10.0000\n10.0000  10.0000  10.0000  10.0000  10.0000\n[  Variable[CPUFloatType]{8,5}  ] \n```", "```py\nimport torch.utils.cpp_extension\n\ntorch.utils.cpp_extension.load(\n    name=\"warp_perspective\",\n    sources=[\"op.cpp\"],\n    extra_ldflags=[\"-lopencv_core\", \"-lopencv_imgproc\"],\n    is_python_module=False,\n    verbose=True\n)\n\nprint(torch.ops.my_ops.warp_perspective) \n```", "```py\n<built-in method my_ops::warp_perspective of PyCapsule object at 0x7f3e0f840b10> \n```", "```py\nimport torch\nimport torch.utils.cpp_extension\n\nop_source = \"\"\"\n#include <opencv2/opencv.hpp>\n#include <torch/script.h>\n\ntorch::Tensor warp_perspective(torch::Tensor image, torch::Tensor warp) {\n cv::Mat image_mat(/*rows=*/image.size(0),\n /*cols=*/image.size(1),\n /*type=*/CV_32FC1,\n /*data=*/image.data<float>());\n cv::Mat warp_mat(/*rows=*/warp.size(0),\n /*cols=*/warp.size(1),\n /*type=*/CV_32FC1,\n /*data=*/warp.data<float>());\n\n cv::Mat output_mat;\n cv::warpPerspective(image_mat, output_mat, warp_mat, /*dsize=*/{64, 64});\n\n torch::Tensor output =\n torch::from_blob(output_mat.ptr<float>(), /*sizes=*/{64, 64});\n return output.clone();\n}\n\nTORCH_LIBRARY(my_ops, m) {\n m.def(\"warp_perspective\", &warp_perspective);\n}\n\"\"\"\n\ntorch.utils.cpp_extension.load_inline(\n    name=\"warp_perspective\",\n    cpp_sources=op_source,\n    extra_ldflags=[\"-lopencv_core\", \"-lopencv_imgproc\"],\n    is_python_module=False,\n    verbose=True,\n)\n\nprint(torch.ops.my_ops.warp_perspective) \n```", "```py\nfrom setuptools import setup\nfrom torch.utils.cpp_extension import BuildExtension, CppExtension\n\nsetup(\n    name=\"warp_perspective\",\n    ext_modules=[\n        CppExtension(\n            \"warp_perspective\",\n            [\"example_app/warp_perspective/op.cpp\"],\n            libraries=[\"opencv_core\", \"opencv_imgproc\"],\n        )\n    ],\n    cmdclass={\"build_ext\": BuildExtension.with_options(no_python_abi_suffix=True)},\n) \n```", "```py\n$  python  setup.py  build  develop\nrunning  build\nrunning  build_ext\nbuilding  'warp_perspective'  extension\ncreating  build\ncreating  build/temp.linux-x86_64-3.7\ngcc  -pthread  -B  /root/local/miniconda/compiler_compat  -Wl,--sysroot=/  -Wsign-compare  -DNDEBUG  -g  -fwrapv  -O3  -Wall  -Wstrict-prototypes  -fPIC  -I/root/local/miniconda/lib/python3.7/site-packages/torch/lib/include  -I/root/local/miniconda/lib/python3.7/site-packages/torch/lib/include/torch/csrc/api/include  -I/root/local/miniconda/lib/python3.7/site-packages/torch/lib/include/TH  -I/root/local/miniconda/lib/python3.7/site-packages/torch/lib/include/THC  -I/root/local/miniconda/include/python3.7m  -c  op.cpp  -o  build/temp.linux-x86_64-3.7/op.o  -DTORCH_API_INCLUDE_EXTENSION_H  -DTORCH_EXTENSION_NAME=warp_perspective  -D_GLIBCXX_USE_CXX11_ABI=0  -std=c++11\ncc1plus:  warning:  command  line  option  \u2018-Wstrict-prototypes\u2019  is  valid  for  C/ObjC  but  not  for  C++\ncreating  build/lib.linux-x86_64-3.7\ng++  -pthread  -shared  -B  /root/local/miniconda/compiler_compat  -L/root/local/miniconda/lib  -Wl,-rpath=/root/local/miniconda/lib  -Wl,--no-as-needed  -Wl,--sysroot=/  build/temp.linux-x86_64-3.7/op.o  -lopencv_core  -lopencv_imgproc  -o  build/lib.linux-x86_64-3.7/warp_perspective.so\nrunning  develop\nrunning  egg_info\ncreating  warp_perspective.egg-info\nwriting  warp_perspective.egg-info/PKG-INFO\nwriting  dependency_links  to  warp_perspective.egg-info/dependency_links.txt\nwriting  top-level  names  to  warp_perspective.egg-info/top_level.txt\nwriting  manifest  file  'warp_perspective.egg-info/SOURCES.txt'\nreading  manifest  file  'warp_perspective.egg-info/SOURCES.txt'\nwriting  manifest  file  'warp_perspective.egg-info/SOURCES.txt'\nrunning  build_ext\ncopying  build/lib.linux-x86_64-3.7/warp_perspective.so  ->\nCreating  /root/local/miniconda/lib/python3.7/site-packages/warp-perspective.egg-link  (link  to  .)\nAdding  warp-perspective  0.0.0  to  easy-install.pth  file\n\nInstalled  /warp_perspective\nProcessing  dependencies  for  warp-perspective==0.0.0\nFinished  processing  dependencies  for  warp-perspective==0.0.0 \n```", "```py\n>>> import torch\n>>> torch.ops.load_library(\"warp_perspective.so\")\n>>> print(torch.ops.my_ops.warp_perspective)\n<built-in method custom::warp_perspective of PyCapsule object at 0x7ff51c5b7bd0> \n```"]