- en: Audio Resampling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pytorch.org/audio/stable/tutorials/audio_resampling_tutorial.html](https://pytorch.org/audio/stable/tutorials/audio_resampling_tutorial.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Click [here](#sphx-glr-download-tutorials-audio-resampling-tutorial-py) to download
    the full example code
  prefs: []
  type: TYPE_NORMAL
- en: '**Author**: [Caroline Chen](mailto:carolinechen%40meta.com), [Moto Hira](mailto:moto%40meta.com)'
  prefs: []
  type: TYPE_NORMAL
- en: This tutorial shows how to use torchaudio’s resampling API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Preparation[](#preparation "Permalink to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we import the modules and define the helper functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Resampling Overview[](#resampling-overview "Permalink to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To resample an audio waveform from one freqeuncy to another, you can use [`torchaudio.transforms.Resample`](../generated/torchaudio.transforms.Resample.html#torchaudio.transforms.Resample
    "torchaudio.transforms.Resample") or [`torchaudio.functional.resample()`](../generated/torchaudio.functional.resample.html#torchaudio.functional.resample
    "torchaudio.functional.resample"). `transforms.Resample` precomputes and caches
    the kernel used for resampling, while `functional.resample` computes it on the
    fly, so using `torchaudio.transforms.Resample` will result in a speedup when resampling
    multiple waveforms using the same parameters (see Benchmarking section).
  prefs: []
  type: TYPE_NORMAL
- en: Both resampling methods use [bandlimited sinc interpolation](https://ccrma.stanford.edu/~jos/resample/)
    to compute signal values at arbitrary time steps. The implementation involves
    convolution, so we can take advantage of GPU / multithreading for performance
    improvements.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When using resampling in multiple subprocesses, such as data loading with multiple
    worker processes, your application might create more threads than your system
    can handle efficiently. Setting `torch.set_num_threads(1)` might help in this
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Because a finite number of samples can only represent a finite number of frequencies,
    resampling does not produce perfect results, and a variety of parameters can be
    used to control for its quality and computational speed. We demonstrate these
    properties through resampling a logarithmic sine sweep, which is a sine wave that
    increases exponentially in frequency over time.
  prefs: []
  type: TYPE_NORMAL
- en: The spectrograms below show the frequency representation of the signal, where
    the x-axis corresponds to the frequency of the original waveform (in log scale),
    y-axis the frequency of the plotted waveform, and color intensity the amplitude.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Original Waveform (sample rate: 48000 Hz)](../Images/4829c2c24744b1e2f7d0630418713af0.png)'
  prefs: []
  type: TYPE_IMG
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Your browser does not support the audio element.
  prefs: []
  type: TYPE_NORMAL
- en: Now we resample (downsample) it.
  prefs: []
  type: TYPE_NORMAL
- en: We see that in the spectrogram of the resampled waveform, there is an artifact,
    which was not present in the original waveform. This effect is called aliasing.
    [This page](https://music.arts.uci.edu/dobrian/digitalaudio.htm) has an explanation
    of how it happens, and why it looks like a reflection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![Resampled Waveform (sample rate: 32000 Hz)](../Images/530943db47ff518355ac0dbf53a165a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Your browser does not support the audio element.
  prefs: []
  type: TYPE_NORMAL
- en: Controling resampling quality with parameters[](#controling-resampling-quality-with-parameters
    "Permalink to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lowpass filter width[](#lowpass-filter-width "Permalink to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because the filter used for interpolation extends infinitely, the `lowpass_filter_width`
    parameter is used to control for the width of the filter to use to window the
    interpolation. It is also referred to as the number of zero crossings, since the
    interpolation passes through zero at every time unit. Using a larger `lowpass_filter_width`
    provides a sharper, more precise filter, but is more computationally expensive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![lowpass_filter_width=6 (sample rate: 32000 Hz)](../Images/45dd750d7c3da97fc9051829c27fc7b2.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![lowpass_filter_width=128 (sample rate: 32000 Hz)](../Images/d5a180554f37f4ec48baa92d074209c3.png)'
  prefs: []
  type: TYPE_IMG
- en: Rolloff[](#rolloff "Permalink to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `rolloff` parameter is represented as a fraction of the Nyquist frequency,
    which is the maximal frequency representable by a given finite sample rate. `rolloff`
    determines the lowpass filter cutoff and controls the degree of aliasing, which
    takes place when frequencies higher than the Nyquist are mapped to lower frequencies.
    A lower rolloff will therefore reduce the amount of aliasing, but it will also
    reduce some of the higher frequencies.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![rolloff=0.99 (sample rate: 32000 Hz)](../Images/73e6d2eda5bcb7c230394f27f7ca935b.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![rolloff=0.8 (sample rate: 32000 Hz)](../Images/b8b204173e6ec0cd89b161425597f3ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Window function[](#window-function "Permalink to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, `torchaudio`’s resample uses the Hann window filter, which is a
    weighted cosine function. It additionally supports the Kaiser window, which is
    a near optimal window function that contains an additional `beta` parameter that
    allows for the design of the smoothness of the filter and width of impulse. This
    can be controlled using the `resampling_method` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Hann Window Default (sample rate: 32000 Hz)](../Images/7a9d3553f8406ae1412e1f3bfdae214d.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![Kaiser Window Default (sample rate: 32000 Hz)](../Images/b6d0170397a6b38a7da22e8d7ef25067.png)'
  prefs: []
  type: TYPE_IMG
- en: Comparison against librosa[](#comparison-against-librosa "Permalink to this
    heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`torchaudio`’s resample function can be used to produce results similar to
    that of librosa (resampy)’s kaiser window resampling, with some noise'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: kaiser_best[](#kaiser-best "Permalink to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![Kaiser Window Best (torchaudio) (sample rate: 32000 Hz)](../Images/8aec6830a317bb9c0309c2a84439aa5f.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![Kaiser Window Best (librosa) (sample rate: 32000 Hz)](../Images/6949188dd67ae8061af503c94fe17f42.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: kaiser_fast[](#kaiser-fast "Permalink to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![Kaiser Window Fast (torchaudio) (sample rate: 32000 Hz)](../Images/732d2de8a83ea6f82132dac9ed2ae3b4.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![Kaiser Window Fast (librosa) (sample rate: 32000 Hz)](../Images/e9cc3877c66512afbc416517b5fa8f93.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Performance Benchmarking[](#performance-benchmarking "Permalink to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Below are benchmarks for downsampling and upsampling waveforms between two pairs
    of sampling rates. We demonstrate the performance implications that the `lowpass_filter_width`,
    window type, and sample rates can have. Additionally, we provide a comparison
    against `librosa`’s `kaiser_best` and `kaiser_fast` using their corresponding
    parameters in `torchaudio`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Downsample (48 -> 44.1 kHz)[](#downsample-48-44-1-khz "Permalink to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![audio resampling tutorial](../Images/b62690be19c44962e7aeb17c3db846a4.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Downsample (16 -> 8 kHz)[](#downsample-16-8-khz "Permalink to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![audio resampling tutorial](../Images/639cc35e0243f94f6360788351d67755.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Upsample (44.1 -> 48 kHz)[](#upsample-44-1-48-khz "Permalink to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![audio resampling tutorial](../Images/2784a6f807f63ed8fe6b4e90711818fb.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Upsample (8 -> 16 kHz)[](#upsample-8-16-khz "Permalink to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![audio resampling tutorial](../Images/5755f0ab1026efd7389bd278a704ed34.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Summary[](#summary "Permalink to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To elaborate on the results:'
  prefs: []
  type: TYPE_NORMAL
- en: a larger `lowpass_filter_width` results in a larger resampling kernel, and therefore
    increases computation time for both the kernel computation and convolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: using `sinc_interp_kaiser` results in longer computation times than the default
    `sinc_interp_hann` because it is more complex to compute the intermediate window
    values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a large GCD between the sample and resample rate will result in a simplification
    that allows for a smaller kernel and faster kernel computation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Total running time of the script:** ( 0 minutes 3.300 seconds)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Download Python source code: audio_resampling_tutorial.py`](../_downloads/59ad7db3945dd23dbc0f8d9eef766370/audio_resampling_tutorial.py)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Download Jupyter notebook: audio_resampling_tutorial.ipynb`](../_downloads/68fedf50687e692876b68727022ad06e/audio_resampling_tutorial.ipynb)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Gallery generated by Sphinx-Gallery](https://sphinx-gallery.github.io)'
  prefs: []
  type: TYPE_NORMAL
