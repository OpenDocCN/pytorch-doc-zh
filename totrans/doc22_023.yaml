- en: Numerical accuracy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pytorch.org/docs/stable/notes/numerical_accuracy.html](https://pytorch.org/docs/stable/notes/numerical_accuracy.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In modern computers, floating point numbers are represented using IEEE 754 standard.
    For more details on floating point arithmetics and IEEE 754 standard, please see
    [Floating point arithmetic](https://en.wikipedia.org/wiki/Floating-point_arithmetic)
    In particular, note that floating point provides limited accuracy (about 7 decimal
    digits for single precision floating point numbers, about 16 decimal digits for
    double precision floating point numbers) and that floating point addition and
    multiplication are not associative, so the order of the operations affects the
    results. Because of this, PyTorch is not guaranteed to produce bitwise identical
    results for floating point computations that are mathematically identical. Similarly,
    bitwise identical results are not guaranteed across PyTorch releases, individual
    commits, or different platforms. In particular, CPU and GPU results can be different
    even for bitwise-identical inputs and even after controlling for the sources of
    randomness.
  prefs: []
  type: TYPE_NORMAL
- en: Batched computations or slice computations[](#batched-computations-or-slice-computations
    "Permalink to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many operations in PyTorch support batched computation, where the same operation
    is performed for the elements of the batches of inputs. An example of this is
    [`torch.mm()`](../generated/torch.mm.html#torch.mm "torch.mm") and [`torch.bmm()`](../generated/torch.bmm.html#torch.bmm
    "torch.bmm"). It is possible to implement batched computation as a loop over batch
    elements, and apply the necessary math operations to the individual batch elements,
    for efficiency reasons we are not doing that, and typically perform computation
    for the whole batch. The mathematical libraries that we are calling, and PyTorch
    internal implementations of operations can produces slightly different results
    in this case, compared to non-batched computations. In particular, let `A` and
    `B` be 3D tensors with the dimensions suitable for batched matrix multiplication.
    Then `(A@B)[0]` (the first element of the batched result) is not guaranteed to
    be bitwise identical to `A[0]@B[0]` (the matrix product of the first elements
    of the input batches) even though mathematically it’s an identical computation.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, an operation applied to a tensor slice is not guaranteed to produce
    results that are identical to the slice of the result of the same operation applied
    to the full tensor. E.g. let `A` be a 2-dimensional tensor. `A.sum(-1)[0]` is
    not guaranteed to be bitwise equal to `A[:,0].sum()`.
  prefs: []
  type: TYPE_NORMAL
- en: Extremal values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When inputs contain large values such that intermediate results may overflow
    the range of the used datatype, the end result may overflow too, even though it
    is representable in the original datatype. E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '## Linear algebra (`torch.linalg`)[](#linear-algebra-torch-linalg "Permalink
    to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Non-finite values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The external libraries (backends) that `torch.linalg` uses provide no guarantees
    on their behaviour when the inputs have non-finite values like `inf` or `NaN`.
    As such, neither does PyTorch. The operations may return a tensor with non-finite
    values, or raise an exception, or even segfault.
  prefs: []
  type: TYPE_NORMAL
- en: Consider using [`torch.isfinite()`](../generated/torch.isfinite.html#torch.isfinite
    "torch.isfinite") before calling these functions to detect this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Extremal values in linalg
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions within `torch.linalg` have more [Extremal Values](#extremal-values)
    than other PyTorch functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Solvers](../linalg.html#linalg-solvers) and [Inverses](../linalg.html#linalg-inverses)
    assume that the input matrix `A` is invertible. If it is close to being non-invertible
    (for example, if it has a very small singular value), then these algorithms may
    silently return incorrect results. These matrices are said to be [ill-conditioned](https://nhigham.com/2020/03/19/what-is-a-condition-number/).
    If provided with ill-conditioned inputs, the result of these functions they may
    vary when using the same inputs on different devices or when using different backends
    via the keyword `driver`.'
  prefs: []
  type: TYPE_NORMAL
- en: Spectral operations like `svd`, `eig`, and `eigh` may also return incorrect
    results (and their gradients may be infinite) when their inputs have singular
    values that are close to each other. This is because the algorithms used to compute
    these decompositions struggle to converge for these inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Running the computation in `float64` (as NumPy does by default) often helps,
    but it does not solve these issues in all cases. Analyzing the spectrum of the
    inputs via [`torch.linalg.svdvals()`](../generated/torch.linalg.svdvals.html#torch.linalg.svdvals
    "torch.linalg.svdvals") or their condition number via [`torch.linalg.cond()`](../generated/torch.linalg.cond.html#torch.linalg.cond
    "torch.linalg.cond") may help to detect these issues.
  prefs: []
  type: TYPE_NORMAL
- en: TensorFloat-32(TF32) on Nvidia Ampere (and later) devices[](#tensorfloat-32-tf32-on-nvidia-ampere-and-later-devices
    "Permalink to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On Ampere (and later) Nvidia GPUs, PyTorch can use TensorFloat32 (TF32) to speed
    up mathematically intensive operations, in particular matrix multiplications and
    convolutions. When an operation is performed using TF32 tensor cores, only the
    first 10 bits of the input mantissa are read. This may reduce accuracy and produce
    surprising results (e.g., multiplying a matrix by the identity matrix may produce
    results that are different from the input). By default, TF32 tensor cores are
    disabled for matrix multiplications and enabled for convolutions, although most
    neural network workloads have the same convergence behavior when using TF32 as
    they have with fp32. We recommend enabling TF32 tensor cores for matrix multiplications
    with `torch.backends.cuda.matmul.allow_tf32 = True` if your network does not need
    full float32 precision. If your network needs full float32 precision for both
    matrix multiplications and convolutions, then TF32 tensor cores can also be disabled
    for convolutions with `torch.backends.cudnn.allow_tf32 = False`.
  prefs: []
  type: TYPE_NORMAL
- en: For more information see [TensorFloat32](cuda.html#tf32-on-ampere).
  prefs: []
  type: TYPE_NORMAL
- en: Reduced Precision Reduction for FP16 and BF16 GEMMs[](#reduced-precision-reduction-for-fp16-and-bf16-gemms
    "Permalink to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Half-precision GEMM operations are typically done with intermediate accumulations
    (reduction) in single-precision for numerical accuracy and improved resilience
    to overflow. For performance, certain GPU architectures, especially more recent
    ones, allow a few truncations of the intermediate accumulation results to the
    reduced precision (e.g., half-precision). This change is often benign from the
    perspective of model convergence, though it may lead to unexpected results (e.g.,
    `inf` values when the final result should be be representable in half-precision).
    If reduced-precision reductions are problematic, they can be turned off with `torch.backends.cuda.matmul.allow_fp16_reduced_precision_reduction
    = False`
  prefs: []
  type: TYPE_NORMAL
- en: A similar flag exists for BF16 GEMM operations and is turned on by default.
    If BF16 reduced-precision reductions are problematic, they can be turned off with
    `torch.backends.cuda.matmul.allow_bf16_reduced_precision_reduction = False`
  prefs: []
  type: TYPE_NORMAL
- en: For more information see [allow_fp16_reduced_precision_reduction](cuda.html#fp16reducedprecision)
    and [allow_bf16_reduced_precision_reduction](cuda.html#bf16reducedprecision)
  prefs: []
  type: TYPE_NORMAL
- en: '## Reduced Precision FP16 and BF16 GEMMs and Convolutions on AMD Instinct MI200
    devices[](#reduced-precision-fp16-and-bf16-gemms-and-convolutions-on-amd-instinct-mi200-devices
    "Permalink to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: On AMD Instinct MI200 GPUs, the FP16 and BF16 V_DOT2 and MFMA matrix instructions
    flush input and output denormal values to zero. FP32 and FP64 MFMA matrix instructions
    do not flush input and output denormal values to zero. The affected instructions
    are only used by rocBLAS (GEMM) and MIOpen (convolution) kernels; all other PyTorch
    operations will not encounter this behavior. All other supported AMD GPUs will
    not encounter this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: rocBLAS and MIOpen provide alternate implementations for affected FP16 operations.
    Alternate implementations for BF16 operations are not provided; BF16 numbers have
    a larger dynamic range than FP16 numbers and are less likely to encounter denormal
    values. For the FP16 alternate implementations, FP16 input values are cast to
    an intermediate BF16 value and then cast back to FP16 output after the accumulate
    FP32 operations. In this way, the input and output types are unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'When training using FP16 precision, some models may fail to converge with FP16
    denorms flushed to zero. Denormal values more frequently occur in the backward
    pass of training during gradient calculation. PyTorch by default will use the
    rocBLAS and MIOpen alternate implementations during the backward pass. The default
    behavior can be overridden using environment variables, ROCBLAS_INTERNAL_FP16_ALT_IMPL
    and MIOPEN_DEBUG_CONVOLUTION_ATTRIB_FP16_ALT_IMPL. The behavior of these environment
    variables is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | forward | backward |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Env unset | original | alternate |'
  prefs: []
  type: TYPE_TB
- en: '| Env set to 1 | alternate | alternate |'
  prefs: []
  type: TYPE_TB
- en: '| Env set to 0 | original | original |'
  prefs: []
  type: TYPE_TB
- en: 'The following is the list of operations where rocBLAS may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: torch.addbmm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: torch.addmm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: torch.baddbmm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: torch.bmm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: torch.mm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: torch.nn.GRUCell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: torch.nn.LSTMCell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: torch.nn.Linear
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: torch.sparse.addmm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'the following torch._C._ConvBackend implementations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: slowNd
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: slowNd_transposed
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: slowNd_dilated
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: slowNd_dilated_transposed
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the list of operations where MIOpen may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: torch.nn.Conv[Transpose]Nd
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'the following torch._C._ConvBackend implementations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ConvBackend::Miopen
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ConvBackend::MiopenDepthwise
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ConvBackend::MiopenTranspose
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
