["```pyframes_per_chunk`.\n\n    Providing `-1` disables chunking, in which case, method `[pop_chunks()](#classtorio_1_1io_1_1StreamingMediaDecoder_1aaddbcb821053bb30f8e106c2e838c8ef)` returns all the buffered frames as one chunk.\n\n*   **num_chunks** \u2013 Internal buffer size.\n\n    When the number of buffered chunks exceeds this number, old chunks are dropped. For example, if `frames_per_chunk` is 5 and `buffer_chunk_size` is 3, then frames older than 15 are dropped.\n\n    Providing `-1` disables this behavior, forcing the retention of all chunks.\n\n*   **filter_desc** \u2013 Description of filter graph applied to the source stream.\n\n*   **decoder** \u2013 The name of the decoder to be used. When provided, use the specified decoder instead of the default one.\n\n*   **decoder_option** \u2013 Options passed to decoder.\n\n    To list decoder options for a decoder, you can use `ffmpeg -h decoder=<DECODER>` command.\n\n    In addition to decoder-specific options, you can also pass options related to multithreading. They are effective only if the decoder supports them. If neither of them are provided, [StreamingMediaDecoder](#classtorio_1_1io_1_1StreamingMediaDecoder) defaults to single thread.\n\n    *   `\"threads\"`: The number of threads or the value `\"0\"` to let FFmpeg decide based on its heuristics.\n\n    *   `\"thread_type\"`: Which multithreading method to use. The valid values are `\"frame\"` or `\"slice\"`. Note that each decoder supports a different set of methods. If not provided, a default value is used.\n\n        *   `\"frame\"`: Decode more than one frame at once. Each thread handles one frame. This will increase decoding delay by one frame per thread\n\n        *   `\"slice\"`: Decode more than one part of a single frame at once.\n\n### add_video_stream[\u00b6](#add-video-stream \"Permalink to this heading\")\n\nvoid  torio::io::[StreamingMediaDecoder](#_CPPv4N5torio2io21StreamingMediaDecoderE \"torio::io::StreamingMediaDecoder\")::add_video_stream(int64_t  i, int64_t  frames_per_chunk, int64_t  num_chunks, const  c10::optional<std::string>  &filter_desc  =  c10::nullopt, const  c10::optional<std::string>  &decoder  =  c10::nullopt, const  c10::optional<OptionDict>  &decoder_option  =  c10::nullopt, const  c10::optional<std::string>  &hw_accel  =  c10::nullopt)[\u00b6](#_CPPv4N5torio2io21StreamingMediaDecoder16add_video_streamE7int64_t7int64_t7int64_tRKN3c108optionalINSt6stringEEERKN3c108optionalINSt6stringEEERKN3c108optionalI10OptionDictEERKN3c108optionalINSt6stringEEE \"Permalink to this definition\") \n\nDefine an output video stream.\n\nParameters:\n\n*   **i, frames_per_chunk, num_chunks, filter_desc, decoder, decoder_option** \u2013 See `[add_audio_stream()](#classtorio_1_1io_1_1StreamingMediaDecoder_1ab0ea1a8c8be1299d79119d05b806dcd1)`.\n\n*   **hw_accel** \u2013 Enable hardware acceleration.\n\n    When video is decoded on CUDA hardware, (for example by specifying `\"h264_cuvid\"` decoder), passing CUDA device indicator to `hw_accel` (i.e. `hw_accel=\"cuda:0\"`) will make [StreamingMediaDecoder](#classtorio_1_1io_1_1StreamingMediaDecoder) place the resulting frames directly on the specified CUDA device as a CUDA tensor.\n\n    If `None`, the chunk will be moved to CPU memory.\n\n### remove_stream[\u00b6](#remove-stream \"Permalink to this heading\")\n\nvoid  torio::io::[StreamingMediaDecoder](#_CPPv4N5torio2io21StreamingMediaDecoderE \"torio::io::StreamingMediaDecoder\")::remove_stream(int64_t  i)[\u00b6](#_CPPv4N5torio2io21StreamingMediaDecoder13remove_streamE7int64_t \"Permalink to this definition\") \n\nRemove an output stream.\n\nParameters:\n\n**i** \u2013 The index of the output stream to be removed. The valid value range is `[0, [num_out_streams()](#classtorio_1_1io_1_1StreamingMediaDecoder_1a2675b80361ce5ac9da29bb63105f1135))`.\n\n### Stream Methods[\u00b6](#stream-methods \"Permalink to this heading\")\n\n### seek[\u00b6](#seek \"Permalink to this heading\")\n\nvoid  torio::io::[StreamingMediaDecoder](#_CPPv4N5torio2io21StreamingMediaDecoderE \"torio::io::StreamingMediaDecoder\")::seek(double  timestamp, int64_t  mode)[\u00b6](#_CPPv4N5torio2io21StreamingMediaDecoder4seekEd7int64_t \"Permalink to this definition\") \n\nSeek into the given time stamp.\n\nParameters:\n\n*   **timestamp** \u2013 Target time stamp in second.\n\n*   **mode** \u2013 Seek mode.\n\n    *   `0`: Keyframe mode. Seek into nearest key frame before the given timestamp.\n\n    *   `1`: Any mode. Seek into any frame (including non-key frames) before the given timestamp.\n\n    *   `2`: Precise mode. First seek into the nearest key frame before the given timestamp, then decode frames until it reaches the frame closest to the given timestamp.\n\n### process_packet[\u00b6](#process-packet \"Permalink to this heading\")\n\nint  torio::io::[StreamingMediaDecoder](#_CPPv4N5torio2io21StreamingMediaDecoderE \"torio::io::StreamingMediaDecoder\")::process_packet()[\u00b6](#_CPPv4N5torio2io21StreamingMediaDecoder14process_packetEv \"Permalink to this definition\") \n\nDemultiplex and process one packet.\n\nReturns:\n\n*   `0`: A packet was processed successfully and there are still packets left in the stream, so client code can call this method again.\n\n*   `1`: A packet was processed successfully and it reached EOF. Client code should not call this method again.\n\n*   `<0`: An error has happened.\n\n### process_packet_block[\u00b6](#process-packet-block \"Permalink to this heading\")\n\nint  torio::io::[StreamingMediaDecoder](#_CPPv4N5torio2io21StreamingMediaDecoderE \"torio::io::StreamingMediaDecoder\")::process_packet_block(const  double  timeout, const  double  backoff)[\u00b6](#_CPPv4N5torio2io21StreamingMediaDecoder20process_packet_blockEKdKd \"Permalink to this definition\") \n\nSimilar to `[process_packet()](#classtorio_1_1io_1_1StreamingMediaDecoder_1a01fdf9e71bd58aeafcf2aeb4418a817c)`, but in case it fails due to resource temporarily being unavailable, it automatically retries.\n\nThis behavior is helpful when using device input, such as a microphone, during which the buffer may be busy while sample acquisition is happening.\n\nParameters:\n\n*   **timeout** \u2013 Timeout in milli seconds.\n\n    *   `>=0`: Keep retrying until the given time passes.\n\n    *   `<0`: Keep retrying forever.\n\n*   **backoff** \u2013 Time to wait before retrying in milli seconds.\n\n### process_all_packets[\u00b6](#process-all-packets \"Permalink to this heading\")\n\nvoid  torio::io::[StreamingMediaDecoder](#_CPPv4N5torio2io21StreamingMediaDecoderE \"torio::io::StreamingMediaDecoder\")::process_all_packets()[\u00b6](#_CPPv4N5torio2io21StreamingMediaDecoder19process_all_packetsEv \"Permalink to this definition\") \n\nProcess packets unitl EOF.\n\n### fill_buffer[\u00b6](#fill-buffer \"Permalink to this heading\")\n\nint  torio::io::[StreamingMediaDecoder](#_CPPv4N5torio2io21StreamingMediaDecoderE \"torio::io::StreamingMediaDecoder\")::fill_buffer(const  c10::optional<double>  &timeout  =  c10::nullopt, const  double  backoff  =  10.)[\u00b6](#_CPPv4N5torio2io21StreamingMediaDecoder11fill_bufferERKN3c108optionalIdEEKd \"Permalink to this definition\") \n\nProcess packets until all the chunk buffers have at least one chunk\n\nParameters:\n\n*   **timeout** \u2013 See `[process_packet_block()](#classtorio_1_1io_1_1StreamingMediaDecoder_1ab79ca75fbcf46543b5947762d4feba46)`\n\n*   **backoff** \u2013 See `[process_packet_block()](#classtorio_1_1io_1_1StreamingMediaDecoder_1ab79ca75fbcf46543b5947762d4feba46)`\n\n## Retrieval Methods[\u00b6](#retrieval-methods \"Permalink to this heading\")\n\n### pop_chunks[\u00b6](#pop-chunks \"Permalink to this heading\")\n\nstd::vector<c10::optional<[Chunk](#_CPPv4N5torio2io5ChunkE \"torio::io::Chunk\")>>  torio::io::[StreamingMediaDecoder](#_CPPv4N5torio2io21StreamingMediaDecoderE \"torio::io::StreamingMediaDecoder\")::pop_chunks()[\u00b6](#_CPPv4N5torio2io21StreamingMediaDecoder10pop_chunksEv \"Permalink to this definition\") \n\nPop one chunk from each output stream if it is available.\n\n## Support Structures[\u00b6](#support-structures \"Permalink to this heading\")\n\n### Chunk[\u00b6](#chunk \"Permalink to this heading\")\n\nstruct  Chunk[\u00b6](#_CPPv4N5torio2io5ChunkE \"Permalink to this definition\") \n\nStores decoded frames and metadata.\n\nPublic Members\n\ntorch::Tensor  frames[\u00b6](#_CPPv4N5torio2io5Chunk6framesE \"Permalink to this definition\") \n\nAudio/video frames.\n\nFor audio, the shape is `[time, num_channels]`, and the `dtype` depends on output stream configurations.\n\nFor video, the shape is `[time, channel, height, width]`, and the `dtype` is `torch.uint8`.\n\ndouble  pts[\u00b6](#_CPPv4N5torio2io5Chunk3ptsE \"Permalink to this definition\") \n\nPresentation time stamp of the first frame, in second.\n\n### SrcStreaminfo[\u00b6](#srcstreaminfo \"Permalink to this heading\")\n\nstruct  SrcStreamInfo[\u00b6](#_CPPv4N5torio2io13SrcStreamInfoE \"Permalink to this definition\") \n\nInformation about source stream found in the input media.\n\nCOMMON MEMBERS\n\nAVMediaType  media_type[\u00b6](#_CPPv4N5torio2io13SrcStreamInfo10media_typeE \"Permalink to this definition\") \n\nThe stream media type.\n\nPlease see refer to [the FFmpeg documentation](https://ffmpeg.org/doxygen/4.1/group__lavu__misc.html#ga9a84bba4713dfced21a1a56163be1f48) for the available values\n\n*Todo:*\n\nIntroduce own enum and get rid of FFmpeg dependency\n\nconst  char  *codec_name  =  \"N/A\"[\u00b6](#_CPPv4N5torio2io13SrcStreamInfo10codec_nameE \"Permalink to this definition\") \n\nThe name of codec.\n\nconst  char  *codec_long_name  =  \"N/A\"[\u00b6](#_CPPv4N5torio2io13SrcStreamInfo15codec_long_nameE \"Permalink to this definition\") \n\nThe name of codec in long, human friendly form.\n\nconst  char  *fmt_name  =  \"N/A\"[\u00b6](#_CPPv4N5torio2io13SrcStreamInfo8fmt_nameE \"Permalink to this definition\") \n\nFor audio, it is sample format.\n\nCommonly found values are;\n\n*   `\"u8\"`, `\"u8p\"`: 8-bit unsigned integer.\n\n*   `\"s16\"`, `\"s16p\"`: 16-bit signed integer.\n\n*   `\"s32\"`, `\"s32p\"`: 32-bit signed integer.\n\n*   `\"s64\"`, `\"s64p\"`: 64-bit signed integer.\n\n*   `\"flt\"`, `\"fltp\"`: 32-bit floating point.\n\n*   `\"dbl\"`, `\"dblp\"`: 64-bit floating point.\n\nFor video, it is color channel format.\n\nCommonly found values include;\n\n*   `\"gray8\"`: grayscale\n\n*   `\"rgb24\"`: RGB\n\n*   `\"bgr24\"`: BGR\n\n*   `\"yuv420p\"`: YUV420p\n\nint64_t  bit_rate  =  0[\u00b6](#_CPPv4N5torio2io13SrcStreamInfo8bit_rateE \"Permalink to this definition\") \n\nBit rate.\n\nint64_t  num_frames  =  0[\u00b6](#_CPPv4N5torio2io13SrcStreamInfo10num_framesE \"Permalink to this definition\") \n\nNumber of frames.\n\nNote\n\nIn some formats, the value is not reliable or unavailable.\n\nint  bits_per_sample  =  0[\u00b6](#_CPPv4N5torio2io13SrcStreamInfo15bits_per_sampleE \"Permalink to this definition\") \n\nBits per sample.\n\nOptionDict  metadata  =  {}[\u00b6](#_CPPv4N5torio2io13SrcStreamInfo8metadataE \"Permalink to this definition\") \n\nMetadata\n\nThis method can fetch ID3 tag from MP3.\n\nExample:\n\n```"]