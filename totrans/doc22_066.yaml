- en: torch.package
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: torch.package
- en: 原文：[https://pytorch.org/docs/stable/package.html](https://pytorch.org/docs/stable/package.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://pytorch.org/docs/stable/package.html](https://pytorch.org/docs/stable/package.html)
- en: '`torch.package` adds support for creating packages containing both artifacts
    and arbitrary PyTorch code. These packages can be saved, shared, used to load
    and execute models at a later date or on a different machine, and can even be
    deployed to production using `torch::deploy`.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`torch.package` 支持创建包含工件和任意PyTorch代码的包。这些包可以保存、共享，用于在以后的日期或不同机器上加载和执行模型，甚至可以使用`torch::deploy`部署到生产环境。'
- en: This document contains tutorials, how-to guides, explanations, and an API reference
    that will help you learn more about `torch.package` and how to use it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本文包含教程、指南、解释和API参考，将帮助您更多地了解`torch.package`及如何使用它。
- en: Warning
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: This module depends on the `pickle` module which is not secure. Only unpackage
    data you trust.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块依赖于不安全的`pickle`模块。只有解包您信任的数据。
- en: It is possible to construct malicious pickle data which will **execute arbitrary
    code during unpickling**. Never unpackage data that could have come from an untrusted
    source, or that could have been tampered with.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 可能构造恶意的pickle数据，将在解包时执行任意代码。永远不要解包可能来自不受信任来源或可能被篡改的数据。
- en: For more information, review the [documentation](https://docs.python.org/3/library/pickle.html)
    for the `pickle` module.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`pickle`模块的更多信息，请查看[文档](https://docs.python.org/3/library/pickle.html)。
- en: '[Tutorials](#tutorials)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[教程](#tutorials)'
- en: '[Packaging your first model](#packaging-your-first-model)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[打包您的第一个模型](#packaging-your-first-model)'
- en: '[How do I…](#how-do-i)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我该如何...](#how-do-i)'
- en: '[See what is inside a package?](#see-what-is-inside-a-package)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[查看包内部内容？](#see-what-is-inside-a-package)'
- en: '[See why a given module was included as a dependency?](#see-why-a-given-module-was-included-as-a-dependency)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[查看为什么某个模块被包含为依赖？](#see-why-a-given-module-was-included-as-a-dependency)'
- en: '[Include arbitrary resources with my package and access them later?](#include-arbitrary-resources-with-my-package-and-access-them-later)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何在我的包中包含任意资源并以后访问它们？](#include-arbitrary-resources-with-my-package-and-access-them-later)'
- en: '[Customize how a class is packaged?](#customize-how-a-class-is-packaged)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[自定义类如何打包？](#customize-how-a-class-is-packaged)'
- en: '[Test in my source code whether or not it is executing inside a package?](#test-in-my-source-code-whether-or-not-it-is-executing-inside-a-package)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我的源代码中测试是否在包内执行？
- en: '[Patch code into a package?](#patch-code-into-a-package)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将代码打补丁到包中？](#patch-code-into-a-package)'
- en: '[Access package contents from packaged code?](#access-package-contents-from-packaged-code)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[从打包的代码中访问包内容？](#access-package-contents-from-packaged-code)'
- en: '[Distinguish between packaged code and non-packaged code?](#distinguish-between-packaged-code-and-non-packaged-code)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[区分打包代码和非打包代码？](#distinguish-between-packaged-code-and-non-packaged-code)'
- en: '[Re-export an imported object?](#re-export-an-imported-object)'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[重新导出导入的对象？](#re-export-an-imported-object)'
- en: '[Package a TorchScript module?](#package-a-torchscript-module)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[打包一个TorchScript模块？](#package-a-torchscript-module)'
- en: '[Explanation](#explanation)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[解释](#explanation)'
- en: '[`torch.package` Format Overview](#torch-package-format-overview)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`torch.package` 格式概述](#torch-package-format-overview)'
- en: '[How `torch.package` finds your code’s dependencies](#how-torch-package-finds-your-code-s-dependencies)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`torch.package` 如何找到您代码的依赖](#how-torch-package-finds-your-code-s-dependencies)'
- en: '[Dependency Management](#dependency-management)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[依赖管理](#dependency-management)'
- en: '[`torch.package` sharp edges](#torch-package-sharp-edges)'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`torch.package` 的尖锐边缘](#torch-package-sharp-edges)'
- en: '[How `torch.package` keeps packages isolated from each other](#how-torch-package-keeps-packages-isolated-from-each-other)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`torch.package` 如何保持包之间的隔离](#how-torch-package-keeps-packages-isolated-from-each-other)'
- en: '[API Reference](#api-reference)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[API参考](#api-reference)'
- en: '[Tutorials](#id1)'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[教程](#id1)'
- en: '[Packaging your first model](#id2)[](#packaging-your-first-model "Permalink
    to this heading")'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[打包您的第一个模型](#id2)'
- en: A tutorial that guides you through packaging and unpackaging a simple model
    is available [on Colab](https://colab.research.google.com/drive/1lFZkLyViGfXxB-m3jqlyTQuYToo3XLo-).
    After completing this exercise, you will be familiar with the basic API for creating
    and using Torch packages.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了一个指导您打包和解包简单模型的教程[在Colab上](https://colab.research.google.com/drive/1lFZkLyViGfXxB-m3jqlyTQuYToo3XLo-)。完成这个练习后，您将熟悉用于创建和使用Torch包的基本API。
- en: '[How do I…](#id3)'
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[我该如何...](#id3)'
- en: '[See what is inside a package?](#id4)[](#see-what-is-inside-a-package "Permalink
    to this heading")'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[查看包内部内容？](#id4)'
- en: Treat the package like a ZIP archive[](#treat-the-package-like-a-zip-archive
    "Permalink to this heading")
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将包像ZIP存档一样处理
- en: 'The container format for a `torch.package` is ZIP, so any tools that work with
    standard ZIP files should work for exploring the contents. Some common ways to
    interact with ZIP files:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`torch.package`的容器格式是ZIP，因此任何可以处理标准ZIP文件的工具都可以用于探索内容。与ZIP文件交互的一些常见方法：'
- en: '`unzip my_package.pt` will unzip the `torch.package` archive to disk, where
    you can freely inspect its contents.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unzip my_package.pt` 将`torch.package`存档解压到磁盘上，您可以自由检查其内容。'
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Python `zipfile` module provides a standard way to read and write ZIP archive
    contents.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python的`zipfile`模块提供了一种标准的方法来读取和写入ZIP存档内容。
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: vim has the ability to natively read ZIP archives. You can even edit files and
    :`write` them back into the archive!
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: vim有本地读取ZIP存档的能力。您甚至可以编辑文件并将其`:write`回存档中！
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Use the `file_structure()` API[](#use-the-file-structure-api "Permalink to this
    heading")
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`file_structure()` API
- en: '[`PackageImporter`](#torch.package.PackageImporter "torch.package.PackageImporter")
    provides a `file_structure()` method, which will return a printable and queryable
    [`Directory`](#torch.package.Directory "torch.package.Directory") object. The
    [`Directory`](#torch.package.Directory "torch.package.Directory") object is a
    simple directory structure that you can use to explore the current contents of
    a `torch.package`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PackageImporter`](#torch.package.PackageImporter "torch.package.PackageImporter")
    提供了一个 `file_structure()` 方法，它将返回一个可打印和可查询的 [`Directory`](#torch.package.Directory
    "torch.package.Directory") 对象。[`Directory`](#torch.package.Directory "torch.package.Directory")
    对象是一个简单的目录结构，您可以用它来探索 `torch.package` 的当前内容。'
- en: The [`Directory`](#torch.package.Directory "torch.package.Directory") object
    itself is directly printable and will print out a file tree representation. To
    filter what is returned, use the glob-style `include` and `exclude` filtering
    arguments.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Directory`](#torch.package.Directory "torch.package.Directory") 对象本身是可以直接打印的，将打印出一个文件树表示。要过滤返回的内容，使用类似glob的
    `include` 和 `exclude` 过滤参数。'
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Output:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can also query [`Directory`](#torch.package.Directory "torch.package.Directory")
    objects with the `has_file()` method.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `has_file()` 方法查询 [`Directory`](#torch.package.Directory "torch.package.Directory")
    对象。
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[See why a given module was included as a dependency?](#id5)[](#see-why-a-given-module-was-included-as-a-dependency
    "Permalink to this heading")'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[查看为什么一个给定模块被包含为一个依赖项？](#id5)[](#see-why-a-given-module-was-included-as-a-dependency
    "Permalink to this heading")'
- en: Say there is a given module `foo`, and you want to know why your [`PackageExporter`](#torch.package.PackageExporter
    "torch.package.PackageExporter") is pulling in `foo` as a dependency.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个给定的模块 `foo`，您想知道为什么您的 [`PackageExporter`](#torch.package.PackageExporter
    "torch.package.PackageExporter") 将 `foo` 作为一个依赖项引入。
- en: '[`PackageExporter.get_rdeps()`](#torch.package.PackageExporter.get_rdeps "torch.package.PackageExporter.get_rdeps")
    will return all modules that directly depend on `foo`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PackageExporter.get_rdeps()`](#torch.package.PackageExporter.get_rdeps "torch.package.PackageExporter.get_rdeps")
    将返回所有直接依赖于 `foo` 的模块。'
- en: If you would like to see how a given module `src` depends on `foo`, the [`PackageExporter.all_paths()`](#torch.package.PackageExporter.all_paths
    "torch.package.PackageExporter.all_paths") method will return a DOT-formatted
    graph showing all the dependency paths between `src` and `foo`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看给定模块 `src` 如何依赖于 `foo`，[`PackageExporter.all_paths()`](#torch.package.PackageExporter.all_paths
    "torch.package.PackageExporter.all_paths") 方法将返回一个以DOT格式显示的图形，显示 `src` 和 `foo`
    之间的所有依赖路径。
- en: If you would just like to see the whole dependency graph of your [`PackageExporter`](#torch.package.PackageExporter
    "torch.package.PackageExporter"), you can use [`PackageExporter.dependency_graph_string()`](#torch.package.PackageExporter.dependency_graph_string
    "torch.package.PackageExporter.dependency_graph_string").
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想查看您的 [`PackageExporter`](#torch.package.PackageExporter "torch.package.PackageExporter")
    的整个依赖图，您可以使用 [`PackageExporter.dependency_graph_string()`](#torch.package.PackageExporter.dependency_graph_string
    "torch.package.PackageExporter.dependency_graph_string")。
- en: '[Include arbitrary resources with my package and access them later?](#id6)[](#include-arbitrary-resources-with-my-package-and-access-them-later
    "Permalink to this heading")'
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[如何在我的包中包含任意资源并以后访问它们？](#id6)[](#include-arbitrary-resources-with-my-package-and-access-them-later
    "Permalink to this heading")'
- en: '[`PackageExporter`](#torch.package.PackageExporter "torch.package.PackageExporter")
    exposes three methods, `save_pickle`, `save_text` and `save_binary` that allow
    you to save Python objects, text, and binary data to a package.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PackageExporter`](#torch.package.PackageExporter "torch.package.PackageExporter")
    提供了三种方法，`save_pickle`、`save_text` 和 `save_binary`，允许您将Python对象、文本和二进制数据保存到一个包中。'
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[`PackageImporter`](#torch.package.PackageImporter "torch.package.PackageImporter")
    exposes complementary methods named `load_pickle`, `load_text` and `load_binary`
    that allow you to load Python objects, text and binary data from a package.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PackageImporter`](#torch.package.PackageImporter "torch.package.PackageImporter")
    提供了名为 `load_pickle`、`load_text` 和 `load_binary` 的补充方法，允许您从一个包中加载Python对象、文本和二进制数据。'
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Customize how a class is packaged?](#id7)[](#customize-how-a-class-is-packaged
    "Permalink to this heading")'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[如何自定义类的打包方式？](#id7)[](#customize-how-a-class-is-packaged "Permalink to this
    heading")'
- en: '`torch.package` allows for the customization of how classes are packaged. This
    behavior is accessed through defining the method `__reduce_package__` on a class
    and by defining a corresponding de-packaging function. This is similar to defining
    `__reduce__` for Python’s normal pickling process.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`torch.package` 允许自定义类的打包方式。通过在一个类上定义方法 `__reduce_package__` 并定义相应的解包函数来访问这种行为。这类似于为Python的普通pickling过程定义
    `__reduce__`。'
- en: 'Steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤：
- en: 'Define the method `__reduce_package__(self, exporter: PackageExporter)` on
    the target class. This method should do the work to save the class instance inside
    of the package, and should return a tuple of the corresponding de-packaging function
    with the arguments needed to invoke the de-packaging function. This method is
    called by the `PackageExporter` when it encounters an instance of the target class.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在目标类上定义方法 `__reduce_package__(self, exporter: PackageExporter)`。这个方法应该完成将类实例保存在包中的工作，并应该返回一个元组，其中包含相应的解包函数以及调用解包函数所需的参数。当
    `PackageExporter` 遇到目标类的实例时，会调用这个方法。'
- en: Define a de-packaging function for the class. This de-packaging function should
    do the work to reconstruct and return an instance of the class. The function signature’s
    first parameter should be a `PackageImporter` instance, and the rest of the parameters
    are user defined.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个类定义一个解包函数。这个解包函数应该完成重建并返回类实例的工作。函数签名的第一个参数应该是一个 `PackageImporter` 实例，其余参数由用户定义。
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Test in my source code whether or not it is executing inside a package?](#id8)[](#test-in-my-source-code-whether-or-not-it-is-executing-inside-a-package
    "Permalink to this heading")'
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[在我的源代码中测试是否正在包内执行？](#id8)[](#test-in-my-source-code-whether-or-not-it-is-executing-inside-a-package
    "Permalink to this heading")'
- en: A [`PackageImporter`](#torch.package.PackageImporter "torch.package.PackageImporter")
    will add the attribute `__torch_package__` to every module that it initializes.
    Your code can check for the presence of this attribute to determine whether it
    is executing in a packaged context or not.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PackageImporter`](#torch.package.PackageImporter "torch.package.PackageImporter")将在初始化的每个模块上添加属性`__torch_package__`。您的代码可以检查此属性的存在来确定它是否在打包上下文中执行。'
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, the code will behave differently depending on whether it’s imported normally
    through your Python environment or imported from a `torch.package`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，代码的行为将取决于它是通过Python环境正常导入还是从`torch.package`导入。
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Warning**: in general, it’s bad practice to have code that behaves differently
    depending on whether it’s packaged or not. This can lead to hard-to-debug issues
    that are sensitive to how you imported your code. If your package is intended
    to be heavily used, consider restructuring your code so that it behaves the same
    way no matter how it was loaded.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：通常，根据代码是打包还是未打包而表现不同是不好的实践。这可能导致难以调试的问题，这些问题对您导入代码的方式很敏感。如果您的包打算被广泛使用，请考虑重新组织您的代码，使其无论如何加载都表现相同。'
- en: '[Patch code into a package?](#id9)[](#patch-code-into-a-package "Permalink
    to this heading")'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[将代码打补丁到包中？](#id9)[](#patch-code-into-a-package "跳转到此标题的永久链接")'
- en: '[`PackageExporter`](#torch.package.PackageExporter "torch.package.PackageExporter")
    offers a `save_source_string()` method that allows one to save arbitrary Python
    source code to a module of your choosing.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PackageExporter`](#torch.package.PackageExporter "torch.package.PackageExporter")提供了一个`save_source_string()`方法，允许将任意Python源代码保存到您选择的模块中。'
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[Access package contents from packaged code?](#id10)[](#access-package-contents-from-packaged-code
    "Permalink to this heading")'
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[从打包代码中访问包内容？](#id10)[](#access-package-contents-from-packaged-code "跳转到此标题的永久链接")'
- en: '[`PackageImporter`](#torch.package.PackageImporter "torch.package.PackageImporter")
    implements the [importlib.resources](https://docs.python.org/3/library/importlib.html#module-importlib.resources)
    API for accessing resources from inside a package.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PackageImporter`](#torch.package.PackageImporter "torch.package.PackageImporter")实现了[importlib.resources](https://docs.python.org/3/library/importlib.html#module-importlib.resources)
    API，用于从包内访问资源。'
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `importlib.resources` API allows access to resources from within packaged
    code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`importlib.resources` API允许从打包代码中访问资源。'
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using `importlib.resources` is the recommended way to access package contents
    from within packaged code, since it complies with the Python standard. However,
    it is also possible to access the parent [`PackageImporter`](#torch.package.PackageImporter
    "torch.package.PackageImporter") instance itself from within packaged code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`importlib.resources`是从打包代码中访问包内容的推荐方式，因为它符合Python标准。但是，也可以从打包代码中访问父[`PackageImporter`](#torch.package.PackageImporter
    "torch.package.PackageImporter")实例本身。
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Distinguish between packaged code and non-packaged code?](#id11)[](#distinguish-between-packaged-code-and-non-packaged-code
    "Permalink to this heading")'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[区分打包代码和非打包代码？](#id11)[](#distinguish-between-packaged-code-and-non-packaged-code
    "跳转到此标题的永久链接")'
- en: 'To tell if an object’s code is from a `torch.package`, use the `torch.package.is_from_package()`
    function. Note: if an object is from a package but its definition is from a module
    marked `extern` or from `stdlib`, this check will return `False`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定对象的代码是否来自`torch.package`，请使用`torch.package.is_from_package()`函数。注意：如果对象来自包但其定义来自标记为`extern`或`stdlib`的模块，此检查将返回`False`。
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Re-export an imported object?](#id12)[](#re-export-an-imported-object "Permalink
    to this heading")'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[重新导出已导入的对象？](#id12)[](#re-export-an-imported-object "跳转到此标题的永久链接")'
- en: To re-export an object that was previously imported by a [`PackageImporter`](#torch.package.PackageImporter
    "torch.package.PackageImporter"), you must make the new [`PackageExporter`](#torch.package.PackageExporter
    "torch.package.PackageExporter") aware of the original [`PackageImporter`](#torch.package.PackageImporter
    "torch.package.PackageImporter") so that it can find source code for your object’s
    dependencies.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重新导出之前由[`PackageImporter`](#torch.package.PackageImporter "torch.package.PackageImporter")导入的对象，您必须让新的[`PackageExporter`](#torch.package.PackageExporter
    "torch.package.PackageExporter")知道原始的[`PackageImporter`](#torch.package.PackageImporter
    "torch.package.PackageImporter")，以便它可以找到您对象的依赖项的源代码。
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Package a TorchScript module?](#id13)[](#package-a-torchscript-module "Permalink
    to this heading")'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[打包TorchScript模块？](#id13)[](#package-a-torchscript-module "跳转到此标题的永久链接")'
- en: To package a TorchScript model, use the same `save_pickle` and `load_pickle`
    APIs as you would with any other object. Saving TorchScript objects that are attributes
    or submodules is supported as well with no extra work.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要打包TorchScript模型，请使用与任何其他对象相同的`save_pickle`和`load_pickle` API。支持保存属性或子模块的TorchScript对象，无需额外工作。
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[Explanation](#id14)'
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[解释](#id14)'
- en: '[`torch.package` Format Overview](#id15)[](#torch-package-format-overview "Permalink
    to this heading")'
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`torch.package`格式概述](#id15)[](#torch-package-format-overview "跳转到此标题的永久链接")'
- en: 'A `torch.package` file is a ZIP archive which conventionally uses the `.pt`
    extension. Inside the ZIP archive, there are two kinds of files:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`torch.package`文件是一个ZIP存档，通常使用`.pt`扩展名。在ZIP存档中，有两种类型的文件：'
- en: Framework files, which are placed in the `.data/`.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架文件，放置在`.data/`中。
- en: User files, which is everything else.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户文件，即其他所有文件。
- en: 'As an example, this is what a fully packaged ResNet model from `torchvision`
    looks like:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个来自`torchvision`的完全打包的ResNet模型的样子：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Framework files
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 框架文件
- en: The `.data/` directory is owned by torch.package, and its contents are considered
    to be a private implementation detail. The `torch.package` format makes no guarantees
    about the contents of `.data/`, but any changes made will be backward compatible
    (that is, newer version of PyTorch will always be able to load older `torch.packages`).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`.data/`目录由torch.package拥有，其内容被视为私有实现细节。`torch.package`格式不对`.data/`的内容做任何保证，但任何更改都将向后兼容（即，新版本的PyTorch始终能够加载旧的`torch.packages`）。'
- en: 'Currently, the `.data/` directory contains the following items:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`.data/`目录包含以下项目：
- en: '`version`: a version number for the serialized format, so that the `torch.package`
    import infrastructures knows how to load this package.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`：序列化格式的版本号，以便`torch.package`导入基础设施知道如何加载此包。'
- en: '`extern_modules`: a list of modules that are considered `extern`. `extern`
    modules will be imported using the loading environment’s system importer.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extern_modules`：一个被视为`extern`的模块列表。`extern`模块将使用加载环境的系统导入器进行导入。'
- en: '`*.storage`: serialized tensor data.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*.storage`：序列化的张量数据。'
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: User files
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用户文件
- en: All other files in the archive were put there by a user. The layout is identical
    to a Python [regular package](https://docs.python.org/3/reference/import.html#regular-packages).
    For a deeper dive in how Python packaging works, please consult [this essay](https://www.python.org/doc/essays/packages/)
    (it’s slightly out of date, so double-check implementation details with the [Python
    reference documentation](https://docs.python.org/3/library/importlib.html)).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 存档中的所有其他文件都是用户放置的。布局与Python[常规包](https://docs.python.org/3/reference/import.html#regular-packages)相同。要深入了解Python打包的工作原理，请参考[这篇文章](https://www.python.org/doc/essays/packages/)（它略有过时，因此请通过[Python参考文档](https://docs.python.org/3/library/importlib.html)双重检查实现细节）。
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[How `torch.package` finds your code’s dependencies](#id16)[](#how-torch-package-finds-your-code-s-dependencies
    "Permalink to this heading")'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[如何`torch.package`找到您代码的依赖项](#id16)[](#how-torch-package-finds-your-code-s-dependencies
    "跳转到此标题")'
- en: Analyzing an object’s dependencies[](#analyzing-an-object-s-dependencies "Permalink
    to this heading")
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分析对象的依赖项[](#analyzing-an-object-s-dependencies "跳转到此标题")
- en: When you issue a `save_pickle(obj, ...)` call, [`PackageExporter`](#torch.package.PackageExporter
    "torch.package.PackageExporter") will pickle the object normally. Then, it uses
    the `pickletools` standard library module to parse the pickle bytecode.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当您发出`save_pickle(obj, ...)`调用时，[`PackageExporter`](#torch.package.PackageExporter
    "torch.package.PackageExporter")将正常对对象进行pickle。然后，它使用`pickletools`标准库模块来解析pickle字节码。
- en: 'In a pickle, an object is saved along with a `GLOBAL` opcode that describes
    where to find the implementation of the object’s type, like:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在pickle中，对象与描述对象类型实现位置的`GLOBAL`操作码一起保存，例如：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The dependency resolver will gather up all `GLOBAL` ops and mark them as dependencies
    of your pickled object. For more information about pickling and the pickle format,
    please consult [the Python docs](https://docs.python.org/3/library/pickle.html).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖解析器将收集所有`GLOBAL`操作，并将它们标记为您的pickled对象的依赖项。有关pickling和pickle格式的更多信息，请参考[Python文档](https://docs.python.org/3/library/pickle.html)。
- en: Analyzing a module’s dependencies[](#analyzing-a-module-s-dependencies "Permalink
    to this heading")
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分析模块的依赖项[](#analyzing-a-module-s-dependencies "跳转到此标题")
- en: 'When a Python module is identified as a dependency, `torch.package` walks the
    module’s python AST representation and looks for import statements with full support
    for the standard forms: `from x import y`, `import z`, `from w import v as u`,
    etc. When one of these import statements are encountered, `torch.package` registers
    the imported modules as dependencies that are then themselves parsed in the same
    AST walking way.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python模块被识别为依赖项时，`torch.package`会遍历模块的Python AST表示，并查找具有标准形式的导入语句的支持：`from
    x import y`，`import z`，`from w import v as u`等。当遇到这些导入语句之一时，`torch.package`会将导入的模块注册为依赖项，然后以相同的AST遍历方式解析它们自己。
- en: '**Note**: AST parsing has limited support for the `__import__(...)` syntax
    and does not support `importlib.import_module` calls. In general, you should not
    expect dynamic imports to be detected by `torch.package`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：AST解析对于`__import__(...)`语法有限支持，并且不支持`importlib.import_module`调用。一般来说，您不应该期望`torch.package`能够检测到动态导入。'
- en: '[Dependency Management](#id17)[](#dependency-management "Permalink to this
    heading")'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[依赖管理](#id17)[](#dependency-management "跳转到此标题")'
- en: '`torch.package` automatically finds the Python modules that your code and objects
    depend on. This process is called dependency resolution. For each module that
    the dependency resolver finds, you must specify an *action* to take.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`torch.package`会自动找到您的代码和对象依赖的Python模块。这个过程称为依赖解析。对于依赖解析器找到的每个模块，您必须指定要执行的*操作*。'
- en: 'The allowed actions are:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 允许的操作是：
- en: '`intern`: put this module into the package.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intern`：将此模块放入包中。'
- en: '`extern`: declare this module as an external dependency of the package.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extern`：将此模块声明为包的外部依赖项。'
- en: '`mock`: stub out this module.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mock`：模拟此模块。'
- en: '`deny`: depending on this module will raise an error during package export.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deny`：依赖于此模块将在包导出期间引发错误。'
- en: 'Finally, there is one more important action that is not technically part of
    `torch.package`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一个重要的操作不是技术上`torch.package`的一部分：
- en: 'Refactoring: remove or change the dependencies in your code.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构：删除或更改代码中的依赖项。
- en: Note that actions are only defined on entire Python modules. There is no way
    to package “just” a function or class from a module and leave the rest out. This
    is by design. Python does not offer clean boundaries between objects defined in
    a module. The only defined unit of dependency organization is a module, so that’s
    what `torch.package` uses.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，操作仅在整个Python模块上定义。无法仅打包模块中的“只是”函数或类并将其余部分留出。这是有意设计的。Python没有为模块中定义的对象提供清晰的边界。依赖组织的唯一定义单元是模块，因此`torch.package`使用它。
- en: Actions are applied to modules using patterns. Patterns can either be module
    names (`"foo.bar"`) or globs (like `"foo.**"`). You associate a pattern with an
    action using methods on [`PackageExporter`](#torch.package.PackageExporter "torch.package.PackageExporter"),
    e.g.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模式对模块应用操作。模式可以是模块名称（`"foo.bar"`）或通配符（如`"foo.**"`）。您可以使用[`PackageExporter`](#torch.package.PackageExporter
    "torch.package.PackageExporter")上的方法将模式与操作关联起来，例如：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If a module matches a pattern, the corresponding action is applied to it. For
    a given module, patterns will be checked in the order that they were defined,
    and the first action will be taken.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块与模式匹配，则将对其应用相应的操作。对于给定的模块，将按照定义的顺序检查模式，并采取第一个操作。
- en: '`intern`'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`intern`'
- en: If a module is `intern`-ed, it will be placed into the package.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个模块被`intern`，它将被放入包中。
- en: This action is your model code, or any related code you want to package. For
    example, if you are trying to package a ResNet from `torchvision`, you will need
    to `intern` the module torchvision.models.resnet.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作是您的模型代码，或者您想要打包的任何相关代码。例如，如果您正在尝试从`torchvision`打包一个ResNet，您将需要`intern`模块torchvision.models.resnet。
- en: On package import, when your packaged code tries to import an `intern`-ed module,
    PackageImporter will look inside your package for that module. If it can’t find
    that module, an error will be raised. This ensures that each [`PackageImporter`](#torch.package.PackageImporter
    "torch.package.PackageImporter") is isolated from the loading environment—even
    if you have `my_interned_module` available in both your package and the loading
    environment, [`PackageImporter`](#torch.package.PackageImporter "torch.package.PackageImporter")
    will only use the version in your package.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在包导入时，当您的打包代码尝试导入一个`intern`-ed模块时，PackageImporter将在您的包内查找该模块。如果找不到该模块，将引发错误。这确保了每个[`PackageImporter`](#torch.package.PackageImporter
    "torch.package.PackageImporter")与加载环境隔离——即使您的包和加载环境中都有`my_interned_module`，[`PackageImporter`](#torch.package.PackageImporter
    "torch.package.PackageImporter")也只会使用您包中的版本。
- en: '**Note**: Only Python source modules can be `intern`-ed. Other kinds of modules,
    like C extension modules and bytecode modules, will raise an error if you attempt
    to `intern` them. These kinds of modules need to be `mock`-ed or `extern`-ed.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：只有Python源模块可以被`intern`。其他类型的模块，如C扩展模块和字节码模块，如果您尝试`intern`它们，将引发错误。这些类型的模块需要被`mock`或`extern`。'
- en: '`extern`'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`extern`'
- en: If a module is `extern`-ed, it will not be packaged. Instead, it will be added
    to a list of external dependencies for this package. You can find this list on
    `package_exporter.extern_modules`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个模块被`extern`，它将不会被打包。相反，它将被添加到此包的外部依赖项列表中。您可以在`package_exporter.extern_modules`中找到此列表。
- en: On package import, when the packaged code tries to import an `extern`-ed module,
    [`PackageImporter`](#torch.package.PackageImporter "torch.package.PackageImporter")
    will use the default Python importer to find that module, as if you did `importlib.import_module("my_externed_module")`.
    If it can’t find that module, an error will be raised.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在包导入时，当打包的代码尝试导入一个`extern`-ed模块时，[`PackageImporter`](#torch.package.PackageImporter
    "torch.package.PackageImporter")将使用默认的Python导入器来查找该模块，就好像您执行了`importlib.import_module("my_externed_module")`。如果找不到该模块，将引发错误。
- en: In this way, you can depend on third-party libraries like `numpy` and `scipy`
    from within your package without having to package them too.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，您可以依赖于第三方库，如`numpy`和`scipy`，而无需将它们也打包。
- en: '**Warning**: If any external library changes in a backwards-incompatible way,
    your package may fail to load. If you need long-term reproducibility for your
    package, try to limit your use of `extern`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：如果任何外部库以不兼容的方式更改，您的包可能无法加载。如果您需要长期的包可重现性，请尽量限制对`extern`的使用。'
- en: '`mock`'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`mock`'
- en: If a module is `mock`-ed, it will not be packaged. Instead a stub module will
    be packaged in its place. The stub module will allow you to retrieve objects from
    it (so that `from my_mocked_module import foo` will not error), but any use of
    that object will raise a `NotImplementedError`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个模块被`mock`，它将不会被打包。相反，将会打包一个存根模块。存根模块将允许您从中检索对象（因此`from my_mocked_module
    import foo`不会出错），但对该对象的任何使用将引发`NotImplementedError`。
- en: '`mock` should be used for code that you “know” will not be needed in the loaded
    package, but you still want available for use in non-packaged contents. For example,
    initialization/configuration code, or code only used for debugging/training.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`mock`应该用于您“知道”在加载的包中不会需要的代码，但您仍希望在非打包内容中可用。例如，初始化/配置代码，或仅用于调试/训练的代码。'
- en: '**Warning**: In general, `mock` should be used as a last resort. It introduces
    behavioral differences between packaged code and non-packaged code, which may
    lead to later confusion. Prefer instead to refactor your code to remove unwanted
    dependencies.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：一般来说，`mock`应该作为最后的手段使用。它会引入打包代码和非打包代码之间的行为差异，可能会导致后续混淆。相反，最好重构您的代码以删除不需要的依赖项。'
- en: Refactoring
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重构
- en: 'The best way to manage dependencies is to not have dependencies at all! Often,
    code can be refactored to remove unnecessary dependencies. Here are some guidelines
    for writing code with clean dependencies (which are also generally good practices!):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 管理依赖项的最佳方法是根本不要有依赖项！通常，代码可以重构以删除不必要的依赖项。以下是编写具有干净依赖项的代码的一些指导原则（这些也通常是良好的实践！）：
- en: '**Include only what you use**. Do not leave unused imports in your code. The
    dependency resolver is not smart enough to tell that they are indeed unused, and
    will try to process them.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**只包含你使用的内容**。不要在你的代码中留下未使用的导入。依赖解析器不够智能，无法判断它们是否确实未使用，并将尝试处理它们。'
- en: '**Qualify your imports**. For example, instead of writing import foo and later
    using `foo.bar.baz`, prefer to write `from foo.bar import baz`. This more precisely
    specifies your real dependency (`foo.bar`) and lets the dependency resolver know
    you don’t need all of `foo`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**限定您的导入**。例如，不要写import foo然后在后面使用`foo.bar.baz`，最好写`from foo.bar import baz`。这更精确地指定了您的真实依赖项(`foo.bar`)，并让依赖解析器知道您不需要`foo`的全部内容。'
- en: '**Split up large files with unrelated functionality into smaller ones**. If
    your `utils` module contains a hodge-podge of unrelated functionality, any module
    that depends on `utils` will need to pull in lots of unrelated dependencies, even
    if you only needed a small part of it. Prefer instead to define single-purpose
    modules that can be packaged independently of one another.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**将具有无关功能的大文件拆分为较小的文件**。如果您的`utils`模块包含各种无关功能，任何依赖于`utils`的模块都将需要引入大量无关的依赖项，即使您只需要其中的一小部分。相反，最好定义单一用途的模块，可以独立打包。'
- en: Patterns
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模式
- en: Patterns allow you to specify groups of modules with a convenient syntax. The
    syntax and behavior of patterns follows the Bazel/Buck [glob()](https://docs.bazel.build/versions/master/be/functions.html#glob).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 模式允许您使用方便的语法指定模块组。模式的语法和行为遵循Bazel/Buck [glob()](https://docs.bazel.build/versions/master/be/functions.html#glob)。
- en: A module that we are trying to match against a pattern is called a candidate.
    A candidate is composed of a list of segments separated by a separator string,
    e.g. `foo.bar.baz`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在尝试匹配的模块称为候选模块。候选模块由一系列由分隔符字符串分隔的段组成，例如`foo.bar.baz`。
- en: 'A pattern contains one or more segments. Segments can be:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 模式包含一个或多个段。段可以是：
- en: A literal string (e.g. `foo`), which matches exactly.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文字字符串（例如`foo`），精确匹配。
- en: A string containing a wildcard (e.g. `torch`, or `foo*baz*`). The wildcard matches
    any string, including the empty string.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含通配符的字符串（例如`torch`或`foo*baz*`）。通配符匹配任何字符串，包括空字符串。
- en: A double wildcard (`**`). This matches against zero or more complete segments.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双通配符（`**`）。这与零个或多个完整段匹配。
- en: 'Examples:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '`torch.**`: matches `torch` and all its submodules, e.g. `torch.nn` and `torch.nn.functional`.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`torch.**`：匹配`torch`及其所有子模块，例如`torch.nn`和`torch.nn.functional`。'
- en: '`torch.*`: matches `torch.nn` or `torch.functional`, but not `torch.nn.functional`
    or `torch`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`torch.*`：匹配`torch.nn`或`torch.functional`，但不匹配`torch.nn.functional`或`torch`'
- en: '`torch*.**`: matches `torch`, `torchvision`, and all of their submodules'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`torch*.**`：匹配`torch`、`torchvision`和它们的所有子模块'
- en: When specifying actions, you can pass multiple patterns, e.g.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定操作时，可以传递多个模式，例如。
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A module will match against this action if it matches any of the patterns.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块与任何模式匹配，它将匹配此操作。
- en: You can also specify patterns to exclude, e.g.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以指定要排除的模式，例如。
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A module will not match against this action if it matches any of the exclude
    patterns. In this example, we are mocking all modules except `torchvision` and
    its submodules.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果匹配任何排除模式，模块将不匹配此操作。在此示例中，我们模拟所有模块，除了`torchvision`及其子模块。
- en: When a module could potentially match against multiple actions, the first action
    defined will be taken.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个模块可能匹配多个操作时，将采取首先定义的操作。
- en: '[`torch.package` sharp edges](#id18)[](#torch-package-sharp-edges "Permalink
    to this heading")'
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`torch.package`尖锐边缘](#id18)[](#torch-package-sharp-edges "跳转到此标题")'
- en: Avoid global state in your modules[](#avoid-global-state-in-your-modules "Permalink
    to this heading")
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 避免在您的模块中使用全局状态[](#avoid-global-state-in-your-modules "跳转到此标题")
- en: Python makes it really easy to bind objects and run code at module-level scope.
    This is generally fine—after all, functions and classes are bound to names this
    way. However, things become more complicated when you define an object at module
    scope with the intention of mutating it, introducing mutable global state.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Python使绑定对象和在模块级别范围运行代码变得非常容易。这通常没问题——毕竟，函数和类是以这种方式绑定到名称的。但是，当您在模块范围定义一个对象以进行突变时，引入可变全局状态时，情况会变得更加复杂。
- en: Mutable global state is quite useful—it can reduce boilerplate, allow for open
    registration into tables, etc. But unless employed very carefully, it can cause
    complications when used with `torch.package`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 可变全局状态非常有用——它可以减少样板文件，允许向表中开放注册等。但是，除非非常小心地使用，否则在与`torch.package`一起使用时可能会引起复杂性。
- en: Every [`PackageImporter`](#torch.package.PackageImporter "torch.package.PackageImporter")
    creates an independent environment for its contents. This is nice because it means
    we load multiple packages and ensure they are isolated from each other, but when
    modules are written in a way that assumes shared mutable global state, this behavior
    can create hard-to-debug errors.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 每个[`PackageImporter`](#torch.package.PackageImporter "torch.package.PackageImporter")为其内容创建一个独立的环境。这很好，因为这意味着我们加载多个包并确保它们彼此隔离，但是当模块以假定共享可变全局状态的方式编写时，此行为可能会导致难以调试的错误。
- en: Types are not shared between packages and the loading environment[](#types-are-not-shared-between-packages-and-the-loading-environment
    "Permalink to this heading")
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类型不在包之间共享，并且加载环境[](#types-are-not-shared-between-packages-and-the-loading-environment
    "跳转到此标题")
- en: 'Any class that you import from a [`PackageImporter`](#torch.package.PackageImporter
    "torch.package.PackageImporter") will be a version of the class specific to that
    importer. For example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从[`PackageImporter`](#torch.package.PackageImporter "torch.package.PackageImporter")导入的任何类都将是特定于该导入器的类的版本。例如：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, `MyClass` and `imported_MyClass` are *not the same type*. In
    this specific example, `MyClass` and `imported_MyClass` have exactly the same
    implementation, so you might think it’s okay to consider them the same class.
    But consider the situation where `imported_MyClass` is coming from an older package
    with an entirely different implementation of `MyClass` — in that case, it’s unsafe
    to consider them the same class.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`MyClass`和`imported_MyClass`不是*相同类型*。在这个特定示例中，`MyClass`和`imported_MyClass`具有完全相同的实现，因此您可能认为可以将它们视为相同的类。但是请考虑`imported_MyClass`来自具有完全不同`MyClass`实现的旧包的情况——在这种情况下，将它们视为相同类是不安全的。
- en: 'Under the hood, each importer has a prefix that allows it to uniquely identify
    classes:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，每个导入器都有一个前缀，允许它唯一识别类：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That means you should not expect `isinstance` checks to work when one of the
    arguments is from a package and the other is not. If you need this functionality,
    consider the following options:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当一个参数来自一个包而另一个参数不是时，您不应该期望`isinstance`检查能够工作。如果需要此功能，请考虑以下选项：
- en: Doing duck typing (just using the class instead of explicitly checking that
    it is of a given type).
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行鸭子类型（只使用类而不是明确检查它是给定类型）。
- en: Make the typing relationship an explicit part of the class contract. For example,
    you can add an attribute tag `self.handler = "handle_me_this_way"` and have client
    code check for the value of `handler` instead of checking the type directly.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使类型关系成为类合同的显式部分。例如，您可以添加一个属性标签`self.handler = "handle_me_this_way"`，并让客户端代码检查`handler`的值而不是直接检查类型。
- en: '[How `torch.package` keeps packages isolated from each other](#id19)[](#how-torch-package-keeps-packages-isolated-from-each-other
    "Permalink to this heading")'
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[如何使`torch.package`中的包相互隔离](#id19)[](#how-torch-package-keeps-packages-isolated-from-each-other
    "跳转到此标题的永久链接")'
- en: Each [`PackageImporter`](#torch.package.PackageImporter "torch.package.PackageImporter")
    instance creates an independent, isolated environment for its modules and objects.
    Modules in a package can only import other packaged modules, or modules marked
    `extern`. If you use multiple [`PackageImporter`](#torch.package.PackageImporter
    "torch.package.PackageImporter") instances to load a single package, you will
    get multiple independent environments that do not interact.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 每个[`PackageImporter`](#torch.package.PackageImporter "torch.package.PackageImporter")实例为其模块和对象创建一个独立的、隔离的环境。包中的模块只能导入其他打包的模块，或标记为`extern`的模块。如果您使用多个[`PackageImporter`](#torch.package.PackageImporter
    "torch.package.PackageImporter")实例来加载单个包，您将获得多个独立的环境，它们不会相互交互。
- en: This is achieved by extending Python’s import infrastructure with a custom importer.
    [`PackageImporter`](#torch.package.PackageImporter "torch.package.PackageImporter")
    provides the same core API as the `importlib` importer; namely, it implements
    the `import_module` and `__import__` methods.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用自定义导入器扩展 Python 的导入基础设施来实现的。[`PackageImporter`](#torch.package.PackageImporter
    "torch.package.PackageImporter")提供与`importlib`导入器相同的核心 API；即，它实现了`import_module`和`__import__`方法。
- en: When you invoke [`PackageImporter.import_module()`](#torch.package.PackageImporter.import_module
    "torch.package.PackageImporter.import_module"), [`PackageImporter`](#torch.package.PackageImporter
    "torch.package.PackageImporter") will construct and return a new module, much
    as the system importer does. However, [`PackageImporter`](#torch.package.PackageImporter
    "torch.package.PackageImporter") patches the returned module to use `self` (i.e.
    that [`PackageImporter`](#torch.package.PackageImporter "torch.package.PackageImporter")
    instance) to fulfill future import requests by looking in the package rather than
    searching the user’s Python environment.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用[`PackageImporter.import_module()`](#torch.package.PackageImporter.import_module
    "torch.package.PackageImporter.import_module")时，[`PackageImporter`](#torch.package.PackageImporter
    "torch.package.PackageImporter")将构建并返回一个新模块，就像系统导入器一样。但是，[`PackageImporter`](#torch.package.PackageImporter
    "torch.package.PackageImporter")会修补返回的模块，以使用`self`（即[`PackageImporter`](#torch.package.PackageImporter
    "torch.package.PackageImporter")实例）来满足未来的导入请求，通过在包中查找而不是搜索用户的Python环境。
- en: Mangling
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 混淆
- en: To avoid confusion (“is this `foo.bar` object the one from my package, or the
    one from my Python environment?”), [`PackageImporter`](#torch.package.PackageImporter
    "torch.package.PackageImporter") mangles the `__name__` and `__file__` of all
    imported modules, by adding a *mangle prefix* to them.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免混淆（“这个`foo.bar`对象是来自我的包还是来自我的Python环境？”），[`PackageImporter`](#torch.package.PackageImporter
    "torch.package.PackageImporter")通过为导入的所有模块添加*混淆前缀*来篡改它们的`__name__`和`__file__`。
- en: For `__name__`, a name like `torchvision.models.resnet18` becomes `<torch_package_0>.torchvision.models.resnet18`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`__name__`，类似`torchvision.models.resnet18`的名称变为`<torch_package_0>.torchvision.models.resnet18`。
- en: For `__file__`, a name like `torchvision/models/resnet18.py` becomes `<torch_package_0>.torchvision/modules/resnet18.py`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`__file__`，类似`torchvision/models/resnet18.py`的名称变为`<torch_package_0>.torchvision/modules/resnet18.py`。
- en: Name mangling helps avoid inadvertent punning of module names between different
    packages, and helps you debug by making stack traces and print statements more
    clearly show whether they are referring to packaged code or not. For developer-facing
    details about mangling, consult `mangling.md` in `torch/package/`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 名称混淆有助于避免不同包之间模块名称的无意间双关，并通过使堆栈跟踪和打印语句更清晰地显示它们是指向打包代码还是其他内容来帮助您调试。有关混淆的面向开发人员的详细信息，请参阅`torch/package/`中的`mangling.md`。
- en: '[API Reference](#id20)'
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[API 参考](#id20)'
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This exception is raised when there is an issue with exporting a package. `PackageExporter`
    will attempt to gather up all the errors and present them to you at once.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在导出包时出现问题时会引发此异常。`PackageExporter`将尝试收集所有错误并一次性呈现给您。
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is an exception that is thrown when a mock or extern is marked as `allow_empty=False`,
    and is not matched with any module during packaging.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当在打包过程中遇到将 mock 或 extern 标记为`allow_empty=False`，并且在打包期间未匹配到任何模块时，将引发此异常。
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Exporters allow you to write packages of code, pickled Python data, and arbitrary
    binary and text resources into a self-contained package.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 导出器允许您将代码包、Python 数据、以及任意二进制和文本资源写入一个独立的包中。
- en: Imports can load this code in a hermetic way, such that code is loaded from
    the package rather than the normal Python import system. This allows for the packaging
    of PyTorch model code and data so that it can be run on a server or used in the
    future for transfer learning.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 导入可以以封闭的方式加载代码，使代码从包中加载而不是从正常的Python导入系统加载。这允许打包 PyTorch 模型代码和数据，以便在服务器上运行或将来用于迁移学习。
- en: The code contained in packages is copied file-by-file from the original source
    when it is created, and the file format is a specially organized zip file. Future
    users of the package can unzip the package, and edit the code in order to perform
    custom modifications to it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建包时，包中包含的代码是从原始源文件逐个文件复制的，文件格式是一个特别组织的压缩文件。包的未来用户可以解压包，并编辑代码以执行自定义修改。
- en: The importer for packages ensures that code in the module can only be loaded
    from within the package, except for modules explicitly listed as external using
    [`extern()`](#torch.package.PackageExporter.extern "torch.package.PackageExporter.extern").
    The file `extern_modules` in the zip archive lists all the modules that a package
    externally depends on. This prevents “implicit” dependencies where the package
    runs locally because it is importing a locally-installed package, but then fails
    when the package is copied to another machine.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 包导入器确保模块中的代码只能从包内部加载，除非明确列出为外部模块使用[`extern()`](#torch.package.PackageExporter.extern
    "torch.package.PackageExporter.extern")。压缩文件中的`extern_modules`列出了包在外部依赖的所有模块。这可以防止“隐式”依赖，即因为导入了本地安装的包而在本地运行，但在将包复制到另一台机器时失败。
- en: 'When source code is added to the package, the exporter can optionally scan
    it for further code dependencies (`dependencies=True`). It looks for import statements,
    resolves relative references to qualified module names, and performs an action
    specified by the user (See: [`extern()`](#torch.package.PackageExporter.extern
    "torch.package.PackageExporter.extern"), [`mock()`](#torch.package.PackageExporter.mock
    "torch.package.PackageExporter.mock"), and [`intern()`](#torch.package.PackageExporter.intern
    "torch.package.PackageExporter.intern")).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当源代码添加到包中时，导出器可以选择扫描它以获取更多的代码依赖项（`dependencies=True`）。它查找导入语句，解析相对引用以获取限定模块名称，并执行用户指定的操作（参见：[`extern()`](#torch.package.PackageExporter.extern
    "torch.package.PackageExporter.extern")，[`mock()`](#torch.package.PackageExporter.mock
    "torch.package.PackageExporter.mock")和[`intern()`](#torch.package.PackageExporter.intern
    "torch.package.PackageExporter.intern")).
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Create an exporter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个导出器。
- en: Parameters
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**f** ([*Union*](https://docs.python.org/3/library/typing.html#typing.Union
    "(in Python v3.12)")*[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*,* [*Path*](https://docs.python.org/3/library/pathlib.html#pathlib.Path
    "(in Python v3.12)")*,* [*BinaryIO*](https://docs.python.org/3/library/typing.html#typing.BinaryIO
    "(in Python v3.12)")*]*) – The location to export to. Can be a `string`/`Path`
    object containing a filename or a binary I/O object.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**f** ([*Union*](https://docs.python.org/3/library/typing.html#typing.Union
    "(in Python v3.12)")*[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*,* [*Path*](https://docs.python.org/3/library/pathlib.html#pathlib.Path
    "(in Python v3.12)")*,* [*BinaryIO*](https://docs.python.org/3/library/typing.html#typing.BinaryIO
    "(in Python v3.12)")*]*) – 导出位置。可以是包含文件名的`string`/`Path`对象，也可以是二进制I/O对象。'
- en: '**importer** ([*Union*](https://docs.python.org/3/library/typing.html#typing.Union
    "(in Python v3.12)")*[**Importer**,* [*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence
    "(in Python v3.12)")*[**Importer**]**]*) – If a single Importer is passed, use
    that to search for modules. If a sequence of importers are passed, an `OrderedImporter`
    will be constructed out of them.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**importer** ([*Union*](https://docs.python.org/3/library/typing.html#typing.Union
    "(in Python v3.12)")*[**Importer**,* [*Sequence*](https://docs.python.org/3/library/typing.html#typing.Sequence
    "(in Python v3.12)")*[**Importer**]**]*) – 如果传递了单个Importer，则使用该Importer搜索模块。如果传递了一系列importers，将从中构建一个`OrderedImporter`。'
- en: '**debug** ([*bool*](https://docs.python.org/3/library/functions.html#bool "(in
    Python v3.12)")) – If set to True, add path of broken modules to PackagingErrors.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**debug** ([*bool*](https://docs.python.org/3/library/functions.html#bool "(in
    Python v3.12)")) – 如果设置为True，则将损坏模块的路径添加到PackagingErrors中。'
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Given a module, add it to the dependency graph according to patterns specified
    by the user.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个模块，根据用户指定的模式将其添加到依赖图中。
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Return a dot representation of the subgraph
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 返回子图的点表示
- en: that has all paths from src to dst.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从src到dst的所有路径。
- en: Returns
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: A dot representation containing all paths from src to dst. ([https://graphviz.org/doc/info/lang.html](https://graphviz.org/doc/info/lang.html))
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 包含从src到dst的所有路径的点表示。([https://graphviz.org/doc/info/lang.html](https://graphviz.org/doc/info/lang.html))
- en: Return type
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")'
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Write the package to the filesystem. Any calls after [`close()`](#torch.package.PackageExporter.close
    "torch.package.PackageExporter.close") are now invalid. It is preferable to use
    resource guard syntax instead:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 将包写入文件系统。[`close()`](#torch.package.PackageExporter.close "torch.package.PackageExporter.close")之后的任何调用现在都是无效的。最好使用资源保护语法：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Return all modules that are currently denied.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 返回当前被拒绝的所有模块。
- en: Returns
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: A list containing the names of modules which will be denied in this package.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 包含将在此包中被拒绝的模块名称的列表。
- en: Return type
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python
    v3.12)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python
    v3.12)")]'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python
    v3.12)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python
    v3.12)")]'
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Blocklist modules who names match the given glob patterns from the list of modules
    the package can import. If a dependency on any matching packages is found, a [`PackagingError`](#torch.package.PackagingError
    "torch.package.PackagingError") is raised.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 从包可以导入的模块列表中阻止与给定glob模式匹配的模块名称。如果找到任何匹配的包的依赖项，将引发[`PackagingError`](#torch.package.PackagingError
    "torch.package.PackagingError")。
- en: Parameters
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**include** (*Union**[**List**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]**,* [*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]*) – A string e.g. `"my_package.my_subpackage"`, or list
    of strings for the names of the modules to be externed. This can also be a glob-style
    pattern, as described in [`mock()`](#torch.package.PackageExporter.mock "torch.package.PackageExporter.mock").'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**include** (*Union**[**List**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]**,* [*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]*) – 一个字符串，例如 `"my_package.my_subpackage"`，或者字符串列表，用于指定要外部化的模块的名称。这也可以是一个类似于glob的模式，如[`mock()`](#torch.package.PackageExporter.mock
    "torch.package.PackageExporter.mock")中所述。'
- en: '**exclude** (*Union**[**List**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]**,* [*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]*) – An optional pattern that excludes some patterns that
    match the include string.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**exclude** (*Union**[**List**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]**,* [*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]*) – 一个可选模式，用于排除与包含字符串匹配的某些模式。'
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Returns digraph string representation of dependencies in package.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 返回包中依赖项的双字母字符串表示。
- en: Returns
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: A string representation of dependencies in package.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 包中依赖项的字符串表示。
- en: Return type
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")'
- en: '[PRE40]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Include `module` in the list of external modules the package can import. This
    will prevent dependency discovery from saving it in the package. The importer
    will load an external module directly from the standard import system. Code for
    extern modules must also exist in the process loading the package.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 将`module`包含在包可以导入的外部模块列表中。这将阻止依赖项发现将其保存在包中。导入程序将直接从标准导入系统加载外部模块。外部模块的代码也必须存在于加载包的进程中。
- en: Parameters
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**include** (*Union**[**List**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]**,* [*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]*) – A string e.g. `"my_package.my_subpackage"`, or list
    of strings for the names of the modules to be externed. This can also be a glob-style
    pattern, as described in [`mock()`](#torch.package.PackageExporter.mock "torch.package.PackageExporter.mock").'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包括**（*Union**[**List**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(在Python v3.12中)")*]**,* [*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(在Python v3.12中)")*]）- 一个字符串，例如`"my_package.my_subpackage"`，或者是要导出的模块的名称列表。这也可以是一个类似glob的模式，如[`mock()`](#torch.package.PackageExporter.mock
    "torch.package.PackageExporter.mock")中所述。'
- en: '**exclude** (*Union**[**List**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]**,* [*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]*) – An optional pattern that excludes some patterns that
    match the include string.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排除**（*Union**[**List**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(在Python v3.12中)")*]**,* [*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(在Python v3.12中)")*]）- 一个可选模式，排除一些与包含字符串匹配的模式。'
- en: '**allow_empty** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")) – An optional flag that specifies whether the extern modules
    specified by this call to the `extern` method must be matched to some module during
    packaging. If an extern module glob pattern is added with `allow_empty=False`,
    and [`close()`](#torch.package.PackageExporter.close "torch.package.PackageExporter.close")
    is called (either explicitly or via `__exit__`) before any modules match that
    pattern, an exception is thrown. If `allow_empty=True`, no such exception is thrown.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**allow_empty**（[*bool*](https://docs.python.org/3/library/functions.html#bool
    "(在Python v3.12中)")）- 一个可选标志，指定此调用`extern`方法指定的外部模块是否必须在打包过程中与某个模块匹配。如果添加了一个`allow_empty=False`的外部模块glob模式，并且在任何模块匹配该模式之前调用了[`close()`](#torch.package.PackageExporter.close
    "torch.package.PackageExporter.close")（显式调用或通过`__exit__`），则会抛出异常。如果`allow_empty=True`，则不会抛出此类异常。'
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Return all modules that are currently externed.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 返回当前所有已经externed的模块。
- en: Returns
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: A list containing the names of modules which will be externed in this package.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在此包中将被externed的模块的名称列表。
- en: Return type
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python
    v3.12)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python
    v3.12)")]'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[*List*](https://docs.python.org/3/library/typing.html#typing.List "(在Python
    v3.12中)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(在Python
    v3.12中)")]'
- en: '[PRE42]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Return a list of all modules which depend on the module `module_name`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个依赖于模块`module_name`的所有模块的列表。
- en: Returns
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: A list containing the names of modules which depend on `module_name`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 包含依赖于`module_name`的模块的名称列表。
- en: Return type
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python
    v3.12)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python
    v3.12)")]'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[*List*](https://docs.python.org/3/library/typing.html#typing.List "(在Python
    v3.12中)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(在Python
    v3.12中)")]'
- en: '[PRE43]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Get an id. This id is guaranteed to only be handed out once for this package.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 获取一个id。此id保证仅在此包中分配一次。
- en: Return type
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[str](https://docs.python.org/3/library/stdtypes.html#str "(在Python v3.12中)")'
- en: '[PRE44]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Specify modules that should be packaged. A module must match some `intern` pattern
    in order to be included in the package and have its dependencies processed recursively.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 指定应该打包的模块。模块必须匹配一些`intern`模式才能包含在包中，并且其依赖项会被递归处理。
- en: Parameters
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**include** (*Union**[**List**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]**,* [*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]*) – A string e.g. “my_package.my_subpackage”, or list of
    strings for the names of the modules to be externed. This can also be a glob-style
    pattern, as described in [`mock()`](#torch.package.PackageExporter.mock "torch.package.PackageExporter.mock").'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包括**（*Union**[**List**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(在Python v3.12中)")*]**,* [*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(在Python v3.12中)")*]）- 一个字符串，例如“my_package.my_subpackage”，或者是要导出的模块的名称列表。这也可以是一个类似glob的模式，如[`mock()`](#torch.package.PackageExporter.mock
    "torch.package.PackageExporter.mock")中所述。'
- en: '**exclude** (*Union**[**List**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]**,* [*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]*) – An optional pattern that excludes some patterns that
    match the include string.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排除**（*Union**[**List**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(在Python v3.12中)")*]**,* [*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(在Python v3.12中)")*]）- 一个可选模式，排除一些与包含字符串匹配的模式。'
- en: '**allow_empty** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")) – An optional flag that specifies whether the intern modules
    specified by this call to the `intern` method must be matched to some module during
    packaging. If an `intern` module glob pattern is added with `allow_empty=False`,
    and [`close()`](#torch.package.PackageExporter.close "torch.package.PackageExporter.close")
    is called (either explicitly or via `__exit__`) before any modules match that
    pattern, an exception is thrown. If `allow_empty=True`, no such exception is thrown.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**allow_empty**（[*bool*](https://docs.python.org/3/library/functions.html#bool
    "(在Python v3.12中)")）- 一个可选标志，指定此调用`intern`方法指定的intern模块是否必须在打包过程中与某个模块匹配。如果添加了一个`allow_empty=False`的`intern`模块glob模式，并且在任何模块匹配该模式之前调用了[`close()`](#torch.package.PackageExporter.close
    "torch.package.PackageExporter.close")（显式调用或通过`__exit__`），则会抛出异常。如果`allow_empty=True`，则不会抛出此类异常。'
- en: '[PRE45]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Return all modules that are currently interned.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 返回当前所有已经interned的模块。
- en: Returns
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: A list containing the names of modules which will be interned in this package.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 包含将在此软件包中intern的模块名称的列表。
- en: Return type
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python
    v3.12)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python
    v3.12)")]'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python
    v3.12)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python
    v3.12)")]'
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Replace some required modules with a mock implementation. Mocked modules will
    return a fake object for any attribute accessed from it. Because we copy file-by-file,
    the dependency resolution will sometimes find files that are imported by model
    files but whose functionality is never used (e.g. custom serialization code or
    training helpers). Use this function to mock this functionality out without having
    to modify the original code.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 用模拟实现替换一些必需的模块。模拟的模块将为从中访问的任何属性返回一个虚假对象。因为我们是逐个文件复制的，所以依赖关系解析有时会找到由模型文件导入但其功能从未被使用的文件（例如自定义序列化代码或训练助手）。使用此函数可以模拟此功能，而无需修改原始代码。
- en: Parameters
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**include** (*Union**[**List**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]**,* [*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]*) –'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**include**（*Union**[**List**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]**,* [*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]*) -'
- en: A string e.g. `"my_package.my_subpackage"`, or list of strings for the names
    of the modules to be mocked out. Strings can also be a glob-style pattern string
    that may match multiple modules. Any required dependencies that match this pattern
    string will be mocked out automatically.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个字符串，例如`"my_package.my_subpackage"`，或模块名称的字符串列表。字符串也可以是匹配多个模块的glob样式模式字符串。与此模式字符串匹配的任何必需依赖项将自动被模拟。
- en: 'Examples :'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例：
- en: '`''torch.**''` – matches `torch` and all submodules of torch, e.g. `''torch.nn''`
    and `''torch.nn.functional''`'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`''torch.**''` - 匹配`torch`和torch的所有子模块，例如`''torch.nn''`和`''torch.nn.functional''`'
- en: '`''torch.*''` – matches `''torch.nn''` or `''torch.functional''`, but not `''torch.nn.functional''`'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`''torch.*''` - 匹配`''torch.nn''`或`''torch.functional''`，但不匹配`''torch.nn.functional''`'
- en: '**exclude** (*Union**[**List**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]**,* [*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]*) – An optional pattern that excludes some patterns that
    match the include string. e.g. `include=''torch.**'', exclude=''torch.foo''` will
    mock all torch packages except `''torch.foo''`, Default: is `[]`.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**exclude**（*Union**[**List**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]**,* [*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]*) - 一个可选模式，用于排除与包含字符串匹配的某些模式。例如 `include=''torch.**'',
    exclude=''torch.foo''` 将模拟所有torch包，除了`''torch.foo''`，默认值为`[]`。'
- en: '**allow_empty** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")) – An optional flag that specifies whether the mock implementation(s)
    specified by this call to the [`mock()`](#torch.package.PackageExporter.mock "torch.package.PackageExporter.mock")
    method must be matched to some module during packaging. If a mock is added with
    `allow_empty=False`, and [`close()`](#torch.package.PackageExporter.close "torch.package.PackageExporter.close")
    is called (either explicitly or via `__exit__`) and the mock has not been matched
    to a module used by the package being exported, an exception is thrown. If `allow_empty=True`,
    no such exception is thrown.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**allow_empty**（*bool*）- 一个可选标志，指定此调用[`mock()`](#torch.package.PackageExporter.mock
    "torch.package.PackageExporter.mock")方法指定的模拟实现是否在打包期间必须与某个模块匹配。如果使用`allow_empty=False`添加了一个模拟，并且调用了[`close()`](#torch.package.PackageExporter.close
    "torch.package.PackageExporter.close")（显式调用或通过`__exit__`），并且该模拟未与要导出的包使用的模块匹配，则会抛出异常。如果`allow_empty=True`，则不会抛出此类异常。'
- en: '[PRE47]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Return all modules that are currently mocked.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 返回当前模拟的所有模块。
- en: Returns
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: A list containing the names of modules which will be mocked in this package.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 包含将在此软件包中模拟的模块名称的列表。
- en: Return type
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python
    v3.12)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python
    v3.12)")]'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python
    v3.12)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python
    v3.12)")]'
- en: '[PRE48]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Registers an extern hook on the exporter.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在导出器上注册一个extern钩子。
- en: 'The hook will be called each time a module matches against an [`extern()`](#torch.package.PackageExporter.extern
    "torch.package.PackageExporter.extern") pattern. It should have the following
    signature:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 每次模块与[`extern()`](#torch.package.PackageExporter.extern "torch.package.PackageExporter.extern")模式匹配时都会调用钩子。它应该具有以下签名：
- en: '[PRE49]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Hooks will be called in order of registration.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子将按注册顺序调用。
- en: Returns
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: A handle that can be used to remove the added hook by calling `handle.remove()`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`handle.remove()`可以删除添加的钩子的句柄。
- en: Return type
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '`torch.utils.hooks.RemovableHandle`'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`torch.utils.hooks.RemovableHandle`'
- en: '[PRE50]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Registers an intern hook on the exporter.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在导出器上注册一个intern钩子。
- en: 'The hook will be called each time a module matches against an [`intern()`](#torch.package.PackageExporter.intern
    "torch.package.PackageExporter.intern") pattern. It should have the following
    signature:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 每次模块与[`intern()`](#torch.package.PackageExporter.intern "torch.package.PackageExporter.intern")模式匹配时都会调用钩子。它应该具有以下签名：
- en: '[PRE51]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Hooks will be called in order of registration.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子将按注册顺序调用。
- en: Returns
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: A handle that can be used to remove the added hook by calling `handle.remove()`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`handle.remove()`可以删除添加的钩子的句柄。
- en: Return type
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '`torch.utils.hooks.RemovableHandle`'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`torch.utils.hooks.RemovableHandle`'
- en: '[PRE52]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Registers a mock hook on the exporter.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在导出器上注册一个模拟钩子。
- en: 'The hook will be called each time a module matches against a [`mock()`](#torch.package.PackageExporter.mock
    "torch.package.PackageExporter.mock") pattern. It should have the following signature:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 每次模块与[`mock()`](#torch.package.PackageExporter.mock "torch.package.PackageExporter.mock")模式匹配时都会调用钩子。它应该具有以下签名：
- en: '[PRE53]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Hooks will be called in order of registration.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子将按注册顺序调用。
- en: Returns
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: A handle that can be used to remove the added hook by calling `handle.remove()`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用`handle.remove()`来删除添加的钩子的句柄。
- en: Return type
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '`torch.utils.hooks.RemovableHandle`'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`torch.utils.hooks.RemovableHandle`'
- en: '[PRE54]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Save raw bytes to the package.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 将原始字节保存到包中。
- en: Parameters
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**package** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – The name of module package this resource should go it (e.g.
    `"my_package.my_subpackage"`).'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**package**（[*str*](https://docs.python.org/3/library/stdtypes.html#str "(在Python
    v3.12中)")） - 此资源应该放在的模块包的名称（例如`"my_package.my_subpackage"`）。'
- en: '**resource** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – A unique name for the resource, used to identify it to load.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源**（[*str*](https://docs.python.org/3/library/stdtypes.html#str "(在Python
    v3.12中)")） - 用于标识要加载的资源的唯一名称。'
- en: '**binary** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – The data to save.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制**（[*str*](https://docs.python.org/3/library/stdtypes.html#str "(在Python
    v3.12中)")） - 要保存的数据。'
- en: '[PRE55]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Save the code for `module` into the package. Code for the module is resolved
    using the `importers` path to find the module object, and then using its `__file__`
    attribute to find the source code.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 将`module`的代码保存到包中。使用`importers`路径解析模块对象的代码，然后使用其`__file__`属性查找源代码。
- en: Parameters
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**module_name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")) – e.g. `my_package.my_subpackage`, code will be saved to
    provide code for this package.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**module_name**（[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(在Python v3.12中)")） - 例如`my_package.my_subpackage`，将保存代码以提供此包的代码。'
- en: '**dependencies** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – If `True`, we scan the source for dependencies.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖项**（[*bool*](https://docs.python.org/3/library/functions.html#bool "(在Python
    v3.12中)")，可选） - 如果为`True`，我们会扫描源代码以查找依赖项。'
- en: '[PRE56]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Save a python object to the archive using pickle. Equivalent to [`torch.save()`](generated/torch.save.html#torch.save
    "torch.save") but saving into the archive rather than a stand-alone file. Standard
    pickle does not save the code, only the objects. If `dependencies` is true, this
    method will also scan the pickled objects for which modules are required to reconstruct
    them and save the relevant code.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pickle将Python对象保存到存档中。相当于[`torch.save()`](generated/torch.save.html#torch.save
    "torch.save")，但保存到存档而不是独立文件。标准pickle不保存代码，只保存对象。如果`dependencies`为true，则此方法还将扫描pickled对象以确定重建它们所需的模块，并保存相关代码。
- en: To be able to save an object where `type(obj).__name__` is `my_module.MyObject`,
    `my_module.MyObject` must resolve to the class of the object according to the
    `importer` order. When saving objects that have previously been packaged, the
    importer’s `import_module` method will need to be present in the `importer` list
    for this to work.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够保存一个对象，其中`type(obj).__name__`是`my_module.MyObject`，`my_module.MyObject`必须根据`importer`顺序解析为对象的类。当保存先前已打包的对象时，导入程序的`import_module`方法将需要存在于`importer`列表中才能正常工作。
- en: Parameters
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**package** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – The name of module package this resource should go in (e.g.
    `"my_package.my_subpackage"`).'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**package**（[*str*](https://docs.python.org/3/library/stdtypes.html#str "(在Python
    v3.12中)")） - 此资源应该放在的模块包的名称（例如`"my_package.my_subpackage"`）。'
- en: '**resource** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – A unique name for the resource, used to identify it to load.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源**（[*str*](https://docs.python.org/3/library/stdtypes.html#str "(在Python
    v3.12中)")） - 用于标识要加载的资源的唯一名称。'
- en: '**obj** (*Any*) – The object to save, must be picklable.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**obj**（*Any*） - 要保存的对象，必须是可picklable的。'
- en: '**dependencies** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – If `True`, we scan the source for dependencies.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖项**（[*bool*](https://docs.python.org/3/library/functions.html#bool "(在Python
    v3.12中)")，可选） - 如果为`True`，我们会扫描源代码以查找依赖项。'
- en: '[PRE57]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Adds the local file system `file_or_directory` to the source package to provide
    the code for `module_name`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 将本地文件系统中的`file_or_directory`添加到源包中，以提供`module_name`的代码。
- en: Parameters
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**module_name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")) – e.g. `"my_package.my_subpackage"`, code will be saved
    to provide code for this package.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**module_name**（[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(在Python v3.12中)")） - 例如`"my_package.my_subpackage"`，将保存代码以提供此包的代码。'
- en: '**file_or_directory** ([*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")) – the path to a file or directory of code. When a directory,
    all python files in the directory are recursively copied using [`save_source_file()`](#torch.package.PackageExporter.save_source_file
    "torch.package.PackageExporter.save_source_file"). If a file is named `"/__init__.py"`
    the code is treated as a package.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**file_or_directory**（[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(在Python v3.12中)")） - 文件或代码目录的路径。当目录时，使用[`save_source_file()`](#torch.package.PackageExporter.save_source_file
    "torch.package.PackageExporter.save_source_file")递归复制目录中的所有python文件。如果文件命名为`"/__init__.py"`，则将代码视为包。'
- en: '**dependencies** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – If `True`, we scan the source for dependencies.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖项**（[*bool*](https://docs.python.org/3/library/functions.html#bool "(在Python
    v3.12中)")，可选） - 如果为`True`，我们会扫描源代码以查找依赖项。'
- en: '[PRE58]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Adds `src` as the source code for `module_name` in the exported package.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在导出的包中将`src`作为`module_name`的源代码添加。
- en: Parameters
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**module_name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")) – e.g. `my_package.my_subpackage`, code will be saved to
    provide code for this package.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**module_name**（[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(在Python v3.12中)")） - 例如`my_package.my_subpackage`，将保存代码以提供此包的代码。'
- en: '**src** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python
    v3.12)")) – The Python source code to save for this package.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**src**（[*str*](https://docs.python.org/3/library/stdtypes.html#str "(在Python
    v3.12中)")） - 要保存到此包的Python源代码。'
- en: '**is_package** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – If `True`, this module is treated as a package.
    Packages are allowed to have submodules (e.g. `my_package.my_subpackage.my_subsubpackage`),
    and resources can be saved inside them. Defaults to `False`.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**is_package**（*bool*，可选）- 如果为`True`，则将此模块视为包。允许包具有子模块（例如`my_package.my_subpackage.my_subsubpackage`），并且资源可以保存在其中。默认为`False`。'
- en: '**dependencies** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – If `True`, we scan the source for dependencies.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖**（*bool*，可选）- 如果为`True`，我们会扫描源代码以获取依赖项。'
- en: '[PRE59]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Save text data to the package.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 将文本数据保存到包中。
- en: Parameters
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**package** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – The name of module package this resource should go it (e.g.
    `"my_package.my_subpackage"`).'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**package**（*str*）- 此资源应该放在的模块包的名称（例如`"my_package.my_subpackage"`）。'
- en: '**resource** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – A unique name for the resource, used to identify it to load.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**resource**（*str*）- 用于标识资源的唯一名称，用于加载。'
- en: '**text** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – The contents to save.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**text**（*str*）- 要保存的内容。'
- en: '[PRE60]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Importers allow you to load code written to packages by [`PackageExporter`](#torch.package.PackageExporter
    "torch.package.PackageExporter"). Code is loaded in a hermetic way, using files
    from the package rather than the normal python import system. This allows for
    the packaging of PyTorch model code and data so that it can be run on a server
    or used in the future for transfer learning.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 导入器允许您加载由[`PackageExporter`](#torch.package.PackageExporter "torch.package.PackageExporter")编写的包中的代码。代码以封闭方式加载，使用包中的文件而不是正常的python导入系统。这允许将PyTorch模型代码和数据打包，以便在服务器上运行或在将来用于迁移学习。
- en: The importer for packages ensures that code in the module can only be loaded
    from within the package, except for modules explicitly listed as external during
    export. The file `extern_modules` in the zip archive lists all the modules that
    a package externally depends on. This prevents “implicit” dependencies where the
    package runs locally because it is importing a locally-installed package, but
    then fails when the package is copied to another machine.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 包的导入器确保模块中的代码只能从包内加载，除了在导出期间明确列出为外部模块的模块。zip存档中的`extern_modules`文件列出了包在外部依赖的所有模块。这可以防止“隐式”依赖，其中包在本地运行，因为它正在导入一个本地安装的包，但是当包被复制到另一台机器时会失败。
- en: '[PRE61]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Open `file_or_buffer` for importing. This checks that the imported package only
    requires modules allowed by `module_allowed`
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`file_or_buffer`以进行导入。这将检查导入的包是否仅需要`module_allowed`允许的模块。
- en: Parameters
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**file_or_buffer** ([*Union*](https://docs.python.org/3/library/typing.html#typing.Union
    "(in Python v3.12)")*[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*,* *PyTorchFileReader**,* [*Path*](https://docs.python.org/3/library/pathlib.html#pathlib.Path
    "(in Python v3.12)")*,* [*BinaryIO*](https://docs.python.org/3/library/typing.html#typing.BinaryIO
    "(in Python v3.12)")*]*) – a file-like object (has to implement `read()`, `readline()`,
    `tell()`, and `seek()`), a string, or an `os.PathLike` object containing a filename.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**file_or_buffer**（*Union*[*[*str*]*，*PyTorchFileReader*，*[*Path*]*，*[*BinaryIO*]*]）-
    类似文件的对象（必须实现`read()`，`readline()`，`tell()`和`seek()`），一个字符串，或包含文件名的`os.PathLike`对象。'
- en: '**module_allowed** (*Callable**[**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]**,* [*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*]**,* *optional*) – A method to determine if a externally
    provided module should be allowed. Can be used to ensure packages loaded do not
    depend on modules that the server does not support. Defaults to allowing anything.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**module_allowed**（*Callable**[*[*str*]*，*bool*]*，可选）- 用于确定是否应允许外部提供的模块的方法。可以用于确保加载的包不依赖于服务器不支持的模块。默认允许任何内容。'
- en: Raises
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 引发
- en: '[**ImportError**](https://docs.python.org/3/library/exceptions.html#ImportError
    "(in Python v3.12)") – If the package will use a disallowed module.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '[**ImportError**](https://docs.python.org/3/library/exceptions.html#ImportError
    "(in Python v3.12)")- 如果包将使用不允许的模块。'
- en: '[PRE62]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Returns a file structure representation of package’s zipfile.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 返回包的zip文件结构表示。
- en: Parameters
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**include** (*Union**[**List**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]**,* [*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]*) – An optional string e.g. `"my_package.my_subpackage"`,
    or optional list of strings for the names of the files to be included in the zipfile
    representation. This can also be a glob-style pattern, as described in [`PackageExporter.mock()`](#torch.package.PackageExporter.mock
    "torch.package.PackageExporter.mock")'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**include**（*Union**[**List**[*[*str*]*]**，*[*str*]*]）- 一个可选的字符串，例如`"my_package.my_subpackage"`，或者包含在zip文件表示中的文件名称的可选字符串列表。这也可以是一个类似glob的模式，如[`PackageExporter.mock()`](#torch.package.PackageExporter.mock
    "torch.package.PackageExporter.mock")中所述。'
- en: '**exclude** (*Union**[**List**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]**,* [*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]*) – An optional pattern that excludes files whose name
    match the pattern.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**exclude**（*Union**[**List**[*[*str*]*]**，*[*str*]*]）- 一个可选的模式，用于排除与模式匹配的文件。'
- en: Returns
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: '[`Directory`](#torch.package.Directory "torch.package.Directory")'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Directory`](#torch.package.Directory "torch.package.Directory")'
- en: Return type
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[*Directory*](#torch.package.Directory "torch.package.file_structure_representation.Directory")'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '[*Directory*](#torch.package.Directory "torch.package.file_structure_representation.Directory")'
- en: '[PRE63]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Returns internal identifier that torch.package uses to distinguish [`PackageImporter`](#torch.package.PackageImporter
    "torch.package.PackageImporter") instances. Looks like:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 返回内部标识符，torch.package 用于区分 [`PackageImporter`](#torch.package.PackageImporter
    "torch.package.PackageImporter") 实例。看起来像：
- en: '[PRE64]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Load a module from the package if it hasn’t already been loaded, and then return
    the module. Modules are loaded locally to the importer and will appear in `self.modules`
    rather than `sys.modules`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未加载包中的模块，则加载该模块，然后返回模块。模块在导入程序本地加载，并将出现在 `self.modules` 而不是 `sys.modules`
    中。
- en: Parameters
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – Fully qualified name of the module to load.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – 要加载的模块的完全限定名称。'
- en: '**package** (*[*[*type*](https://docs.python.org/3/library/functions.html#type
    "(in Python v3.12)")*]**,* *optional*) – Unused, but present to match the signature
    of importlib.import_module. Defaults to `None`.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**package** (*[*[*type*](https://docs.python.org/3/library/functions.html#type
    "(in Python v3.12)")*]**,* *optional*) – 未使用，但出现以匹配 importlib.import_module 的签名。默认为
    `None`。'
- en: Returns
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: The (possibly already) loaded module.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: （可能已经）加载的模块。
- en: Return type
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[types.ModuleType](https://docs.python.org/3/library/types.html#types.ModuleType
    "(in Python v3.12)")'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '[types.ModuleType](https://docs.python.org/3/library/types.html#types.ModuleType
    "(in Python v3.12)")'
- en: '[PRE66]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Load raw bytes.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 加载原始字节。
- en: Parameters
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**package** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – The name of module package (e.g. `"my_package.my_subpackage"`).'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**package** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – 模块包的名称（例如 `"my_package.my_subpackage"`）。'
- en: '**resource** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – The unique name for the resource.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**resource** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – 资源的唯一名称。'
- en: Returns
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: The loaded data.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 加载的数据。
- en: Return type
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[bytes](https://docs.python.org/3/library/stdtypes.html#bytes "(in Python v3.12)")'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '[bytes](https://docs.python.org/3/library/stdtypes.html#bytes "(in Python v3.12)")'
- en: '[PRE67]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Unpickles the resource from the package, loading any modules that are needed
    to construct the objects using [`import_module()`](#torch.package.PackageImporter.import_module
    "torch.package.PackageImporter.import_module").
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 从包中反序列化资源，加载任何需要构造对象的模块，使用 [`import_module()`](#torch.package.PackageImporter.import_module
    "torch.package.PackageImporter.import_module")。
- en: Parameters
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**package** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – The name of module package (e.g. `"my_package.my_subpackage"`).'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**package** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – 模块包的名称（例如 `"my_package.my_subpackage"`）。'
- en: '**resource** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – The unique name for the resource.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**resource** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – 资源的唯一名称。'
- en: '**map_location** – Passed to torch.load to determine how tensors are mapped
    to devices. Defaults to `None`.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**map_location** – 传递给 torch.load 以确定张量如何映射到设备。默认为 `None`。'
- en: Returns
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: The unpickled object.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 反序列化的对象。
- en: Return type
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: Any
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 任何
- en: '[PRE68]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Load a string.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 加载字符串。
- en: Parameters
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**package** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – The name of module package (e.g. `"my_package.my_subpackage"`).'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**package** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – 模块包的名称（例如 `"my_package.my_subpackage"`）。'
- en: '**resource** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – The unique name for the resource.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**resource** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – 资源的唯一名称。'
- en: '**encoding** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")*,* *optional*) – Passed to `decode`. Defaults to `''utf-8''`.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**encoding** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")*,* *optional*) – 传递给 `decode`。默认为 `''utf-8''`。'
- en: '**errors** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")*,* *optional*) – Passed to `decode`. Defaults to `''strict''`.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**errors** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")*,* *optional*) – 传递给 `decode`。默认为 `''strict''`。'
- en: Returns
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: The loaded text.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 加载的文本。
- en: Return type
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")'
- en: '[PRE69]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Returns the version of python that was used to create this package.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 返回用于创建此包的 python 版本。
- en: 'Note: this function is experimental and not Forward Compatible. The plan is
    to move this into a lock file later on.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：此函数是实验性的，不具有向前兼容性。计划将其稍后移入锁定文件。
- en: Returns
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: '`Optional[str]` a python version e.g. 3.8.9 or None if no version was stored
    with this package'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional[str]` 一个 python 版本，例如 3.8.9，如果没有存储与此包相关的版本，则为 None'
- en: '[PRE70]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: A file structure representation. Organized as Directory nodes that have lists
    of their Directory children. Directories for a package are created by calling
    [`PackageImporter.file_structure()`](#torch.package.PackageImporter.file_structure
    "torch.package.PackageImporter.file_structure").
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 文件结构表示。组织为具有其 Directory 子节点列表的 Directory 节点。通过调用 [`PackageImporter.file_structure()`](#torch.package.PackageImporter.file_structure
    "torch.package.PackageImporter.file_structure") 来创建包的目录。
- en: '[PRE71]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Checks if a file is present in a [`Directory`](#torch.package.Directory "torch.package.Directory").
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 检查文件是否存在于 [`Directory`](#torch.package.Directory "torch.package.Directory")
    中。
- en: Parameters
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**filename** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – Path of file to search for.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '**filename** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – 要搜索的文件路径。'
- en: Returns
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: If a [`Directory`](#torch.package.Directory "torch.package.Directory") contains
    the specified file.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 [`Directory`](#torch.package.Directory "torch.package.Directory") 包含指定的文件。
- en: Return type
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.12)")'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '[bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.12)")'
