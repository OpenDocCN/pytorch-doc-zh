# 分布式检查点 - torch.distributed.checkpoint

> 原文：[`pytorch.org/docs/stable/distributed.checkpoint.html`](https://pytorch.org/docs/stable/distributed.checkpoint.html)

分布式检查点（DCP）支持并行从多个排名加载和保存模型。它处理加载时的重分片，使得可以在一个集群拓扑中保存并加载到另一个集群拓扑中。

DCP 与 torch.save 和 torch.load 在几个重要方面有所不同：

+   每个检查点会生成多个文件，每个排名至少有一个文件。

+   它是就地操作，这意味着模型应该首先分配其数据，DCP 将使用该存储空间。

加载和保存检查点的入口点如下：

```py
torch.distributed.checkpoint.load(state_dict, storage_reader, *, process_group=None, coordinator_rank=0, no_dist=False, planner=None)¶
```

以 SPMD 风格加载分布式`state_dict`。

每个排名将尝试读取尽可能少的数据以满足请求的 state_dict。在加载`ShardedTensor`或`DTensor`实例时，每个排名只读取其本地分片的数据。

对于每个具有`state_dict`和`load_state_dict`的`Stateful`对象，在尝试反序列化之前，load 将首先调用`state_dict`，然后在反序列化完成后调用`load_state_dict`。

警告

`state_dict`中的所有张量必须在调用此函数之前分配到其目标设备上。

所有非张量数据都是使用 torch.load()加载并在 state_dict 上进行就地修改的。

警告

用户必须在根模块上调用 load_state_dict 以确保加载后处理和非张量数据正确传播。

参数

+   **state_dict**（*Dict**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* *Any**]*) - 要加载的 state_dict。请注意，此 state dict 将就地更新。

+   **storage_reader**（*StorageReader*）- 用于加载数据的 StorageReader。

+   **process_group**（*ProcessGroup*）- 用于跨排同步的 ProcessGroup。

+   **coordinator_rank**（[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")）- 用于协调检查点的排名。默认情况下使用 rank0。

+   **no_dist**（[*bool*](https://docs.python.org/3/library/functions.html#bool "(in Python v3.12)")）- 如果为`True`，分布式检查点将不以 SPMD 风格加载。 （默认值：`False`）

返回

无。

返回类型

无

示例

```py
>>> my_model = MyModule()
>>> optimizer = Adagrad(my_model.parameters())
>>> model_state_dict = my_model.state_dict()
>>> fs_storage_reader = torch.distributed.checkpoint.FileSystemReader("/checkpoint/1") 
```

```py
>>> torch.distributed.checkpoint.load_state_dict(
>>>     state_dict=model_state_dict,
>>>     storage_reader=fs_storage_reader,
>>> ) 
```

```py
>>> # module.load_state_dict() function might have customized steps
>>> # to flush the state_dict, must call it to
>>> # ensure correct behavior.
>>> my_model.load_state_dict(model_state_dict) 
```

注意

load_state_dict 使用集合来协调跨排读取。对于基于 NCCL 的进程组，对象的内部张量表示必须在通信发生之前移动到 GPU 设备。在这种情况下，使用的设备由`torch.cuda.current_device()`给出，用户有责任确保设置了这一点，以便每个排名都有一个独立的 GPU，通过`torch.cuda.set_device()`。

```py
torch.distributed.checkpoint.save(state_dict, storage_writer, *, process_group=None, coordinator_rank=0, no_dist=False, planner=None)¶
```

以 SPMD 风格保存分布式模型。

此函数与`torch.save()`不同，它处理`ShardedTensor`和`DTensor`，通过让每个排名仅保存其本地分片来实现。

对于每个具有`state_dict`和`load_state_dict`的`Stateful`对象，在序列化之前会调用`state_dict`。

警告

对于保存的 state_dicts，不保证在 PyTorch 版本之间的向后兼容性。

警告

如果使用 process_group 参数，请确保只有其排名调用 save_state_dict，并且 state_dict 中的所有数据都属于它。

注意

对于 FSDP 的 ShardingStrategy.HYBRID_SHARD 保存检查点时，只有一个 shard_group 应该调用 save_state_dict，并且需要传递相应的进程组。

注意

通过传递`no_dist=True`，可以在没有初始化进程组的情况下使用此函数保存 state_dict。

参数

+   **state_dict**（*Dict**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* *Any**]*) - 要保存的 state_dict。

+   **storage_writer**（*StorageWriter*）- 用于执行写操作的 StorageWriter 实例。

+   **process_group**（*ProcessGroup*） - 用于跨等级同步的 ProcessGroup。

+   **coordinator_rank**（[*int*](https://docs.python.org/3/library/functions.html#int "(在 Python v3.12 中)")） - 用于协调检查点的等级。默认情况下使用 rank0。

+   **no_dist**（[*bool*](https://docs.python.org/3/library/functions.html#bool "(在 Python v3.12 中)")） - 如果为`True`，分布式检查点将不以 SPMD 样式保存。（默认值：`False`）

返回

保存检查点的元数据对象。

返回类型

元数据

示例

```py
>>> my_model = MyModule() 
```

```py
>>> model_state_dict = my_model.state_dict() 
```

```py
>>> fs_storage_writer = torch.distributed.checkpoint.FileSystemWriter("/checkpoint/1")
>>> torch.distributed.checkpoint.save_state_dict(
>>>     state_dict=model_state_dict,
>>>     storage_writer=fs_storage_writer,
>>> ) 
```

注意

save_state_dict 使用集合来协调跨等级的写入。对于基于 NCCL 的进程组，对象的内部张量表示必须在通信发生之前移动到 GPU 设备。在这种情况下，使用的设备由`torch.cuda.current_device()`给出，用户有责任确保设置正确，以便每个等级都有独立的 GPU，通过`torch.cuda.set_device()`。

```py
torch.distributed.checkpoint.load_state_dict(state_dict, storage_reader, process_group=None, coordinator_rank=0, no_dist=False, planner=None)¶
```

此方法已弃用。请切换到“load”。

```py
torch.distributed.checkpoint.save_state_dict(state_dict, storage_writer, process_group=None, coordinator_rank=0, no_dist=False, planner=None)¶
```

此方法已弃用。请切换到“save”。

返回类型

*元数据*

除了上述入口点外，如下所述的 Stateful 对象在保存/加载期间提供额外的定制化.. automodule:: torch.distributed.checkpoint.stateful

```py
class torch.distributed.checkpoint.stateful.Stateful(*args, **kwargs)¶
```

可以进行检查点和恢复的具有状态的对象的 Stateful 协议。

```py
load_state_dict(state_dict)¶
```

从提供的 state_dict 中恢复对象的状态。

参数

**state_dict**（[*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(在 Python v3.12 中)")*[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(在 Python v3.12 中)")*,* [*Any*](https://docs.python.org/3/library/typing.html#typing.Any "(在 Python v3.12 中)")*]*) - 要从中恢复的状态字典

```py
state_dict()¶
```

对象应该将它们的 state_dict 表示作为字典返回。此函数的输出将被检查点，并稍后在 load_state_dict()中恢复。

警告

由于恢复检查点的就地性质，此函数在 torch.distributed.checkpoint.load 期间也被调用。

返回

对象状态字典

返回类型

字典

这个[示例](https://github.com/pytorch/pytorch/blob/main/torch/distributed/checkpoint/examples/fsdp_checkpoint_example.py)展示了如何使用 Pytorch 分布式检查点保存 FSDP 模型。

以下类型定义了检查点期间使用的 IO 接口：

```py
class torch.distributed.checkpoint.StorageReader¶
```

`load_state_dict`用于从存储中读取的接口。

一个 StorageReader 实例在分布式检查点中同时充当协调员和跟随者。作为初始化的一部分，告知每个实例其角色。

子类应该期望`load_state_dict`按以下顺序调用：

1.  （所有等级）read_metadata()

1.  （所有等级）set_up_storage_reader()

1.  （所有等级）prepare_local_plan()

1.  （协调员）prepare_global_plan()

1.  （所有等级）read_data()

```py
abstract prepare_global_plan(plans)¶
```

执行存储加载的集中规划。

此方法仅在协调员实例上调用。

虽然此方法可以生成完全不同的计划，但推荐的方法是将特定于存储的数据存储在 LoadPlan::storage_data 中。

参数

**plans**（[*List*](https://docs.python.org/3/library/typing.html#typing.List "(在 Python v3.12 中)")**[*LoadPlan**]*) - 每个等级一个`LoadPlan`实例的列表。

返回

存储全局规划后的转换后的`LoadPlan`列表

返回类型

[*List*](https://docs.python.org/3/library/typing.html#typing.List "(在 Python v3.12 中)")[*LoadPlan*]

```py
abstract prepare_local_plan(plan)¶
```

执行特定于存储的本地规划。

虽然此方法可以生成完全不同的计划，但推荐的方法是将特定于存储的数据存储在 LoadPlan::storage_data 中。

参数

**plan**（*LoadPlan*） - 使用中的`LoadPlan`的本地计划。

返回

存储本地规划后的转换后的`LoadPlan`

返回类型

*LoadPlan*

```py
abstract read_data(plan, planner)¶
```

使用`planner`从`plan`中读取所有项目以解析数据。

子类应调用`LoadPlanner::load_bytes`将 BytesIO 对象反序列化到正确的位置。

子类应调用`LoadPlanner::resolve_tensor`来访问应加载数据的张量。

StorageLayer 有责任正确安排所需的任何跨设备复制。

参数

+   **plan**（*LoadPlan*） - 要执行的本地计划

+   **planner**（*LoadPlanner*） - 用于解析项目的计划器对象。

返回

一种在所有读取完成后完成的未来。

返回类型

*Future*[无]

```py
abstract read_metadata()¶
```

读取检查点元数据。

返回

与正在加载的检查点相关联的元数据对象。

返回类型

*元数据*

```py
abstract set_up_storage_reader(metadata, is_coordinator)¶
```

初始化此实例。

参数

+   **metadata**（*Metadata*） - 要使用的元数据模式。

+   **is_coordinator**（[*bool*](https://docs.python.org/3/library/functions.html#bool "(在 Python v3.12 中)")） - 此实例是否负责协调检查点。

```py
class torch.distributed.checkpoint.StorageWriter¶
```

`save_state_dict`用于写入存储的接口。

一个 StorageWriter 实例在分布式检查点中充当协调器和跟随者。作为初始化的一部分，告知每个实例其角色。

子类应该期望以下调用序列。

1.  （所有秩）set_up_storage_writer()

1.  （所有秩）prepare_local_plan()

1.  （协调器）prepare_global_plan()

1.  （所有秩）write_data()

1.  （协调器）完成()

```py
abstract finish(metadata, results)¶
```

写入元数据并将当前检查点标记为成功。

用于序列化元数据的实际格式/模式是实现细节。唯一要求是它可以恢复到相同的对象图中。

参数

+   **metadata**（*Metadata*） - 新检查点的元数据

+   **results**（[*List*](https://docs.python.org/3/library/typing.html#typing.List "(在 Python v3.12 中)")*[*[*List*](https://docs.python.org/3/library/typing.html#typing.List "(在 Python v3.12 中)")*[**WriteResult**]**]*) - 所有秩的 WriteResults 列表。

返回

无

返回类型

无

```py
abstract prepare_global_plan(plans)¶
```

执行存储的集中规划。

此方法仅在协调器实例上调用。

虽然此方法可以生成完全不同的计划，但首选方法是将特定于存储的数据存储在 SavePlan::storage_data 中。

参数

**plans**（[*List*](https://docs.python.org/3/library/typing.html#typing.List "(在 Python v3.12 中)")**[*SavePlan**]*) - `SavePlan`实例列表，每个秩一个。

返回

一个经过转换的`SavePlan`列表，存储全局规划后

返回类型

[*List*](https://docs.python.org/3/library/typing.html#typing.List "(在 Python v3.12 中)")[*SavePlan*]

```py
abstract prepare_local_plan(plan)¶
```

执行特定于存储的本地规划。

虽然此方法可以生成完全不同的计划，但推荐的方法是将特定于存储的数据存储在 SavePlan::storage_data 中。

参数

**plan**（*SavePlan*） - 使用中的`SavePlanner`中的本地计划。

返回

存储本地规划后的转换的`SavePlan`

返回类型

*SavePlan*

```py
abstract set_up_storage_writer(is_coordinator)¶
```

初始化此实例。

参数

**is_coordinator**（[*bool*](https://docs.python.org/3/library/functions.html#bool "(在 Python v3.12 中)")） - 此实例是否负责协调检查点。

```py
abstract write_data(plan, planner)¶
```

使用`planner`解析数据，从`plan`中写入所有项目。

子类应该对计划中的每个项目调用`SavePlanner::resolve_data`以获得写入底层对象的访问权限。

子类应该懒惰地调用 resolve_data，因为它可能会分配内存。对于张量，做出以下假设：

+   它们可能位于任何设备上，包括与`WriteItem::tensor_data`不匹配的设备

+   它们可能是视图，也可能不是连续的。只需要保存投影。

参数

+   **plan** (*SavePlan*) – 要执行的保存计划。

+   **planner** (*SavePlanner*) – 用于将项目解析为数据的规划器对象。

返回

一个将完成为 WriteResult 列表的未来

返回类型

*Future*[[*List*](https://docs.python.org/3/library/typing.html#typing.List "(在 Python v3.12 中)")[*WriteResult*]]

以下类型定义了检查点期间使用的规划器接口：

```py
class torch.distributed.checkpoint.LoadPlanner¶
```

定义 load_state_dict 用于规划加载过程的协议的抽象类。

LoadPlanner 是可以用于自定义整个加载过程的有状态对象。

LoadPlanner 充当对 state_dict 的访问代理，因此对其进行的任何转换都将对整个过程可见。

在 load_state_dict 期间，规划器子类可以期望以下调用序列：

1.  set_up_planner - 在所有等级上调用。

    标志着加载检查点的开始。

1.  create_local_plan - 在所有等级上调用。

    处理 state_dict 并生成将发送到全局规划的 LoadPlan。

1.  create_global_plan - 仅在协调等级上调用。

    获取所有等级的 LoadPlan 并做出任何全局决策。

1.  load_bytes - 在每个等级上多次调用

    对于 state_dict 中的每个非张量值，调用一次。

1.  resolve_tensor 和 commit_tensor - 在每个等级上多次调用

    它们为 state_dict 中的每个张量值成对调用。

建议用户扩展 DefaultLoadPlanner 而不是直接扩展此接口，因为大多数更改可以通过更改单个方法来表达。

有两种常见的扩展模式：

重写 state_dict。这是扩展加载过程的最简单方法，因为它不需要理解 LoadPlan 的工作原理。由于加载是就地进行的，因此我们需要保留对原始 state_dict 的引用，因此我们需要能够就地执行它

```py
>>> class RenamePlanner(DefaultLoadPlanner):
>>>     def set_up_planner(self, state_dict, metadata, is_coordinator):
>>>         self.original_state_dict = state_dict
>>>         state_dict = {"foo_" + k: v for k, v in state_dict.items()}
>>>
>>>         if self.flatten_sharded_tensors:
>>>             state_dict = _flatten_sharded_tensors(state_dict)
>>>
>>>         if self.flatten_state_dict:
>>>             state_dict, self.mappings = flatten_state_dict(state_dict)
>>>
>>>         self.state_dict = state_dict
>>>         self.metadata = metadata
>>>         self.is_coordinator = is_coordinator
>>>
>>>     def load_bytes(self, read_item, value):
>>>         # Remove the "foo_" prefix
>>>         self.original_state_dict[read_item.dest_index.fqn[4:]] = torch.load(value) 
```

修改 resolve_tensor 和 commit_tensor 以处理加载时的转换。

```py
>>> class MetaModelMaterialize(DefaultSavePlanner):
>>>     def resolve_tensor(self, read_item):
>>>         tensor = super().resolve_tensor(read_item)
>>>         return torch.empty_like(tensor, device="cpu")
>>>
>>>     def commit_tensor(self, read_item, tensor):
>>>         self.state_dict[read_item.dest_index.fqn] = tensor 
```

```py
abstract commit_tensor(read_item, tensor)¶
```

在 StorageReader 完成将数据加载到`tensor`后调用一次。

提供的张量与调用`resolve_tensor`返回的相同。如果此 LoadPlanner 需要在将`tensor`复制回 state_dict 中的张量之前对其进行后处理，则只需要此方法。

张量的内容将遵循其设备同步模型。

```py
abstract create_global_plan(global_plan)¶
```

计算全局加载计划并返回每个等级的计划。

。注意：仅在协调等级上调用

返回类型

[*List*](https://docs.python.org/3/library/typing.html#typing.List "(在 Python v3.12 中)")[*LoadPlan*]

```py
abstract create_local_plan()¶
```

根据 set_up_planner 提供的 state_dict 和元数据创建一个 LoadPlan。

。注意：在每个等级上调用。

返回类型

*LoadPlan*

```py
abstract finish_plan(central_plan)¶
```

接受来自协调员的计划并返回最终的 LoadPlan。

返回类型

*LoadPlan*

```py
abstract load_bytes(read_item, value)¶
```

加载由`read_item``和``value`描述的项目。

这种方法预计会就地修改底层的 state_dict。

`value`的内容由用于生成正在加载的检查点的 SavePlanner 定义。

```py
abstract resolve_tensor(read_item)¶
```

返回由`read_item`描述的张量，以供 StorageReader 加载 read_item 使用。

张量应该与底层 state_dict 上的张量别名，因为 StorageReader 将替换其内容。如果由于任何原因这不可能，规划器可以使用`commit_tensor`方法将数据复制回 state_dict 中的数据。

返回类型

*Tensor*

```py
abstract set_up_planner(state_dict, metadata, is_coordinator)¶
```

初始化此实例以将数据加载到`state_dict`中。

. 注意。这在每个等级上都会被调用。

```py
class torch.distributed.checkpoint.LoadPlan(items: List[torch.distributed.checkpoint.planner.ReadItem], storage_data: Any = None, planner_data: Any = None)¶
```

```py
class torch.distributed.checkpoint.ReadItem(type: torch.distributed.checkpoint.planner.LoadItemType, dest_index: torch.distributed.checkpoint.metadata.MetadataIndex, dest_offsets: torch.Size, storage_index: torch.distributed.checkpoint.metadata.MetadataIndex, storage_offsets: torch.Size, lengths: torch.Size)¶
```

```py
class torch.distributed.checkpoint.SavePlanner¶
```

定义由 save_state_dict 用于规划保存过程的协议的抽象类。

SavePlanners 是可以用来自定义整个保存过程的有状态对象。

SavePlanner 充当对 state_dict 的访问代理，因此对其进行的任何转换都将对整个过程可见。

在保存状态字典期间，规划器子类可以期望以下调用序列：

1.  set_up_planner - 在所有等级上调用。

    标志着检查点保存的开始。

1.  create_local_plan - 在所有等级上调用。

    处理 state_dict 并生成一个将发送给全局规划的 SavePlan。

1.  create_global_plan - 仅在协调员等级上调用。

    获取所有等级的 SavePlan 并做出任何全局决定。

1.  finish_plan - 在所有等级上调用。

    这使每个等级有机会调整到全局规划决策。

1.  resolve_data - 在每个等级上多次调用

    在 state_dict 上查找存储层要写入的值。

建议用户扩展 DefaultSavePlanner 而不是直接扩展此接口，因为大多数更改可以通过单个方法的更改来表达。

有 3 种常见的扩展模式：

重写 state_dict。这是扩展保存过程的最简单方法，因为它不需要理解 SavePlan 的工作原理的复杂性：

```py
>>> class RenamePlanner(DefaultSavePlanner):
>>>     def set_up_planner(self, state_dict, is_coordinator):
>>>         # prefix all keys with `foo_``
>>>         super().set_up_planner({"foo_" + k: v for k, v in state_dict.items()}, is_coordinator) 
```

修改本地计划并同时查找。当需要对数据持久化的方式进行精细控制时，这是有用的。

```py
>>> class FP16Planner(DefaultSavePlanner):
>>>     def create_local_plan(self):
>>>         plan = super().create_local_plan()
>>>         for p in plan:
>>>             if p.tensor_data is not None:
>>>                 p.tensor_data.properties.dtype = torch.float16
>>>         return plan
>>>
>>>     def resolve_data(self, write_item):
>>>         item = super().resolve_data(write_item)
>>>         return item if write_item.type == WriteItemType.BYTE_IO else item.to(torch.float16) 
```

使用全局规划步骤做出中央决策，这些决策无法由每个等级单独做出

```py
>>> from itertools import islice
>>> from dataclasses import replace
>>> class DDPLoadBalancingPlanner(DefaultSavePlanner):
>>>     # This uses the default local plan behavior of having all non-sharded writes in rank 0
>>>     # This sample doesn't handle ShardedTensors
>>>     def create_global_plan(self, all_plans):
>>>         def chunk(it, size):
>>>             it = iter(it)
>>>         return list(iter(lambda: tuple(islice(it, size)), ()))
>>>         all_plans = [
>>>             replace(plan, items=items) for plan, items in
>>>                 zip(all_plans, chunk(all_plans[0].items, len(all_plans)))
>>>         ]
>>>         return super().create_global_plan(all_plans) 
```

最后，一些规划器需要在检查点中保存附加元数据，这是通过让每个等级在本地计划中贡献其数据项并让全局规划器聚合它们来实现的：

```py
>>> class SaveExtraDataPlanner(DefaultSavePlanner):
>>>     def create_local_plan(self) -> SavePlan:
>>>         plan = super().create_local_plan()
>>>         return replace(plan, planner_data="per-rank-data")
>>>
>>>     def create_global_plan(self, all_plans: List[SavePlan]) -> Tuple[List[SavePlan], Metadata]:
>>>         global_plan, metadata = super().create_global_plan(all_plans)
>>>         merged_data = [p.planner_data for p in global_plan]
>>>         metadata = replace(metadata, planner_data=merged_data)
>>>         return global_plan, metadata 
```

```py
abstract create_global_plan(all_plans)¶
```

计算全局检查点计划并返回每个等级的本地计划。

这仅在协调员等级上调用。

返回类型

[*Tuple*](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.12)")[[*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python v3.12)")[*SavePlan*], *Metadata*]

```py
abstract create_local_plan()¶
```

计算当前等级的保存计划。

这将被聚合并传递给 create_global_plan。规划器特定的数据可以通过 SavePlan::planner_data 传递。

这在所有等级上都会被调用。

返回类型

*SavePlan*

```py
abstract finish_plan(new_plan)¶
```

合并由 create_local_plan 创建的计划和 create_global_plan 的结果。

这在所有等级上都会被调用。

返回类型

*SavePlan*

```py
abstract resolve_data(write_item)¶
```

转换和准备`state_dict`中的`write_item`以供存储，确保幂等性和线程安全。

查找与`write_item`在`state_dict`中关联的对象，并在存储层消耗之前应用任何转换（如序列化）。

在最终 SavePlan 中的每个 WriteItem 中，每个等级多次调用，至少一次。

此方法应该是幂等的和线程安全的。StorageWriter 实现可以根据需要频繁调用它。

任何分配内存的转换都应该在调用此方法时懒惰地完成，以减少检查点所需的峰值内存。

在返回张量时，它们可以在任何设备或格式上，它们也可以是视图。存储层负责找出如何保存它们。

返回类型

[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")[*Tensor*, *BytesIO*]

```py
abstract set_up_planner(state_dict, is_coordinator)¶
```

初始化此规划者以保存 `state_dict`。

实现应该保存这些值，因为它们在保存过程中不会提供。

这在所有秩上都被调用。

```py
class torch.distributed.checkpoint.SavePlan(items: List[torch.distributed.checkpoint.planner.WriteItem], storage_data: Any = None, planner_data: Any = None)¶
```

```py
class torch.distributed.checkpoint.WriteItem(index: torch.distributed.checkpoint.metadata.MetadataIndex, type: torch.distributed.checkpoint.planner.WriteItemType, tensor_data: Union[torch.distributed.checkpoint.planner.TensorWriteData, NoneType] = None)¶
```

我们提供了基于文件系统的存储层：

```py
class torch.distributed.checkpoint.FileSystemReader(path)¶
```

```py
class torch.distributed.checkpoint.FileSystemWriter(path, single_file_per_rank=True, sync_files=True, thread_count=1, per_thread_copy_ahead=10000000)¶
```

使用文件 IO 的 StorageWriter 的基本实现。

此实现做出以下假设和简化：

+   检查点路径是一个空的或不存在的目录。

+   文件创建是原子的

检查点由每个写入请求一个文件以及一个包含序列化元数据的 .metadata 文件组成。

我们提供了默认的 LoadPlanner 和 SavePlanner 实现，可以处理所有 torch.distributed 构造，如 FSDP、DDP、ShardedTensor 和 DistributedTensor。

```py
class torch.distributed.checkpoint.DefaultSavePlanner(flatten_state_dict=True, flatten_sharded_tensors=True, dedup_replicated_tensors=True)¶
```

```py
lookup_object(index)¶
```

从规划者接口扩展以便于扩展默认规划者。

返回类型

[*Any*](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.12)")

```py
transform_object(write_item, object)¶
```

从规划者接口扩展以便于扩展默认规划者。

```py
class torch.distributed.checkpoint.DefaultLoadPlanner(flatten_state_dict=True, flatten_sharded_tensors=True)¶
```

DefaultLoadPlanner 在 LoadPlanner 的基础上添加了多个功能。

特别是它添加了以下内容：

flatten_state_dict: 处理具有嵌套字典的 state_dict flatten_sharded_tensors: 用于 FSDP 的 2D 并行模式

```py
lookup_tensor(index)¶
```

从规划者接口扩展以便于扩展默认规划者。

返回类型

*Tensor*

```py
transform_tensor(read_item, tensor)¶
```

从规划者接口扩展以便于扩展默认规划者。

我们提供了一组 API 来帮助用户轻松获取和设置 state_dict。这是一个实验性功能，可能会发生变化。

```py
torch.distributed.checkpoint.state_dict.get_state_dict(model, optimizers, *, submodules=None, options=None)¶
```

返回模型 state_dict 和优化器 state_dict。

`get_state_dict` 可以处理任何由 PyTorch FSDP/fully_shard、DDP/replicate、tensor_parallel/parallelize_module 并且这些并行方式的模块。`get_state_dict` 的主要功能是：1.) 返回一个可以使用不同数量的训练器和/或不同并行方式重新分片的模型和优化器 state_dict。2.) 隐藏特定于并行方式的 state_dict API。用户不必调用这些 API。3.) 对结果 state_dict 进行合理性检查。

结果 state 字典的键是规范的 FQN（Fully Qualified Names）。规范的 FQN 指的是基于参数在 nn.Module 层次结构中的位置的 FQN。更具体地，参数的规范 FQN 是在模块没有被任何并行方式分布时，由 `module.named_parameters()` 或 `module.named_buffers()` 返回的 FQN。由于优化器内部使用参数 ID 来表示参数，因此在调用此 API 时会将参数 ID 转换为规范的 FQN。

`get_state_dict` 也可以处理未并行化的模块。在这种情况下，`get_state_dict` 只执行一个功能 - 将优化器参数 ID 转换为规范的 FQN。

示例

import torch from torch.distributed.fsdp import FullyShardedDataParallel as FSDP from torch.nn.parallel import DistributedDataParallel as DDP from torch.distributed.checkpoint.state_dict import get_state_dict

fsdp_model = FSDP(copy.deepcopy(model)) fsdp_optim = torch.optim.Adam(model.parameters(), lr=1e-3) ddp_model = DDP(copy.deepcopy(model)) ddp_optim = torch.optim.Adam(model.parameters(), lr=1e-3)

ddp_state_dict, ddp_optim_state_dict = get_state_dict(ddp_model, ddp_optim) fsdp_state_dict, fsdp_optim_state_dict = get_state_dict(fsdp_model, fsdp_optim)

# 如果我们简单地调用 ddp_model.state_dict() 和 fsdp_model.state_dict()，# 断言将失败。assert ddp_state_dict == fsdp_state_dict assert ddp_optim_state == fsdp_optim_state_dict

参数

+   **model**（*nn.Module**,* *Iterable***[*Optimizer**]**]*) - 用于优化 `model` 的优化器。

+   **子模块**（[*可选*](https://docs.python.org/3/library/typing.html#typing.Optional "(在 Python v3.12 中)")*[*[*集合*](https://docs.python.org/3/library/typing.html#typing.Set "(在 Python v3.12 中)")**[*模块**]**]*) - 可选[Set[nn.Module]]：仅返回属于子模块的模型参数。

+   **选项**（*StateDictOptions*")[[*字典*](https://docs.python.org/3/library/typing.html#typing.Dict "(在 Python v3.12 中)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(在 Python v3.12 中)"), [*联合*](https://docs.python.org/3/library/typing.html#typing.Union "(在 Python v3.12 中)")*DTensor*, *ShardedTensor*, [*张量*, [int](https://docs.python.org/3/library/functions.html#int "(在 Python v3.12 中)"), [float](https://docs.python.org/3/library/functions.html#float "(在 Python v3.12 中)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(在 Python v3.12 中)"), [*列表*](https://docs.python.org/3/library/typing.html#typing.List "(在 Python v3.12 中)")[[*联合*](https://docs.python.org/3/library/typing.html#typing.Union "(在 Python v3.12 中)")*DTensor*, *ShardedTensor*, [*张量*, [int](https://docs.python.org/3/library/functions.html#int "(在 Python v3.12 中)"), [float](https://docs.python.org/3/library/functions.html#float "(在 Python v3.12 中)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(在 Python v3.12 中)")]], [*元组*](https://docs.python.org/3/library/typing.html#typing.Tuple "(在 Python v3.12 中)")[[*联合*](https://docs.python.org/3/library/typing.html#typing.Union "(在 Python v3.12 中)")*DTensor*, *ShardedTensor*, [*张量*, [int](https://docs.python.org/3/library/functions.html#int "(在 Python v3.12 中)"), [float](https://docs.python.org/3/library/functions.html#float "(在 Python v3.12 中)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(在 Python v3.12 中)")]], [*字典*](https://docs.python.org/3/library/typing.html#typing.Dict "(在 Python v3.12 中)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(在 Python v3.12 中)"), [*联合*](https://docs.python.org/3/library/typing.html#typing.Union "(在 Python v3.12 中)")*DTensor*, *ShardedTensor*, [*张量*, [int](https://docs.python.org/3/library/functions.html#int "(在 Python v3.12 中)"), [float](https://docs.python.org/3/library/functions.html#float "(在 Python v3.12 中)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(在 Python v3.12 中)"), [*列表*](https://docs.python.org/3/library/typing.html#typing.List "(在 Python v3.12 中)")[[*联合*](https://docs.python.org/3/library/typing.html#typing.Union "(在 Python v3.12 中)")*DTensor*, *ShardedTensor*, [*张量*, [int](https://docs.python.org/3/library/functions.html#int "(在 Python v3.12 中)"), [float](https://docs.python.org/3/library/functions.html#float "(在 Python v3.12 中)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(在 Python v3.12 中)")]], [*元组*](https://docs.python.org/3/library/typing.html#typing.Tuple "(在 Python v3.12 中)")[[*联合*](https://docs.python.org/3/library/typing.html#typing.Union "(在 Python v3.12 中)")*DTensor*, *ShardedTensor*, [*张量*, [int](https://docs.python.org/3/library/functions.html#int "(在 Python v3.12 中)"), [float](https://docs.python.org/3/library/functions.html#float "(在 Python v3.12 中)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(在 Python v3.12 中)")]], [*字典*](https://docs.python.org/3/library/typing.html#typing.Dict "(在 Python v3.12 中)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(在 Python v3.12 中)"), ValueType]]]]], [*字典*](https://docs.python.org/3/library/typing.html#typing.Dict "(在 Python v3.12 中)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(在 Python v3.12 中)"), [*联合*](https://docs.python.org/3/library/typing.html#typing.Union "(在 Python v3.12 中)")[[*字典*](https://docs.python.org/3/library/typing.html#typing.Dict "(在 Python v3.12 中)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(在 Python v3.12 中)"), [*联合*](https://docs.python.org/3/library/typing.html#typing.Union "(在 Python v3.12 中)")*DTensor*, *ShardedTensor*, [*张量*, [int](https://docs.python.org/3/library/functions.html#int "(在 Python v3.12 中)"), [float](https://docs.python.org/3/library/functions.html#float "(在 Python v3.12 中)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(在 Python v3.12 中)"), [*列表*](https://docs.python.org/3/library/typing.html#typing.List "(在 Python v3.12 中)")[[*联合*](https://docs.python.org/3/library/typing.html#typing.Union "(在 Python v3.12 中)")*DTensor*, *ShardedTensor*, [*张量*, [int](https://docs.python.org/3/library/functions.html#int "(在 Python v3.12 中)"), [float](https://docs.python.org/3/library/functions.html#float "(在 Python v3.12 中)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(在 Python v3.12 中)")]], [*元组*](https://docs.python.org/3/library/typing.html#typing.Tuple "(在 Python v3.12 中)")[[*联合*](https://docs.python.org/3/library/typing.html#typing.Union "(在 Python v3.12 中)")*DTensor*, *ShardedTensor*, [*张量*, [int](https://docs.python.org/3/library/functions.html#int "(在 Python v3.12 中)"), [float](https://docs.python.org/3/library/functions.html#float "(在 Python v3.12 中)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(在 Python v3.12 中)")]], [*字典*](https://docs.python.org/3/library/typing.html#typing.Dict "(在 Python v3.12 中)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(在 Python v3.12 中)"), [*联合*](https://docs.python.org/3/library/typing.html#typing.Union "(在 Python v3.12 中)")*DTensor*, *ShardedTensor*, [*张量*, [int](https://docs.python.org/3/library/functions.html#int "(在 Python v3.12 中)"), [float](https://docs.python.org/3/library/functions.html#float "(在 Python v3.12 中)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(在 Python v3.12 中)"), [*列表*](https://docs.python.org/3/library/typing.html#typing.List "(在 Python v3.12 中)")[[*联合*](https://docs.python.org/3/library/typing.html#typing.Union "(在 Python v3.12 中)")*DTensor*, *ShardedTensor*, [*张量*, [int](https://docs.python.org/3/library/functions.html#int "(在 Python v3.12 中)"), [float](https://docs.python.org/3/library/functions.html#float "(在 Python v3.12 中)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(在 Python v3.12 中)")]], [*元组*](https://docs.python.org/3/library/typing.html#typing.Tuple "(在 Python v3.12 中)")[[*联合*](https://docs.python.org/3/library/typing.html#typing.Union "(在 Python v3.12 中)")*DTensor*, *ShardedTensor*, [*张量*, [int](https://docs.python.org/3/library/functions.html#int "(在 Python v3.12 中)"), [float](https://docs.python.org/3/library/functions.html#float "(在 Python v3.12 中)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(在 Python v3.12 中)")]], [*字典*](https://docs.python.org/3/library/typing.html#typing.Dict "(在 Python v3.12 中)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(在 Python v3.12 中)"), ValueType]]]]]]]]]

```py
torch.distributed.checkpoint.state_dict.get_model_state_dict(model, *, submodules=None, options=None)¶
```

返回`model`的模型 state_dict。

有关详细用法，请参见`get_state_dict`。

参数

+   **模型**（*nn.Module*） - 模型的 nn.Module。

+   **子模块**（[*可选*](https://docs.python.org/3/library/typing.html#typing.Optional "(在 Python v3.12 中)")*[*[*Set*](https://docs.python.org/3/library/typing.html#typing.Set "(在 Python v3.12 中)")**[*Module**]**]*) - 可选[Set[nn.Module]]：仅返回属于子模块的模型参数。

+   **选项**（*StateDictOptions*")[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)"), [*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")*DTensor*, *ShardedTensor*, [*Tensor*, [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)"), [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)"), [*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python v3.12)")[[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")*DTensor*, *ShardedTensor*, [*Tensor*, [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)"), [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")]], [*Tuple*](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.12)")[[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")*DTensor*, *ShardedTensor*, [*Tensor*, [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)"), [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")]], [*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)"), [*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")*DTensor*, *ShardedTensor*, [*Tensor*, [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)"), [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)"), [*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python v3.12)")[[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")*DTensor*, *ShardedTensor*, [*Tensor*, [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)"), [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")]], [*Tuple*](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.12)")[[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")*DTensor*, *ShardedTensor*, [*Tensor*, [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)"), [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")]], [*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)"), ValueType]]]]]

```py
torch.distributed.checkpoint.state_dict.get_optimizer_state_dict(model, optimizers, *, submodules=None, options=None)¶
```

返回优化器的组合 state_dict。

查看`get_state_dict`以获取详细用法。

参数

+   **model** (*nn.Module*) – 要模型的 nn.Module。

+   **optimizers** (*Union****None**,* [*Optimizer**,* *Iterable***[*Optimizer**]**]*) – 用于优化`model`的优化器。

+   **子模块**（可选） - Optional[Set[Module]]：仅返回属于子模块的模型参数。

+   **选项**（StateDictOptions） - 控制模型 state_dict 和优化器 state_dict 应如何返回的选项。有关详细信息，请参见 StateDictOptions。

返回

`optimizers`的 state_dict。

返回类型

[*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)"), [*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")[[*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)"), [*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")*DTensor*, *ShardedTensor*, [*Tensor*, [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)"), [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)"), [*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python v3.12)")[[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")*DTensor*, *ShardedTensor*, [*Tensor*, [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)"), [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")]], [*Tuple*](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.12)")[[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")*DTensor*, *ShardedTensor*, [*Tensor*, [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)"), [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")]], [*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)"), [*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")*DTensor*, *ShardedTensor*, [*Tensor*, [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)"), [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)"), [*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python v3.12)")[[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")*DTensor*, *ShardedTensor*, [*Tensor*, [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)"), [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")]], [*Tuple*](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.12)")[[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")*DTensor*, *ShardedTensor*, [*Tensor*, [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)"), [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")]], [*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)"), ValueType]]]]], [*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python v3.12)")[[*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)"), [*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")*DTensor*, *ShardedTensor*, [*Tensor*, [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)"), [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)"), [*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python v3.12)")[[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")*DTensor*, *ShardedTensor*, [*Tensor*, [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)"), [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")]], [*Tuple*](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.12)")[[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")*DTensor*, *ShardedTensor*, [*Tensor*, [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)"), [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")]], [*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)"), [*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")*DTensor*, *ShardedTensor*, [*Tensor*, [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)"), [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)"), [*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python v3.12)")[[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")*DTensor*, *ShardedTensor*, [*Tensor*, [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)"), [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")]], [*Tuple*](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.12)")[[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")*DTensor*, *ShardedTensor*, [*Tensor*, [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)"), [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")]], [*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)"), ValueType]]]]]]]]

```py
torch.distributed.checkpoint.state_dict.set_state_dict(model, optimizers, *, model_state_dict, optim_state_dict, options=None)¶
```

加载模型的 state_dict 和优化器的 state_dict。

`get_state_dict` 的对应项，用于将 state_dict 设置为模型和优化器。给定的 `model_state_dict` 和 `optim_state_dict` 不必由 `get_state_dict` 返回，但必须满足以下要求：1）所有 FQN 必须是在 `get_state_dict` 中定义的规范 FQN，2）如果张量被分片，它必须是 ShardedTensor 或 DTensor，3）优化器的 state_dict 不能包含参数 ID；键应该是规范 FQN。

参数

+   **模型**（*nn.Module* - 用于优化 `model` 的优化器。

+   **model_state_dict**（[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")*[*[*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")**[*Module**,* [*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")*[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* [*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* [*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python v3.12)")*[*[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*]**]**,* [*Tuple*](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.12)")*[*[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*]**]**,* [*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")*[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* [*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* [*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python v3.12)")*[*[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*]**]**,* [*Tuple*](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.12)")*[*[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*]**]**,* [*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")*[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* *ValueType**]**]**]**]**]**]*) – (Union[Dict[nn.Module, Dict[str, ValueType]], Dict[str, ValueType]]): 要加载的模型 state_dict。如果`model_state_dict`的键是 nn.Module，则该键是`model`的子模块，值应为子模块的 state_dict。在加载 state_dict 时，子模块的前缀将附加到 state_dict 中。

+   **optim_state_dict** ([*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")*[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* [*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")*[*[*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")*[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* [*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* [*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python v3.12)")*[*[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*]**]**,* [*Tuple*](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.12)")*[*[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*]**]**,* [*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")*[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* [*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* [*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python v3.12)")*[*[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*]**]**,* [*Tuple*](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.12)")*[*[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*]**]**,* [*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")*[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* *ValueType**]**]**]**]**]*) – OptimizerStateType: 要加载的优化器状态字典。

+   **options**（*StateDictOptions*） - 控制如何加载模型 state_dict 和优化器 state_dict 的选项。有关详细信息，请参见 StateDictOptions。

返回

+   **missing_keys**是一个包含模型 state_dict 中缺失键的 str 列表。

+   **unexpected_keys**是一个包含模型 state_dict 中意外键的 str 列表。

返回类型

带有`missing_keys`和`unexpected_keys`字段的`NamedTuple`

```py
torch.distributed.checkpoint.state_dict.set_model_state_dict(model, model_state_dict, *, options=None)¶
```

加载模型的 state_dict。

`get_model_state_dict`的对应项，用于将 state_dict 设置到模型中。有关详细用法，请参见`set_state_dict`。

参数

+   **model**（*nn.Module*） - 模型的 nn.Module。

+   **model_state_dict**（[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")*[*[*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")**[*Module**,* [*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")*[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* [*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* [*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python v3.12)")*[*[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*]**]**,* [*Tuple*](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.12)")*[*[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*]**]**,* [*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")*[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* [*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* [*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python v3.12)")*[*[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*]**]**,* [*Tuple*](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.12)")*[*[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*]**]**,* [*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")*[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* *ValueType**]**]**]**]**]**]*) – (Union[Dict[nn.Module, Dict[str, ValueType]], Dict[str, ValueType]]): 要加载的模型 state_dict。如果`model_state_dict`的键是 nn.Module，则该键是`model`的子模块，值应为子模块的 state_dict。在加载 state_dict 时，子模块的前缀将附加到 state_dict 中。

+   **options**（*StateDictOptions*） - 控制如何加载模型状态字典和优化器状态字典的选项。有关详细信息，请参见 StateDictOptions。

返回

+   **missing_keys** 是一个包含缺失键的字符串列表

+   **unexpected_keys** 是一个包含意外键的字符串列表

返回类型

带有`missing_keys`和`unexpected_keys`字段的`NamedTuple`

```py
torch.distributed.checkpoint.state_dict.set_optimizer_state_dict(model, optimizers, *, optim_state_dict, options=None)¶
```

加载优化器的状态字典。

`get_optimizer_state_dict` 的对应项，用于将状态字典设置为优化器。有关详细用法，请参见`set_state_dict`。

参数

+   **model**（*nn.Module*） - 模型的 nn.Module。

+   **optimizers**（*Union***[*Optimizer**,* *Iterable***[*Optimizer**]**]*) - 用于优化`model`的优化器。

+   **optim_state_dict** ([*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")*[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* [*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")*[*[*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")*[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* [*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* [*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python v3.12)")*[*[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*]**]**,* [*Tuple*](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.12)")*[*[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*]**]**,* [*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")*[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* [*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* [*List*](https://docs.python.org/3/library/typing.html#typing.List "(in Python v3.12)")*[*[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*]**]**,* [*Tuple*](https://docs.python.org/3/library/typing.html#typing.Tuple "(in Python v3.12)")*[*[*Union*](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.12)")***DTensor**,* *ShardedTensor**,* [*Tensor**,* [*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")*,* [*float*](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)")*,* [*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*]**]**,* [*Dict*](https://docs.python.org/3/library/typing.html#typing.Dict "(in Python v3.12)")*[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")*,* *ValueType**]**]**]**]**]*) – OptimizerStateType: the optimizer state_dict to load.

+   **options** (*StateDictOptions*) - 控制如何加载模型 state_dict 和优化器 state_dict 的选项。有关详细信息，请参阅 StateDictOptions。

返回

None

返回类型

None

```py
class torch.distributed.checkpoint.state_dict.StateDictOptions(full_state_dict=False, cpu_offload=False, ignore_frozen_params=False, keep_submodule_prefixes=True, strict=True)¶
```

此数据类指定了 get_state_dict/set_state_dict 的工作方式。

+   `full_state_dict`: 如果设置为 True，则返回的 state_dict 中的所有张量将被收集。返回的 state_dict 中不会有 ShardedTensor 和 DTensor。

+   `cpu_offload`: 将所有张量卸载到 CPU。为防止 CPU OOM，如果`full_state_dict`也为 true，则只有 rank0 会获取 state_dict，所有其他 rank 将获取空的 state_dict。

+   `ignore_frozen_params`: 如果值为 True，则返回的 state_dict 不会包含任何冻结参数 - `requires_grad`为 False。默认值为 False。

+   `keep_submodule_prefixes`: 当`submodules`不为 None 时，此选项指示是否保留 state_dict 键中的子模块前缀。例如，如果子模块是`module.pretrain`，参数的完整 FQN 是`pretrain.layer1.weight`。当此选项为 True 时，返回的 state_dict 中参数的键将是`pretrain.layer1.weight`。如果选项为 False，则键将是`layer1.weight`。请注意，如果`keep_submodule_prefixes`为 False，则可能存在冲突的 FQN，因此`submodules`中应该只有一个子模块。

+   `strict`: `set_state_dict` 调用 model.load_state_dict() 时的 `strict` 选项。默认值为 False。
