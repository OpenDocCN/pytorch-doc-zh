- en: Speech Recognition with Wav2Vec2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pytorch.org/audio/stable/tutorials/speech_recognition_pipeline_tutorial.html](https://pytorch.org/audio/stable/tutorials/speech_recognition_pipeline_tutorial.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Click [here](#sphx-glr-download-tutorials-speech-recognition-pipeline-tutorial-py)
    to download the full example code
  prefs: []
  type: TYPE_NORMAL
- en: '**Author**: [Moto Hira](mailto:moto%40meta.com)'
  prefs: []
  type: TYPE_NORMAL
- en: This tutorial shows how to perform speech recognition using using pre-trained
    models from wav2vec 2.0 [[paper](https://arxiv.org/abs/2006.11477)].
  prefs: []
  type: TYPE_NORMAL
- en: Overview[](#overview "Permalink to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process of speech recognition looks like the following.
  prefs: []
  type: TYPE_NORMAL
- en: Extract the acoustic features from audio waveform
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Estimate the class of the acoustic features frame-by-frame
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate hypothesis from the sequence of the class probabilities
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Torchaudio provides easy access to the pre-trained weights and associated information,
    such as the expected sample rate and class labels. They are bundled together and
    available under [`torchaudio.pipelines`](../pipelines.html#module-torchaudio.pipelines
    "torchaudio.pipelines") module.
  prefs: []
  type: TYPE_NORMAL
- en: Preparation[](#preparation "Permalink to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating a pipeline[](#creating-a-pipeline "Permalink to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we will create a Wav2Vec2 model that performs the feature extraction
    and the classification.
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of Wav2Vec2 pre-trained weights available in torchaudio.
    The ones fine-tuned for ASR task, and the ones not fine-tuned.
  prefs: []
  type: TYPE_NORMAL
- en: Wav2Vec2 (and HuBERT) models are trained in self-supervised manner. They are
    firstly trained with audio only for representation learning, then fine-tuned for
    a specific task with additional labels.
  prefs: []
  type: TYPE_NORMAL
- en: The pre-trained weights without fine-tuning can be fine-tuned for other downstream
    tasks as well, but this tutorial does not cover that.
  prefs: []
  type: TYPE_NORMAL
- en: We will use [`torchaudio.pipelines.WAV2VEC2_ASR_BASE_960H`](../generated/torchaudio.pipelines.WAV2VEC2_ASR_BASE_960H.html#torchaudio.pipelines.WAV2VEC2_ASR_BASE_960H
    "torchaudio.pipelines.WAV2VEC2_ASR_BASE_960H") here.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple pre-trained models available in [`torchaudio.pipelines`](../pipelines.html#module-torchaudio.pipelines
    "torchaudio.pipelines"). Please check the documentation for the detail of how
    they are trained.
  prefs: []
  type: TYPE_NORMAL
- en: The bundle object provides the interface to instantiate model and other information.
    Sampling rate and the class labels are found as follow.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Model can be constructed as following. This process will automatically fetch
    the pre-trained weights and load it into the model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Loading data[](#loading-data "Permalink to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the speech data from [VOiCES dataset](https://iqtlabs.github.io/voices/),
    which is licensed under Creative Commos BY 4.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Your browser does not support the audio element.
  prefs: []
  type: TYPE_NORMAL
- en: To load data, we use [`torchaudio.load()`](../generated/torchaudio.load.html#torchaudio.load
    "torchaudio.load").
  prefs: []
  type: TYPE_NORMAL
- en: If the sampling rate is different from what the pipeline expects, then we can
    use [`torchaudio.functional.resample()`](../generated/torchaudio.functional.resample.html#torchaudio.functional.resample
    "torchaudio.functional.resample") for resampling.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '[`torchaudio.functional.resample()`](../generated/torchaudio.functional.resample.html#torchaudio.functional.resample
    "torchaudio.functional.resample") works on CUDA tensors as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When performing resampling multiple times on the same set of sample rates, using
    [`torchaudio.transforms.Resample`](../generated/torchaudio.transforms.Resample.html#torchaudio.transforms.Resample
    "torchaudio.transforms.Resample") might improve the performace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Extracting acoustic features[](#extracting-acoustic-features "Permalink to
    this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to extract acoustic features from the audio.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Wav2Vec2 models fine-tuned for ASR task can perform feature extraction and classification
    with one step, but for the sake of the tutorial, we also show how to perform feature
    extraction here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The returned features is a list of tensors. Each tensor is the output of a transformer
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![Feature from transformer layer 1, Feature from transformer layer 2, Feature
    from transformer layer 3, Feature from transformer layer 4, Feature from transformer
    layer 5, Feature from transformer layer 6, Feature from transformer layer 7, Feature
    from transformer layer 8, Feature from transformer layer 9, Feature from transformer
    layer 10, Feature from transformer layer 11, Feature from transformer layer 12](../Images/9f2d3410922166561ebdadfd4981e797.png)'
  prefs: []
  type: TYPE_IMG
- en: Feature classification[](#feature-classification "Permalink to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the acoustic features are extracted, the next step is to classify them
    into a set of categories.
  prefs: []
  type: TYPE_NORMAL
- en: Wav2Vec2 model provides method to perform the feature extraction and classification
    in one step.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The output is in the form of logits. It is not in the form of probability.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s visualize this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![Classification result](../Images/ce8601d728900194dc8cb21fbd524cf7.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can see that there are strong indications to certain labels across the time
    line.
  prefs: []
  type: TYPE_NORMAL
- en: Generating transcripts[](#generating-transcripts "Permalink to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the sequence of label probabilities, now we want to generate transcripts.
    The process to generate hypotheses is often called “decoding”.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding is more elaborate than simple classification because decoding at certain
    time step can be affected by surrounding observations.
  prefs: []
  type: TYPE_NORMAL
- en: For example, take a word like `night` and `knight`. Even if their prior probability
    distribution are differnt (in typical conversations, `night` would occur way more
    often than `knight`), to accurately generate transcripts with `knight`, such as
    `a knight with a sword`, the decoding process has to postpone the final decision
    until it sees enough context.
  prefs: []
  type: TYPE_NORMAL
- en: There are many decoding techniques proposed, and they require external resources,
    such as word dictionary and language models.
  prefs: []
  type: TYPE_NORMAL
- en: In this tutorial, for the sake of simplicity, we will perform greedy decoding
    which does not depend on such external components, and simply pick up the best
    hypothesis at each time step. Therefore, the context information are not used,
    and only one transcript can be generated.
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining greedy decoding algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now create the decoder object and decode the transcript.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let’s check the result and listen again to the audio.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: Your browser does not support the audio element.
  prefs: []
  type: TYPE_NORMAL
- en: The ASR model is fine-tuned using a loss function called Connectionist Temporal
    Classification (CTC). The detail of CTC loss is explained [here](https://distill.pub/2017/ctc/).
    In CTC a blank token (ϵ) is a special token which represents a repetition of the
    previous symbol. In decoding, these are simply ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion[](#conclusion "Permalink to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this tutorial, we looked at how to use [`Wav2Vec2ASRBundle`](../generated/torchaudio.pipelines.Wav2Vec2ASRBundle.html#torchaudio.pipelines.Wav2Vec2ASRBundle
    "torchaudio.pipelines.Wav2Vec2ASRBundle") to perform acoustic feature extraction
    and speech recognition. Constructing a model and getting the emission is as short
    as two lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Total running time of the script:** ( 0 minutes 6.833 seconds)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Download Python source code: speech_recognition_pipeline_tutorial.py`](../_downloads/a0b5016bbf34fce4ac5549f4075dd10f/speech_recognition_pipeline_tutorial.py)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Download Jupyter notebook: speech_recognition_pipeline_tutorial.ipynb`](../_downloads/ca83af2ea8d7db05fb63211d515b7fde/speech_recognition_pipeline_tutorial.ipynb)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Gallery generated by Sphinx-Gallery](https://sphinx-gallery.github.io)'
  prefs: []
  type: TYPE_NORMAL
