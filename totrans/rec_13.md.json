["```py\nclass torchrec.sparse.jagged_tensor.ComputeJTDictToKJT(*args, **kwargs)\u00b6\n```", "```py\nforward(jt_dict: Dict[str, JaggedTensor]) \u2192 KeyedJaggedTensor\u00b6\n```", "```py\ntraining: bool\u00b6\n```", "```py\nclass torchrec.sparse.jagged_tensor.ComputeKJTToJTDict(*args, **kwargs)\u00b6\n```", "```py\nforward(keyed_jagged_tensor: KeyedJaggedTensor) \u2192 Dict[str, JaggedTensor]\u00b6\n```", "```py\ntraining: bool\u00b6\n```", "```py\nclass torchrec.sparse.jagged_tensor.JaggedTensor(*args, **kwargs)\u00b6\n```", "```py\nstatic empty(is_weighted: bool = False, device: Optional[device] = None, values_dtype: Optional[dtype] = None, weights_dtype: Optional[dtype] = None, lengths_dtype: dtype = torch.int32) \u2192 JaggedTensor\u00b6\n```", "```py\nstatic from_dense(values: List[Tensor], weights: Optional[List[Tensor]] = None) \u2192 JaggedTensor\u00b6\n```", "```py\nvalues = [\n    torch.Tensor([1.0]),\n    torch.Tensor(),\n    torch.Tensor([7.0, 8.0]),\n    torch.Tensor([10.0, 11.0, 12.0]),\n]\nweights = [\n    torch.Tensor([1.0]),\n    torch.Tensor(),\n    torch.Tensor([7.0, 8.0]),\n    torch.Tensor([10.0, 11.0, 12.0]),\n]\nj1 = JaggedTensor.from_dense(\n    values=values,\n    weights=weights,\n)\n\n# j1 = [[1.0], [], [7.0], [8.0], [10.0, 11.0, 12.0]] \n```", "```py\nstatic from_dense_lengths(values: Tensor, lengths: Tensor, weights: Optional[Tensor] = None) \u2192 JaggedTensor\u00b6\n```", "```py\nlengths() \u2192 Tensor\u00b6\n```", "```py\nlengths_or_none() \u2192 Optional[Tensor]\u00b6\n```", "```py\noffsets() \u2192 Tensor\u00b6\n```", "```py\noffsets_or_none() \u2192 Optional[Tensor]\u00b6\n```", "```py\nrecord_stream(stream: Stream) \u2192 None\u00b6\n```", "```py\nto(device: device, non_blocking: bool = False) \u2192 JaggedTensor\u00b6\n```", "```py\nto_dense() \u2192 List[Tensor]\u00b6\n```", "```py\nvalues = torch.Tensor([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0])\noffsets = torch.IntTensor([0, 2, 2, 3, 4, 5, 8])\njt = JaggedTensor(values=values, offsets=offsets)\n\nvalues_list = jt.to_dense()\n\n# values_list = [\n#     torch.tensor([1.0, 2.0]),\n#     torch.tensor([]),\n#     torch.tensor([3.0]),\n#     torch.tensor([4.0]),\n#     torch.tensor([5.0]),\n#     torch.tensor([6.0, 7.0, 8.0]),\n# ] \n```", "```py\nto_dense_weights() \u2192 Optional[List[Tensor]]\u00b6\n```", "```py\nvalues = torch.Tensor([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0])\nweights = torch.Tensor([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8])\noffsets = torch.IntTensor([0, 2, 2, 3, 4, 5, 8])\njt = JaggedTensor(values=values, weights=weights, offsets=offsets)\n\nweights_list = jt.to_dense_weights()\n\n# weights_list = [\n#     torch.tensor([0.1, 0.2]),\n#     torch.tensor([]),\n#     torch.tensor([0.3]),\n#     torch.tensor([0.4]),\n#     torch.tensor([0.5]),\n#     torch.tensor([0.6, 0.7, 0.8]),\n# ] \n```", "```py\nto_padded_dense(desired_length: Optional[int] = None, padding_value: float = 0.0) \u2192 Tensor\u00b6\n```", "```py\nvalues = torch.Tensor([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0])\noffsets = torch.IntTensor([0, 2, 2, 3, 4, 5, 8])\njt = JaggedTensor(values=values, offsets=offsets)\n\ndt = jt.to_padded_dense(\n    desired_length=2,\n    padding_value=10.0,\n)\n\n# dt = [\n#     [1.0, 2.0],\n#     [10.0, 10.0],\n#     [3.0, 10.0],\n#     [4.0, 10.0],\n#     [5.0, 10.0],\n#     [6.0, 7.0],\n# ] \n```", "```py\nto_padded_dense_weights(desired_length: Optional[int] = None, padding_value: float = 0.0) \u2192 Optional[Tensor]\u00b6\n```", "```py\nvalues = torch.Tensor([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0])\nweights = torch.Tensor([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8])\noffsets = torch.IntTensor([0, 2, 2, 3, 4, 5, 8])\njt = JaggedTensor(values=values, weights=weights, offsets=offsets)\n\nd_wt = jt.to_padded_dense_weights(\n    desired_length=2,\n    padding_value=1.0,\n)\n\n# d_wt = [\n#     [0.1, 0.2],\n#     [1.0, 1.0],\n#     [0.3, 1.0],\n#     [0.4, 1.0],\n#     [0.5, 1.0],\n#     [0.6, 0.7],\n# ] \n```", "```py\nvalues() \u2192 Tensor\u00b6\n```", "```py\nweights() \u2192 Tensor\u00b6\n```", "```py\nweights_or_none() \u2192 Optional[Tensor]\u00b6\n```", "```py\nclass torchrec.sparse.jagged_tensor.JaggedTensorMeta(name, bases, namespace, **kwargs)\u00b6\n```", "```py\nclass torchrec.sparse.jagged_tensor.KeyedJaggedTensor(*args, **kwargs)\u00b6\n```", "```py\n#              0       1        2  <-- dim_1\n# \"Feature0\"   [V0,V1] None    [V2]\n# \"Feature1\"   [V3]    [V4]    [V5,V6,V7]\n#   ^\n#  dim_0\n\ndim_0: keyed dimension (ie. `Feature0`, `Feature1`)\ndim_1: optional second dimension (ie. batch size)\ndim_2: The jagged dimension which has slice lengths between 0-3 in the above example\n\n# We represent this data with following inputs:\n\nvalues: torch.Tensor = [V0, V1, V2, V3, V4, V5, V6, V7]  # V == any tensor datatype\nweights: torch.Tensor = [W0, W1, W2, W3, W4, W5, W6, W7]  # W == any tensor datatype\nlengths: torch.Tensor = [2, 0, 1, 1, 1, 3]  # representing the jagged slice\noffsets: torch.Tensor = [0, 2, 2, 3, 4, 5, 8]  # offsets from 0 for each jagged slice\nkeys: List[str] = [\"Feature0\", \"Feature1\"]  # correspond to each value of dim_0\nindex_per_key: Dict[str, int] = {\"Feature0\": 0, \"Feature1\": 1}  # index for each key\noffset_per_key: List[int] = [0, 3, 8]  # start offset for each key and final offset \n```", "```py\nstatic concat(kjt_list: List[KeyedJaggedTensor]) \u2192 KeyedJaggedTensor\u00b6\n```", "```py\ndevice() \u2192 device\u00b6\n```", "```py\nstatic dist_init(keys: List[str], tensors: List[Tensor], variable_stride_per_key: bool, num_workers: int, recat: Optional[Tensor], stride_per_rank: Optional[List[int]], stagger: int = 1) \u2192 KeyedJaggedTensor\u00b6\n```", "```py\ndist_labels() \u2192 List[str]\u00b6\n```", "```py\ndist_splits(key_splits: List[int]) \u2192 List[List[int]]\u00b6\n```", "```py\ndist_tensors() \u2192 List[Tensor]\u00b6\n```", "```py\nstatic empty(is_weighted: bool = False, device: Optional[device] = None, values_dtype: Optional[dtype] = None, weights_dtype: Optional[dtype] = None, lengths_dtype: dtype = torch.int32) \u2192 KeyedJaggedTensor\u00b6\n```", "```py\nstatic empty_like(kjt: KeyedJaggedTensor) \u2192 KeyedJaggedTensor\u00b6\n```", "```py\nflatten_lengths() \u2192 KeyedJaggedTensor\u00b6\n```", "```py\nstatic from_jt_dict(jt_dict: Dict[str, JaggedTensor]) \u2192 KeyedJaggedTensor\u00b6\n```", "```py\nstatic from_lengths_sync(keys: List[str], values: Tensor, lengths: Tensor, weights: Optional[Tensor] = None, stride: Optional[int] = None, stride_per_key_per_rank: Optional[List[List[int]]] = None, inverse_indices: Optional[Tuple[List[str], Tensor]] = None) \u2192 KeyedJaggedTensor\u00b6\n```", "```py\nstatic from_offsets_sync(keys: List[str], values: Tensor, offsets: Tensor, weights: Optional[Tensor] = None, stride: Optional[int] = None, stride_per_key_per_rank: Optional[List[List[int]]] = None, inverse_indices: Optional[Tuple[List[str], Tensor]] = None) \u2192 KeyedJaggedTensor\u00b6\n```", "```py\ninverse_indices() \u2192 Tuple[List[str], Tensor]\u00b6\n```", "```py\ninverse_indices_or_none() \u2192 Optional[Tuple[List[str], Tensor]]\u00b6\n```", "```py\nkeys() \u2192 List[str]\u00b6\n```", "```py\nlength_per_key() \u2192 List[int]\u00b6\n```", "```py\nlength_per_key_or_none() \u2192 Optional[List[int]]\u00b6\n```", "```py\nlengths() \u2192 Tensor\u00b6\n```", "```py\nlengths_offset_per_key() \u2192 List[int]\u00b6\n```", "```py\nlengths_or_none() \u2192 Optional[Tensor]\u00b6\n```", "```py\noffset_per_key() \u2192 List[int]\u00b6\n```", "```py\noffset_per_key_or_none() \u2192 Optional[List[int]]\u00b6\n```", "```py\noffsets() \u2192 Tensor\u00b6\n```", "```py\noffsets_or_none() \u2192 Optional[Tensor]\u00b6\n```", "```py\npermute(indices: List[int], indices_tensor: Optional[Tensor] = None) \u2192 KeyedJaggedTensor\u00b6\n```", "```py\npin_memory() \u2192 KeyedJaggedTensor\u00b6\n```", "```py\nrecord_stream(stream: Stream) \u2192 None\u00b6\n```", "```py\nsplit(segments: List[int]) \u2192 List[KeyedJaggedTensor]\u00b6\n```", "```py\nstride() \u2192 int\u00b6\n```", "```py\nstride_per_key() \u2192 List[int]\u00b6\n```", "```py\nstride_per_key_per_rank() \u2192 List[List[int]]\u00b6\n```", "```py\nsync() \u2192 KeyedJaggedTensor\u00b6\n```", "```py\nto(device: device, non_blocking: bool = False, dtype: Optional[dtype] = None) \u2192 KeyedJaggedTensor\u00b6\n```", "```py\nto_dict() \u2192 Dict[str, JaggedTensor]\u00b6\n```", "```py\nunsync() \u2192 KeyedJaggedTensor\u00b6\n```", "```py\nvalues() \u2192 Tensor\u00b6\n```", "```py\nvariable_stride_per_key() \u2192 bool\u00b6\n```", "```py\nweights() \u2192 Tensor\u00b6\n```", "```py\nweights_or_none() \u2192 Optional[Tensor]\u00b6\n```", "```py\nclass torchrec.sparse.jagged_tensor.KeyedTensor(*args, **kwargs)\u00b6\n```", "```py\n# kt is KeyedTensor holding\n\n#                         0           1           2\n#     \"Embedding A\"    [1,1]       [1,1]        [1,1]\n#     \"Embedding B\"    [2,1,2]     [2,1,2]      [2,1,2]\n#     \"Embedding C\"    [3,1,2,3]   [3,1,2,3]    [3,1,2,3]\n\ntensor_list = [\n    torch.tensor([[1,1]] * 3),\n    torch.tensor([[2,1,2]] * 3),\n    torch.tensor([[3,1,2,3]] * 3),\n]\n\nkeys = [\"Embedding A\", \"Embedding B\", \"Embedding C\"]\n\nkt = KeyedTensor.from_tensor_list(keys, tensor_list)\n\nkt.values()\n    # tensor(\n    #     [\n    #         [1, 1, 2, 1, 2, 3, 1, 2, 3],\n    #         [1, 1, 2, 1, 2, 3, 1, 2, 3],\n    #         [1, 1, 2, 1, 2, 3, 1, 2, 3],\n    #     ]\n    # )\n\nkt[\"Embedding B\"]\n    # tensor([[2, 1, 2], [2, 1, 2], [2, 1, 2]]) \n```", "```py\nstatic from_tensor_list(keys: List[str], tensors: List[Tensor], key_dim: int = 1, cat_dim: int = 1) \u2192 KeyedTensor\u00b6\n```", "```py\nkey_dim() \u2192 int\u00b6\n```", "```py\nkeys() \u2192 List[str]\u00b6\n```", "```py\nlength_per_key() \u2192 List[int]\u00b6\n```", "```py\noffset_per_key() \u2192 List[int]\u00b6\n```", "```py\nrecord_stream(stream: Stream) \u2192 None\u00b6\n```", "```py\nstatic regroup(keyed_tensors: List[KeyedTensor], groups: List[List[str]]) \u2192 List[Tensor]\u00b6\n```", "```py\nstatic regroup_as_dict(keyed_tensors: List[KeyedTensor], groups: List[List[str]], keys: List[str]) \u2192 Dict[str, Tensor]\u00b6\n```", "```py\nto(device: device, non_blocking: bool = False) \u2192 KeyedTensor\u00b6\n```", "```py\nto_dict() \u2192 Dict[str, Tensor]\u00b6\n```", "```py\nvalues() \u2192 Tensor\u00b6\n```", "```py\ntorchrec.sparse.jagged_tensor.jt_is_equal(jt_1: JaggedTensor, jt_2: JaggedTensor) \u2192 bool\u00b6\n```", "```py\ntorchrec.sparse.jagged_tensor.kjt_is_equal(kjt_1: KeyedJaggedTensor, kjt_2: KeyedJaggedTensor) \u2192 bool\u00b6\n```"]