["```py\n>  python  sample.py  Russian  RUS\nRovakov\nUantov\nShavakov\n\n>  python  sample.py  German  GER\nGerren\nEreng\nRosher\n\n>  python  sample.py  Spanish  SPA\nSalla\nParer\nAllan\n\n>  python  sample.py  Chinese  CHI\nChan\nHang\nIun \n```", "```py\nfrom io import open\nimport glob\nimport os\nimport unicodedata\nimport string\n\nall_letters = string.ascii_letters + \" .,;'-\"\nn_letters = len(all_letters) + 1 # Plus EOS marker\n\ndef findFiles(path): return glob.glob(path)\n\n# Turn a Unicode string to plain ASCII, thanks to https://stackoverflow.com/a/518232/2809427\ndef unicodeToAscii(s):\n    return ''.join(\n        c for c in unicodedata.normalize('NFD', s)\n        if unicodedata.category(c) != 'Mn'\n        and c in all_letters\n    )\n\n# Read a file and split into lines\ndef readLines(filename):\n    with open(filename, encoding='utf-8') as some_file:\n        return [unicodeToAscii(line.strip()) for line in some_file]\n\n# Build the category_lines dictionary, a list of lines per category\ncategory_lines = {}\nall_categories = []\nfor filename in findFiles('data/names/*.txt'):\n    category = os.path.splitext(os.path.basename(filename))[0]\n    all_categories.append(category)\n    lines = readLines(filename)\n    category_lines[category] = lines\n\nn_categories = len(all_categories)\n\nif n_categories == 0:\n    raise RuntimeError('Data not found. Make sure that you downloaded data '\n        'from https://download.pytorch.org/tutorial/data.zip and extract it to '\n        'the current directory.')\n\nprint('# categories:', n_categories, all_categories)\nprint(unicodeToAscii(\"O'N\u00e9\u00e0l\")) \n```", "```py\n# categories: 18 ['Arabic', 'Chinese', 'Czech', 'Dutch', 'English', 'French', 'German', 'Greek', 'Irish', 'Italian', 'Japanese', 'Korean', 'Polish', 'Portuguese', 'Russian', 'Scottish', 'Spanish', 'Vietnamese']\nO'Neal \n```", "```py\nimport torch\nimport torch.nn as nn\n\nclass RNN([nn.Module](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module \"torch.nn.Module\")):\n    def __init__(self, input_size, hidden_size, output_size):\n        super([RNN](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module \"torch.nn.Module\"), self).__init__()\n        self.hidden_size = hidden_size\n\n        self.i2h = [nn.Linear](https://pytorch.org/docs/stable/generated/torch.nn.Linear.html#torch.nn.Linear \"torch.nn.Linear\")(n_categories + input_size + hidden_size, hidden_size)\n        self.i2o = [nn.Linear](https://pytorch.org/docs/stable/generated/torch.nn.Linear.html#torch.nn.Linear \"torch.nn.Linear\")(n_categories + input_size + hidden_size, output_size)\n        self.o2o = [nn.Linear](https://pytorch.org/docs/stable/generated/torch.nn.Linear.html#torch.nn.Linear \"torch.nn.Linear\")(hidden_size + output_size, output_size)\n        self.dropout = [nn.Dropout](https://pytorch.org/docs/stable/generated/torch.nn.Dropout.html#torch.nn.Dropout \"torch.nn.Dropout\")(0.1)\n        self.softmax = [nn.LogSoftmax](https://pytorch.org/docs/stable/generated/torch.nn.LogSoftmax.html#torch.nn.LogSoftmax \"torch.nn.LogSoftmax\")(dim=1)\n\n    def forward(self, category, input, hidden):\n        input_combined = [torch.cat](https://pytorch.org/docs/stable/generated/torch.cat.html#torch.cat \"torch.cat\")((category, input, hidden), 1)\n        hidden = self.i2h(input_combined)\n        [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = self.i2o(input_combined)\n        output_combined = [torch.cat](https://pytorch.org/docs/stable/generated/torch.cat.html#torch.cat \"torch.cat\")((hidden, [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")), 1)\n        [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = self.o2o(output_combined)\n        [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = self.dropout([output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"))\n        [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = self.softmax([output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"))\n        return [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), hidden\n\n    def initHidden(self):\n        return [torch.zeros](https://pytorch.org/docs/stable/generated/torch.zeros.html#torch.zeros \"torch.zeros\")(1, self.hidden_size) \n```", "```py\nimport random\n\n# Random item from a list\ndef randomChoice(l):\n    return l[random.randint(0, len(l) - 1)]\n\n# Get a random category and random line from that category\ndef randomTrainingPair():\n    category = randomChoice(all_categories)\n    line = randomChoice(category_lines[category])\n    return category, line \n```", "```py\n# One-hot vector for category\ndef categoryTensor(category):\n    li = all_categories.index(category)\n    tensor = [torch.zeros](https://pytorch.org/docs/stable/generated/torch.zeros.html#torch.zeros \"torch.zeros\")(1, n_categories)\n    tensor[0][li] = 1\n    return tensor\n\n# One-hot matrix of first to last letters (not including EOS) for input\ndef inputTensor(line):\n    tensor = [torch.zeros](https://pytorch.org/docs/stable/generated/torch.zeros.html#torch.zeros \"torch.zeros\")(len(line), 1, n_letters)\n    for li in range(len(line)):\n        letter = line[li]\n        tensor[li][0][all_letters.find(letter)] = 1\n    return tensor\n\n# ``LongTensor`` of second letter to end (EOS) for target\ndef targetTensor(line):\n    letter_indexes = [all_letters.find(line[li]) for li in range(1, len(line))]\n    letter_indexes.append(n_letters - 1) # EOS\n    return torch.LongTensor(letter_indexes) \n```", "```py\n# Make category, input, and target tensors from a random category, line pair\ndef randomTrainingExample():\n    category, line = randomTrainingPair()\n    category_tensor = categoryTensor(category)\n    input_line_tensor = inputTensor(line)\n    target_line_tensor = targetTensor(line)\n    return category_tensor, input_line_tensor, target_line_tensor \n```", "```py\n[criterion](https://pytorch.org/docs/stable/generated/torch.nn.NLLLoss.html#torch.nn.NLLLoss \"torch.nn.NLLLoss\") = [nn.NLLLoss](https://pytorch.org/docs/stable/generated/torch.nn.NLLLoss.html#torch.nn.NLLLoss \"torch.nn.NLLLoss\")()\n\nlearning_rate = 0.0005\n\ndef train(category_tensor, input_line_tensor, target_line_tensor):\n    target_line_tensor.unsqueeze_(-1)\n    hidden = rnn.initHidden()\n\n    [rnn.zero_grad](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module.zero_grad \"torch.nn.Module.zero_grad\")()\n\n    loss = [torch.Tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")([0]) # you can also just simply use ``loss = 0``\n\n    for i in range(input_line_tensor.size(0)):\n        [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), hidden = rnn(category_tensor, input_line_tensor[i], hidden)\n        l = [criterion](https://pytorch.org/docs/stable/generated/torch.nn.NLLLoss.html#torch.nn.NLLLoss \"torch.nn.NLLLoss\")([output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), target_line_tensor[i])\n        loss += l\n\n    loss.backward()\n\n    for p in [rnn.parameters](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module.parameters \"torch.nn.Module.parameters\")():\n        p.data.add_(p.grad.data, alpha=-learning_rate)\n\n    return [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), loss.item() / input_line_tensor.size(0) \n```", "```py\nimport time\nimport math\n\ndef timeSince(since):\n    now = time.time()\n    s = now - since\n    m = math.floor(s / 60)\n    s -= m * 60\n    return '%dm %ds' % (m, s) \n```", "```py\nrnn = [RNN](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module \"torch.nn.Module\")(n_letters, 128, n_letters)\n\nn_iters = 100000\nprint_every = 5000\nplot_every = 500\nall_losses = []\ntotal_loss = 0 # Reset every ``plot_every`` ``iters``\n\nstart = time.time()\n\nfor iter in range(1, n_iters + 1):\n    [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), loss = train(*randomTrainingExample())\n    total_loss += loss\n\n    if iter % print_every == 0:\n        print('%s (%d  %d%%) %.4f' % (timeSince(start), iter, iter / n_iters * 100, loss))\n\n    if iter % plot_every == 0:\n        all_losses.append(total_loss / plot_every)\n        total_loss = 0 \n```", "```py\n0m 9s (5000 5%) 3.1506\n0m 18s (10000 10%) 2.5070\n0m 28s (15000 15%) 3.3047\n0m 37s (20000 20%) 2.4247\n0m 47s (25000 25%) 2.6406\n0m 56s (30000 30%) 2.0266\n1m 5s (35000 35%) 2.6520\n1m 15s (40000 40%) 2.4261\n1m 24s (45000 45%) 2.2302\n1m 33s (50000 50%) 1.6496\n1m 43s (55000 55%) 2.7101\n1m 52s (60000 60%) 2.5396\n2m 1s (65000 65%) 2.5978\n2m 11s (70000 70%) 1.6029\n2m 20s (75000 75%) 0.9634\n2m 29s (80000 80%) 3.0950\n2m 39s (85000 85%) 2.0512\n2m 48s (90000 90%) 2.5302\n2m 57s (95000 95%) 3.2365\n3m 7s (100000 100%) 1.7113 \n```", "```py\nimport matplotlib.pyplot as plt\n\nplt.figure()\nplt.plot(all_losses) \n```", "```py\n[<matplotlib.lines.Line2D object at 0x7fcf36ff04c0>] \n```", "```py\nmax_length = 20\n\n# Sample from a category and starting letter\ndef sample(category, start_letter='A'):\n    with [torch.no_grad](https://pytorch.org/docs/stable/generated/torch.no_grad.html#torch.no_grad \"torch.no_grad\")():  # no need to track history in sampling\n        category_tensor = categoryTensor(category)\n        input = inputTensor(start_letter)\n        hidden = rnn.initHidden()\n\n        output_name = start_letter\n\n        for i in range(max_length):\n            [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), hidden = rnn(category_tensor, input[0], hidden)\n            topv, topi = [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\").topk(1)\n            topi = topi[0][0]\n            if topi == n_letters - 1:\n                break\n            else:\n                letter = all_letters[topi]\n                output_name += letter\n            input = inputTensor(letter)\n\n        return output_name\n\n# Get multiple samples from one category and multiple starting letters\ndef samples(category, start_letters='ABC'):\n    for start_letter in start_letters:\n        print(sample(category, start_letter))\n\nsamples('Russian', 'RUS')\n\nsamples('German', 'GER')\n\nsamples('Spanish', 'SPA')\n\nsamples('Chinese', 'CHI') \n```", "```py\nRovaki\nUarinovev\nShinan\nGerter\nEeren\nRoune\nSantera\nPaneraz\nAllan\nChin\nHan\nIon \n```"]