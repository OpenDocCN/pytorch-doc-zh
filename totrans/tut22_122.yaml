- en: Distributed Pipeline Parallelism Using RPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pytorch.org/tutorials/intermediate/dist_pipeline_parallel_tutorial.html](https://pytorch.org/tutorials/intermediate/dist_pipeline_parallel_tutorial.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Author**: [Shen Li](https://mrshenli.github.io/)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '![edit](../Images/a8aa37bcc5edbf2ba5fcf18dba1e55f9.png)
    View and edit this tutorial in [github](https://github.com/pytorch/tutorials/blob/main/intermediate_source/dist_pipeline_parallel_tutorial.rst).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PyTorch Distributed Overview](../beginner/dist_overview.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Single-Machine Model Parallel Best Practices](https://pytorch.org/tutorials/intermediate/model_parallel_tutorial.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Getting started with Distributed RPC Framework](https://pytorch.org/tutorials/intermediate/rpc_tutorial.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RRef helper functions: [RRef.rpc_sync()](https://pytorch.org/docs/master/rpc.html#torch.distributed.rpc.RRef.rpc_sync),
    [RRef.rpc_async()](https://pytorch.org/docs/master/rpc.html#torch.distributed.rpc.RRef.rpc_async),
    and [RRef.remote()](https://pytorch.org/docs/master/rpc.html#torch.distributed.rpc.RRef.remote)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This tutorial uses a Resnet50 model to demonstrate implementing distributed
    pipeline parallelism with [torch.distributed.rpc](https://pytorch.org/docs/master/rpc.html)
    APIs. This can be viewed as the distributed counterpart of the multi-GPU pipeline
    parallelism discussed in [Single-Machine Model Parallel Best Practices](model_parallel_tutorial.html).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This tutorial requires PyTorch v1.6.0 or above.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Full source code of this tutorial can be found at [pytorch/examples](https://github.com/pytorch/examples/tree/master/distributed/rpc/pipeline).
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous tutorial, [Getting Started with Distributed RPC Framework](rpc_tutorial.html)
    shows how to use [torch.distributed.rpc](https://pytorch.org/docs/master/rpc.html)
    to implement distributed model parallelism for an RNN model. That tutorial uses
    one GPU to host the `EmbeddingTable`, and the provided code works fine. However,
    if a model lives on multiple GPUs, it would require some extra steps to increase
    the amortized utilization of all GPUs. Pipeline parallelism is one type of paradigm
    that can help in this case.
  prefs: []
  type: TYPE_NORMAL
- en: In this tutorial, we use `ResNet50` as an example model which is also used by
    the [Single-Machine Model Parallel Best Practices](model_parallel_tutorial.html)
    tutorial. Similarly, the `ResNet50` model is divided into two shards and the input
    batch is partitioned into multiple splits and fed into the two model shards in
    a pipelined fashion. The difference is that, instead of parallelizing the execution
    using CUDA streams, this tutorial invokes asynchronous RPCs. So, the solution
    presented in this tutorial also works across machine boundaries. The remainder
    of this tutorial presents the implementation in four steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Partition ResNet50 Model'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the preparation step which implements `ResNet50` in two model shards.
    The code below is borrowed from the [ResNet implementation in torchvision](https://github.com/pytorch/vision/blob/7c077f6a986f05383bcb86b535aedb5a63dd5c4b/torchvision/models/resnet.py#L124).
    The `ResNetBase` module contains the common building blocks and attributes for
    the two ResNet shards.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready to define the two model shards. For the constructor, we simply
    split all ResNet50 layers into two parts and move each part into the provided
    device. The `forward` functions of both shards take an `RRef` of the input data,
    fetch the data locally, and then move it to the expected device. After applying
    all layers to the input, it moves the output to CPU and returns. It is because
    the RPC API requires tensors to reside on CPU to avoid invalid device errors when
    the numbers of devices in the caller and the callee do not match.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 2: Stitch ResNet50 Model Shards Into One Module'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Then, we create a `DistResNet50` module to assemble the two shards and implement
    the pipeline parallel logic. In the constructor, we use two `rpc.remote` calls
    to put the two shards on two different RPC workers respectively and hold on to
    the `RRef` to the two model parts so that they can be referenced in the forward
    pass. The `forward` function splits the input batch into multiple micro-batches,
    and feeds these micro-batches to the two model parts in a pipelined fashion. It
    first uses an `rpc.remote` call to apply the first shard to a micro-batch and
    then forwards the returned intermediate output `RRef` to the second model shard.
    After that, it collects the `Future` of all micro-outputs, and waits for all of
    them after the loop. Note that both `remote()` and `rpc_async()` return immediately
    and run asynchronously. Therefore, the entire loop is non-blocking, and will launch
    multiple RPCs concurrently. The execution order of one micro-batch on two model
    parts are preserved by intermediate output `y_rref`. The execution order across
    micro-batches does not matter. In the end, the forward function concatenates outputs
    of all micro-batches into one single output tensor and returns. The `parameter_rrefs`
    function is a helper to simplify distributed optimizer construction, which will
    be used later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 3: Define The Training Loop'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After defining the model, let us implement the training loop. We use a dedicated
    “master” worker to prepare random inputs and labels, and control the distributed
    backward pass and distributed optimizer step. It first creates an instance of
    the `DistResNet50` module. It specifies the number of micro-batches for each batch,
    and also provides the name of the two RPC workers (i.e., “worker1”, and “worker2”).
    Then it defines the loss function and creates a `DistributedOptimizer` using the
    `parameter_rrefs()` helper to acquire a list of parameter `RRefs`. Then, the main
    training loop is very similar to regular local training, except that it uses `dist_autograd`
    to launch backward and provides the `context_id` for both backward and optimizer
    `step()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 4: Launch RPC Processes'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, the code below shows the target function for all processes. The main
    logic is defined in `run_master`. The workers passively waiting for commands from
    the master, and hence simply runs `init_rpc` and `shutdown`, where the `shutdown`
    by default will block until all RPC participants finish.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
