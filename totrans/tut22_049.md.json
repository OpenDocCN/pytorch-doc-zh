["```py\n$  python  predict.py  Hinton\n(-0.47)  Scottish\n(-1.52)  English\n(-3.57)  Irish\n\n$  python  predict.py  Schmidhuber\n(-0.19)  German\n(-2.48)  Czech\n(-2.68)  Dutch \n```", "```py\nfrom io import open\nimport glob\nimport os\n\ndef findFiles(path): return glob.glob(path)\n\nprint(findFiles('data/names/*.txt'))\n\nimport unicodedata\nimport string\n\nall_letters = string.ascii_letters + \" .,;'\"\nn_letters = len(all_letters)\n\n# Turn a Unicode string to plain ASCII, thanks to https://stackoverflow.com/a/518232/2809427\ndef unicodeToAscii(s):\n    return ''.join(\n        c for c in unicodedata.normalize('NFD', s)\n        if unicodedata.category(c) != 'Mn'\n        and c in all_letters\n    )\n\nprint(unicodeToAscii('\u015alus\u00e0rski'))\n\n# Build the category_lines dictionary, a list of names per language\ncategory_lines = {}\nall_categories = []\n\n# Read a file and split into lines\ndef readLines(filename):\n    lines = open(filename, encoding='utf-8').read().strip().split('\\n')\n    return [unicodeToAscii(line) for line in lines]\n\nfor filename in findFiles('data/names/*.txt'):\n    category = os.path.splitext(os.path.basename(filename))[0]\n    all_categories.append(category)\n    lines = readLines(filename)\n    category_lines[category] = lines\n\nn_categories = len(all_categories) \n```", "```py\n['data/names/Arabic.txt', 'data/names/Chinese.txt', 'data/names/Czech.txt', 'data/names/Dutch.txt', 'data/names/English.txt', 'data/names/French.txt', 'data/names/German.txt', 'data/names/Greek.txt', 'data/names/Irish.txt', 'data/names/Italian.txt', 'data/names/Japanese.txt', 'data/names/Korean.txt', 'data/names/Polish.txt', 'data/names/Portuguese.txt', 'data/names/Russian.txt', 'data/names/Scottish.txt', 'data/names/Spanish.txt', 'data/names/Vietnamese.txt']\nSlusarski \n```", "```py\nprint(category_lines['Italian'][:5]) \n```", "```py\n['Abandonato', 'Abatangelo', 'Abatantuono', 'Abate', 'Abategiovanni'] \n```", "```py\nimport torch\n\n# Find letter index from all_letters, e.g. \"a\" = 0\ndef letterToIndex(letter):\n    return all_letters.find(letter)\n\n# Just for demonstration, turn a letter into a <1 x n_letters> Tensor\ndef letterToTensor(letter):\n    tensor = [torch.zeros](https://pytorch.org/docs/stable/generated/torch.zeros.html#torch.zeros \"torch.zeros\")(1, n_letters)\n    tensor[0][letterToIndex(letter)] = 1\n    return tensor\n\n# Turn a line into a <line_length x 1 x n_letters>,\n# or an array of one-hot letter vectors\ndef lineToTensor(line):\n    tensor = [torch.zeros](https://pytorch.org/docs/stable/generated/torch.zeros.html#torch.zeros \"torch.zeros\")(len(line), 1, n_letters)\n    for li, letter in enumerate(line):\n        tensor[li][0][letterToIndex(letter)] = 1\n    return tensor\n\nprint(letterToTensor('J'))\n\nprint(lineToTensor('Jones').size()) \n```", "```py\ntensor([[0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.,\n         0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n         0., 0., 0.]])\ntorch.Size([5, 1, 57]) \n```", "```py\nimport torch.nn as nn\n\nclass RNN([nn.Module](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module \"torch.nn.Module\")):\n    def __init__(self, input_size, hidden_size, output_size):\n        super([RNN](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module \"torch.nn.Module\"), self).__init__()\n\n        self.hidden_size = hidden_size\n\n        self.i2h = [nn.Linear](https://pytorch.org/docs/stable/generated/torch.nn.Linear.html#torch.nn.Linear \"torch.nn.Linear\")(input_size + hidden_size, hidden_size)\n        self.h2o = [nn.Linear](https://pytorch.org/docs/stable/generated/torch.nn.Linear.html#torch.nn.Linear \"torch.nn.Linear\")(hidden_size, output_size)\n        self.softmax = [nn.LogSoftmax](https://pytorch.org/docs/stable/generated/torch.nn.LogSoftmax.html#torch.nn.LogSoftmax \"torch.nn.LogSoftmax\")(dim=1)\n\n    def forward(self, input, [hidden](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")):\n        combined = [torch.cat](https://pytorch.org/docs/stable/generated/torch.cat.html#torch.cat \"torch.cat\")((input, [hidden](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")), 1)\n        [hidden](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = self.i2h(combined)\n        [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = self.h2o([hidden](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"))\n        [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = self.softmax([output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"))\n        return [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [hidden](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")\n\n    def initHidden(self):\n        return [torch.zeros](https://pytorch.org/docs/stable/generated/torch.zeros.html#torch.zeros \"torch.zeros\")(1, self.hidden_size)\n\nn_hidden = 128\nrnn = [RNN](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module \"torch.nn.Module\")(n_letters, n_hidden, n_categories) \n```", "```py\ninput = letterToTensor('A')\n[hidden](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = [torch.zeros](https://pytorch.org/docs/stable/generated/torch.zeros.html#torch.zeros \"torch.zeros\")(1, n_hidden)\n\n[output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [next_hidden](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = rnn(input, [hidden](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")) \n```", "```py\ninput = lineToTensor('Albert')\n[hidden](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = [torch.zeros](https://pytorch.org/docs/stable/generated/torch.zeros.html#torch.zeros \"torch.zeros\")(1, n_hidden)\n\n[output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [next_hidden](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = rnn(input[0], [hidden](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"))\nprint([output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")) \n```", "```py\ntensor([[-2.9083, -2.9270, -2.9167, -2.9590, -2.9108, -2.8332, -2.8906, -2.8325,\n         -2.8521, -2.9279, -2.8452, -2.8754, -2.8565, -2.9733, -2.9201, -2.8233,\n         -2.9298, -2.8624]], grad_fn=<LogSoftmaxBackward0>) \n```", "```py\ndef categoryFromOutput([output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")):\n    top_n, top_i = [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\").topk(1)\n    category_i = top_i[0].item()\n    return all_categories[category_i], category_i\n\nprint(categoryFromOutput([output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"))) \n```", "```py\n('Scottish', 15) \n```", "```py\nimport random\n\ndef randomChoice(l):\n    return l[random.randint(0, len(l) - 1)]\n\ndef randomTrainingExample():\n    category = randomChoice(all_categories)\n    line = randomChoice(category_lines[category])\n    [category_tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = [torch.tensor](https://pytorch.org/docs/stable/generated/torch.tensor.html#torch.tensor \"torch.tensor\")([all_categories.index(category)], dtype=[torch.long](https://pytorch.org/docs/stable/tensor_attributes.html#torch.dtype \"torch.dtype\"))\n    [line_tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = lineToTensor(line)\n    return category, line, [category_tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [line_tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")\n\nfor i in range(10):\n    category, line, [category_tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [line_tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = randomTrainingExample()\n    print('category =', category, '/ line =', line) \n```", "```py\ncategory = Chinese / line = Hou\ncategory = Scottish / line = Mckay\ncategory = Arabic / line = Cham\ncategory = Russian / line = V'Yurkov\ncategory = Irish / line = O'Keeffe\ncategory = French / line = Belrose\ncategory = Spanish / line = Silva\ncategory = Japanese / line = Fuchida\ncategory = Greek / line = Tsahalis\ncategory = Korean / line = Chang \n```", "```py\n[criterion](https://pytorch.org/docs/stable/generated/torch.nn.NLLLoss.html#torch.nn.NLLLoss \"torch.nn.NLLLoss\") = [nn.NLLLoss](https://pytorch.org/docs/stable/generated/torch.nn.NLLLoss.html#torch.nn.NLLLoss \"torch.nn.NLLLoss\")() \n```", "```py\nlearning_rate = 0.005 # If you set this too high, it might explode. If too low, it might not learn\n\ndef train([category_tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [line_tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")):\n    [hidden](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = rnn.initHidden()\n\n    [rnn.zero_grad](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module.zero_grad \"torch.nn.Module.zero_grad\")()\n\n    for i in range([line_tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\").size()[0]):\n        [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [hidden](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = rnn([line_tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")[i], [hidden](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"))\n\n    loss = [criterion](https://pytorch.org/docs/stable/generated/torch.nn.NLLLoss.html#torch.nn.NLLLoss \"torch.nn.NLLLoss\")([output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [category_tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"))\n    loss.backward()\n\n    # Add parameters' gradients to their values, multiplied by learning rate\n    for p in [rnn.parameters](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module.parameters \"torch.nn.Module.parameters\")():\n        p.data.add_(p.grad.data, alpha=-learning_rate)\n\n    return [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), loss.item() \n```", "```py\nimport time\nimport math\n\nn_iters = 100000\nprint_every = 5000\nplot_every = 1000\n\n# Keep track of losses for plotting\ncurrent_loss = 0\nall_losses = []\n\ndef timeSince(since):\n    now = time.time()\n    s = now - since\n    m = math.floor(s / 60)\n    s -= m * 60\n    return '%dm %ds' % (m, s)\n\nstart = time.time()\n\nfor iter in range(1, n_iters + 1):\n    category, line, [category_tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [line_tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = randomTrainingExample()\n    [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), loss = train([category_tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [line_tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"))\n    current_loss += loss\n\n    # Print ``iter`` number, loss, name and guess\n    if iter % print_every == 0:\n        guess, guess_i = categoryFromOutput([output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"))\n        correct = '\u2713' if guess == category else '\u2717 (%s)' % category\n        print('%d  %d%% (%s) %.4f  %s / %s  %s' % (iter, iter / n_iters * 100, timeSince(start), loss, line, guess, correct))\n\n    # Add current loss avg to list of losses\n    if iter % plot_every == 0:\n        all_losses.append(current_loss / plot_every)\n        current_loss = 0 \n```", "```py\n5000 5% (0m 29s) 2.6379 Horigome / Japanese \u2713\n10000 10% (0m 58s) 2.0172 Miazga / Japanese \u2717 (Polish)\n15000 15% (1m 29s) 0.2680 Yukhvidov / Russian \u2713\n20000 20% (1m 58s) 1.8239 Mclaughlin / Irish \u2717 (Scottish)\n25000 25% (2m 29s) 0.6978 Banh / Vietnamese \u2713\n30000 30% (2m 58s) 1.7433 Machado / Japanese \u2717 (Portuguese)\n35000 35% (3m 28s) 0.0340 Fotopoulos / Greek \u2713\n40000 40% (3m 58s) 1.4637 Quirke / Irish \u2713\n45000 45% (4m 28s) 1.9018 Reier / French \u2717 (German)\n50000 50% (4m 57s) 0.9174 Hou / Chinese \u2713\n55000 55% (5m 27s) 1.0506 Duan / Vietnamese \u2717 (Chinese)\n60000 60% (5m 57s) 0.9617 Giang / Vietnamese \u2713\n65000 65% (6m 27s) 2.4557 Cober / German \u2717 (Czech)\n70000 70% (6m 57s) 0.8502 Mateus / Portuguese \u2713\n75000 75% (7m 26s) 0.2750 Hamilton / Scottish \u2713\n80000 80% (7m 56s) 0.7515 Maessen / Dutch \u2713\n85000 85% (8m 26s) 0.0912 Gan / Chinese \u2713\n90000 90% (8m 55s) 0.1190 Bellomi / Italian \u2713\n95000 95% (9m 25s) 0.0137 Vozgov / Russian \u2713\n100000 100% (9m 55s) 0.7808 Tong / Vietnamese \u2713 \n```", "```py\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\n\nplt.figure()\nplt.plot(all_losses) \n```", "```py\n[<matplotlib.lines.Line2D object at 0x7f4d28129de0>] \n```", "```py\n# Keep track of correct guesses in a confusion matrix\n[confusion](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = [torch.zeros](https://pytorch.org/docs/stable/generated/torch.zeros.html#torch.zeros \"torch.zeros\")(n_categories, n_categories)\nn_confusion = 10000\n\n# Just return an output given a line\ndef evaluate([line_tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")):\n    [hidden](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = rnn.initHidden()\n\n    for i in range([line_tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\").size()[0]):\n        [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [hidden](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = rnn([line_tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")[i], [hidden](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"))\n\n    return [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")\n\n# Go through a bunch of examples and record which are correctly guessed\nfor i in range(n_confusion):\n    category, line, [category_tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [line_tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = randomTrainingExample()\n    [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = evaluate([line_tensor](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"))\n    guess, guess_i = categoryFromOutput([output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"))\n    category_i = all_categories.index(category)\n    [confusion](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")[category_i][guess_i] += 1\n\n# Normalize by dividing every row by its sum\nfor i in range(n_categories):\n    [confusion](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")[i] = [confusion](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")[i] / [confusion](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")[i].sum()\n\n# Set up plot\nfig = plt.figure()\nax = fig.add_subplot(111)\ncax = ax.matshow([confusion](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\").numpy())\nfig.colorbar(cax)\n\n# Set up axes\nax.set_xticklabels([''] + all_categories, rotation=90)\nax.set_yticklabels([''] + all_categories)\n\n# Force label at every tick\nax.xaxis.set_major_locator(ticker.MultipleLocator(1))\nax.yaxis.set_major_locator(ticker.MultipleLocator(1))\n\n# sphinx_gallery_thumbnail_number = 2\nplt.show() \n```", "```py\n/var/lib/jenkins/workspace/intermediate_source/char_rnn_classification_tutorial.py:445: UserWarning:\n\nset_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.\n\n/var/lib/jenkins/workspace/intermediate_source/char_rnn_classification_tutorial.py:446: UserWarning:\n\nset_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator. \n```", "```py\ndef predict(input_line, n_predictions=3):\n    print('\\n> %s' % input_line)\n    with [torch.no_grad](https://pytorch.org/docs/stable/generated/torch.no_grad.html#torch.no_grad \"torch.no_grad\")():\n        [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = evaluate(lineToTensor(input_line))\n\n        # Get top N categories\n        topv, topi = [output](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\").topk(n_predictions, 1, True)\n        predictions = []\n\n        for i in range(n_predictions):\n            value = topv[0][i].item()\n            category_index = topi[0][i].item()\n            print('(%.2f) %s' % (value, all_categories[category_index]))\n            predictions.append([value, all_categories[category_index]])\n\npredict('Dovesky')\npredict('Jackson')\npredict('Satoshi') \n```", "```py\n> Dovesky\n(-0.57) Czech\n(-0.97) Russian\n(-3.43) English\n\n> Jackson\n(-1.02) Scottish\n(-1.49) Russian\n(-1.96) English\n\n> Satoshi\n(-0.42) Japanese\n(-1.70) Polish\n(-2.74) Italian \n```", "```py\n$  python  predict.py  Hazaki\n(-0.42)  Japanese\n(-1.39)  Polish\n(-3.51)  Czech \n```"]