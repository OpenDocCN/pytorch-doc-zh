["```py\nimport torch\n\n# use deeplabv3_resnet50 instead of deeplabv3_resnet101 to reduce the model size\nmodel = torch.hub.load('pytorch/vision:v0.8.0', 'deeplabv3_resnet50', pretrained=True)\nmodel.eval()\n\nscriptedm = torch.jit.script(model)\ntorch.jit.save(scriptedm, \"deeplabv3_scripted.pt\") \n```", "```py\nfrom PIL import Image\nfrom torchvision import transforms\ninput_image = Image.open(\"deeplab.jpg\")\npreprocess = transforms.Compose([\n    transforms.ToTensor(),\n    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),\n])\n\ninput_tensor = preprocess(input_image)\ninput_batch = input_tensor.unsqueeze(0)\nwith torch.no_grad():\n    output = model(input_batch)['out'][0]\n\nprint(input_batch.shape)\nprint(output.shape) \n```", "```py\ntorch.Size([1, 3, 400, 400])\ntorch.Size([21, 400, 400]) \n```", "```py\nclass ViewController: UIViewController {\n    var image = UIImage(named: \"deeplab.jpg\")!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n    }\n\n    private lazy var module: TorchModule = {\n        if let filePath = Bundle.main.path(forResource: \"deeplabv3_scripted\",\n              ofType: \"pt\"),\n            let module = TorchModule(fileAtPath: filePath) {\n            return module\n        } else {\n            fatalError(\"Can't load the model file!\")\n        }\n    }()\n} \n```", "```py\n- (unsigned  char*)predictImage:(void*)imageBuffer  {\n  // 1\\. the example deeplab.jpg size is size 400x400 and there are 21 semantic classes\n  const  int  WIDTH  =  400;\n  const  int  HEIGHT  =  400;\n  const  int  CLASSNUM  =  21;\n\n  at::Tensor  tensor  =  torch::from_blob(imageBuffer,  {1,  3,  WIDTH,  HEIGHT},  at::kFloat);\n  torch::autograd::AutoGradMode  guard(false);\n  at::AutoNonVariableTypeMode  non_var_type_mode(true);\n\n  // 2\\. convert the input tensor to an NSMutableArray for debugging\n  float*  floatInput  =  tensor.data_ptr<float>();\n  if  (!floatInput)  {\n  return  nil;\n  }\n  NSMutableArray*  inputs  =  [[NSMutableArray  alloc]  init];\n  for  (int  i  =  0;  i  <  3  *  WIDTH  *  HEIGHT;  i++)  {\n  [inputs  addObject:@(floatInput[i])];\n  }\n\n  // 3\\. the output of the model is a dictionary of string and tensor, as\n  // specified at https://pytorch.org/hub/pytorch_vision_deeplabv3_resnet101\n  auto  outputDict  =  _impl.forward({tensor}).toGenericDict();\n\n  // 4\\. convert the output to another NSMutableArray for easy debugging\n  auto  outputTensor  =  outputDict.at(\"out\").toTensor();\n  float*  floatBuffer  =  outputTensor.data_ptr<float>();\n  if  (!floatBuffer)  {\n  return  nil;\n  }\n  NSMutableArray*  results  =  [[NSMutableArray  alloc]  init];\n  for  (int  i  =  0;  i  <  CLASSNUM  *  WIDTH  *  HEIGHT;  i++)  {\n  [results  addObject:@(floatBuffer[i])];\n  }\n\n  return  nil;\n} \n```", "```py\n// see the 20 semantic classes link in Introduction\nconst  int  DOG  =  12;\nconst  int  PERSON  =  15;\nconst  int  SHEEP  =  17;\n\nNSMutableData*  data  =  [NSMutableData  dataWithLength:\n  sizeof(unsigned  char)  *  3  *  WIDTH  *  HEIGHT];\nunsigned  char*  buffer  =  (unsigned  char*)[data  mutableBytes];\n// go through each element in the output of size [WIDTH, HEIGHT] and\n// set different color for different classnum\nfor  (int  j  =  0;  j  <  WIDTH;  j++)  {\n  for  (int  k  =  0;  k  <  HEIGHT;  k++)  {\n  // maxi: the index of the 21 CLASSNUM with the max probability\n  int  maxi  =  0,  maxj  =  0,  maxk  =  0;\n  float  maxnum  =  -100000.0;\n  for  (int  i  =  0;  i  <  CLASSNUM;  i++)  {\n  if  ([results[i  *  (WIDTH  *  HEIGHT)  +  j  *  WIDTH  +  k]  floatValue]  >  maxnum)  {\n  maxnum  =  [results[i  *  (WIDTH  *  HEIGHT)  +  j  *  WIDTH  +  k]  floatValue];\n  maxi  =  i;  maxj  =  j;  maxk  =  k;\n  }\n  }\n  int  n  =  3  *  (maxj  *  width  +  maxk);\n  // color coding for person (red), dog (green), sheep (blue)\n  // black color for background and other classes\n  buffer[n]  =  0;  buffer[n+1]  =  0;  buffer[n+2]  =  0;\n  if  (maxi  ==  PERSON)  buffer[n]  =  255;\n  else  if  (maxi  ==  DOG)  buffer[n+1]  =  255;\n  else  if  (maxi  ==  SHEEP)  buffer[n+2]  =  255;\n  }\n}\nreturn  buffer; \n```"]