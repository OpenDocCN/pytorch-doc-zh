- en: torch.special
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pytorch.org/docs/stable/special.html](https://pytorch.org/docs/stable/special.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The torch.special module, modeled after SciPy’s [special](https://docs.scipy.org/doc/scipy/reference/special.html)
    module.
  prefs: []
  type: TYPE_NORMAL
- en: '## Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Airy function <math><semantics><mrow><mtext>Ai</mtext><mrow><mo fence="true">(</mo><mtext>input</mtext><mo
    fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{Ai}\left(\text{input}\right)</annotation></semantics></math>Ai(input).
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Bessel function of the first kind of order $0$0.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Bessel function of the first kind of order $1$1.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Computes the logarithmic derivative of the gamma function on input.
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><mi mathvariant="normal">ϝ</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mfrac><mi>d</mi><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mi>ln</mi><mo>⁡</mo><mrow><mo
    fence="true">(</mo><mi mathvariant="normal">Γ</mi><mrow><mo fence="true">(</mo><mi>x</mi><mo
    fence="true">)</mo></mrow><mo fence="true">)</mo></mrow><mo>=</mo><mfrac><mrow><msup><mi
    mathvariant="normal">Γ</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mrow><mi mathvariant="normal">Γ</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation
    encoding="application/x-tex">\digamma(x) = \frac{d}{dx} \ln\left(\Gamma\left(x\right)\right)
    = \frac{\Gamma'(x)}{\Gamma(x)}</annotation></semantics></math> ϝ(x)=dxd​ln(Γ(x))=Γ(x)Γ′(x)​
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the tensor
    to compute the digamma function on'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This function is similar to SciPy’s scipy.special.digamma.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: From PyTorch 1.8 onwards, the digamma function returns -Inf for 0. Previously
    it returned NaN for 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Computes the entropy on `input` (as defined below), elementwise.
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mtable rowspacing="0.25em" columnalign="right"
    columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext>entr(x)</mtext><mo>=</mo><mrow><mo
    fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>x</mi><mo>∗</mo><mi>ln</mi><mo>⁡</mo><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>></mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mrow><mi>x</mi><mo>=</mo><mn>0.0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo><</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr></mtable><annotation
    encoding="application/x-tex">\begin{align} \text{entr(x)} = \begin{cases} -x *
    \ln(x) & x > 0 \\ 0 & x = 0.0 \\ -\infty & x < 0 \end{cases} \end{align}</annotation></semantics></math>
    entr(x)=⎩⎨⎧​−x∗ln(x)0−∞​x>0x=0.0x<0​​​
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Computes the error function of `input`. The error function is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><mrow><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">r</mi><mi mathvariant="normal">f</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mfrac><mn>2</mn><msqrt><mi>π</mi></msqrt></mfrac><msubsup><mo>∫</mo><mn>0</mn><mi>x</mi></msubsup><msup><mi>e</mi><mrow><mo>−</mo><msup><mi>t</mi><mn>2</mn></msup></mrow></msup><mi>d</mi><mi>t</mi></mrow><annotation
    encoding="application/x-tex">\mathrm{erf}(x) = \frac{2}{\sqrt{\pi}} \int_{0}^{x}
    e^{-t^2} dt</annotation></semantics></math> erf(x)=π​2​∫0x​e−t2dt
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Computes the complementary error function of `input`. The complementary error
    function is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><mrow><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">r</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">c</mi></mrow><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>−</mo><mfrac><mn>2</mn><msqrt><mi>π</mi></msqrt></mfrac><msubsup><mo>∫</mo><mn>0</mn><mi>x</mi></msubsup><msup><mi>e</mi><mrow><mo>−</mo><msup><mi>t</mi><mn>2</mn></msup></mrow></msup><mi>d</mi><mi>t</mi></mrow><annotation
    encoding="application/x-tex">\mathrm{erfc}(x) = 1 - \frac{2}{\sqrt{\pi}} \int_{0}^{x}
    e^{-t^2} dt</annotation></semantics></math> erfc(x)=1−π​2​∫0x​e−t2dt
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Computes the scaled complementary error function for each element of `input`.
    The scaled complementary error function is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><mrow><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">r</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">c</mi><mi
    mathvariant="normal">x</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi><msup><mi>x</mi><mn>2</mn></msup></msup><mrow><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">c</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">\mathrm{erfcx}(x) = e^{x^2} \mathrm{erfc}(x)</annotation></semantics></math>
    erfcx(x)=ex2erfc(x)
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Computes the inverse error function of `input`. The inverse error function
    is defined in the range <math><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo
    separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">(-1, 1)</annotation></semantics></math>(−1,1) as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><mrow><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">r</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi
    mathvariant="normal">n</mi><mi mathvariant="normal">v</mi></mrow><mo stretchy="false">(</mo><mrow><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">f</mi></mrow><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation
    encoding="application/x-tex">\mathrm{erfinv}(\mathrm{erf}(x)) = x</annotation></semantics></math>
    erfinv(erf(x))=x
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Computes the base two exponential function of `input`.
  prefs: []
  type: TYPE_NORMAL
- en: $y_{i} = 2^{x_{i}}$
    yi​=2xi​
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Computes the expit (also known as the logistic sigmoid function) of the elements
    of `input`.
  prefs: []
  type: TYPE_NORMAL
- en: $\text{out}_{i} = \frac{1}{1 + e^{-\text{input}_{i}}}$
    outi​=1+e−inputi​1​
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Computes the exponential of the elements minus 1 of `input`.
  prefs: []
  type: TYPE_NORMAL
- en: $y_{i} = e^{x_{i}} - 1$
    yi​=exi​−1
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This function provides greater precision than exp(x) - 1 for small values of
    x.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Computes the regularized lower incomplete gamma function:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><msub><mtext>out</mtext><mi>i</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi
    mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><msub><mtext>input</mtext><mi>i</mi></msub><mo
    stretchy="false">)</mo></mrow></mfrac><msubsup><mo>∫</mo><mn>0</mn><msub><mtext>other</mtext><mi>i</mi></msub></msubsup><msup><mi>t</mi><mrow><msub><mtext>input</mtext><mi>i</mi></msub><mo>−</mo><mn>1</mn></mrow></msup><msup><mi>e</mi><mrow><mo>−</mo><mi>t</mi></mrow></msup><mi>d</mi><mi>t</mi></mrow><annotation
    encoding="application/x-tex">\text{out}_{i} = \frac{1}{\Gamma(\text{input}_i)}
    \int_0^{\text{other}_i} t^{\text{input}_i-1} e^{-t} dt</annotation></semantics></math>
    outi​=Γ(inputi​)1​∫0otheri​​tinputi​−1e−tdt
  prefs: []
  type: TYPE_NORMAL
- en: where both $\text{input}_i$inputi​
    and $\text{other}_i$otheri​
    are weakly positive and at least one is strictly positive. If both are zero or
    either is negative then $\text{out}_i=\text{nan}$outi​=nan.
    <math><semantics><mrow><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mo>⋅</mo><mo
    stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Gamma(\cdot)</annotation></semantics></math>Γ(⋅)
    in the equation above is the gamma function,
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><msub><mtext>input</mtext><mi>i</mi></msub><mo
    stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi mathvariant="normal">∞</mi></msubsup><msup><mi>t</mi><mrow><mo
    stretchy="false">(</mo><msub><mtext>input</mtext><mi>i</mi></msub><mo>−</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></msup><msup><mi>e</mi><mrow><mo>−</mo><mi>t</mi></mrow></msup><mi>d</mi><mi>t</mi><mi
    mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\Gamma(\text{input}_i)
    = \int_0^\infty t^{(\text{input}_i-1)} e^{-t} dt.</annotation></semantics></math>
    Γ(inputi​)=∫0∞​t(inputi​−1)e−tdt.
  prefs: []
  type: TYPE_NORMAL
- en: See [`torch.special.gammaincc()`](#torch.special.gammaincc "torch.special.gammaincc")
    and [`torch.special.gammaln()`](#torch.special.gammaln "torch.special.gammaln")
    for related functions.
  prefs: []
  type: TYPE_NORMAL
- en: Supports [broadcasting to a common shape](notes/broadcasting.html#broadcasting-semantics)
    and float inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The backward pass with respect to `input` is not yet supported. Please open
    an issue on PyTorch’s Github to request it.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the first
    non-negative input tensor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**other** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the second
    non-negative input tensor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Computes the regularized upper incomplete gamma function:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><msub><mtext>out</mtext><mi>i</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi
    mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><msub><mtext>input</mtext><mi>i</mi></msub><mo
    stretchy="false">)</mo></mrow></mfrac><msubsup><mo>∫</mo><msub><mtext>other</mtext><mi>i</mi></msub><mi
    mathvariant="normal">∞</mi></msubsup><msup><mi>t</mi><mrow><msub><mtext>input</mtext><mi>i</mi></msub><mo>−</mo><mn>1</mn></mrow></msup><msup><mi>e</mi><mrow><mo>−</mo><mi>t</mi></mrow></msup><mi>d</mi><mi>t</mi></mrow><annotation
    encoding="application/x-tex">\text{out}_{i} = \frac{1}{\Gamma(\text{input}_i)}
    \int_{\text{other}_i}^{\infty} t^{\text{input}_i-1} e^{-t} dt</annotation></semantics></math>
    outi​=Γ(inputi​)1​∫otheri​∞​tinputi​−1e−tdt
  prefs: []
  type: TYPE_NORMAL
- en: where both $\text{input}_i$inputi​
    and $\text{other}_i$otheri​
    are weakly positive and at least one is strictly positive. If both are zero or
    either is negative then $\text{out}_i=\text{nan}$outi​=nan.
    <math><semantics><mrow><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mo>⋅</mo><mo
    stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Gamma(\cdot)</annotation></semantics></math>Γ(⋅)
    in the equation above is the gamma function,
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><msub><mtext>input</mtext><mi>i</mi></msub><mo
    stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi mathvariant="normal">∞</mi></msubsup><msup><mi>t</mi><mrow><mo
    stretchy="false">(</mo><msub><mtext>input</mtext><mi>i</mi></msub><mo>−</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></msup><msup><mi>e</mi><mrow><mo>−</mo><mi>t</mi></mrow></msup><mi>d</mi><mi>t</mi><mi
    mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\Gamma(\text{input}_i)
    = \int_0^\infty t^{(\text{input}_i-1)} e^{-t} dt.</annotation></semantics></math>
    Γ(inputi​)=∫0∞​t(inputi​−1)e−tdt.
  prefs: []
  type: TYPE_NORMAL
- en: See [`torch.special.gammainc()`](#torch.special.gammainc "torch.special.gammainc")
    and [`torch.special.gammaln()`](#torch.special.gammaln "torch.special.gammaln")
    for related functions.
  prefs: []
  type: TYPE_NORMAL
- en: Supports [broadcasting to a common shape](notes/broadcasting.html#broadcasting-semantics)
    and float inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The backward pass with respect to `input` is not yet supported. Please open
    an issue on PyTorch’s Github to request it.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the first
    non-negative input tensor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**other** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the second
    non-negative input tensor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Computes the natural logarithm of the absolute value of the gamma function on
    `input`.
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><msub><mtext>out</mtext><mi>i</mi></msub><mo>=</mo><mi>ln</mi><mo>⁡</mo><mi
    mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><msub><mtext>input</mtext><mi>i</mi></msub><mi
    mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{out}_{i}
    = \ln \Gamma(|\text{input}_{i}|)</annotation></semantics></math> outi​=lnΓ(∣inputi​∣)
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Computes the zeroth order modified Bessel function of the first kind for each
    element of `input`.
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><msub><mtext>out</mtext><mi>i</mi></msub><mo>=</mo><msub><mi>I</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><msub><mtext>input</mtext><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mi
    mathvariant="normal">∞</mi></munderover><mfrac><mrow><mo stretchy="false">(</mo><msubsup><mtext>input</mtext><mi>i</mi><mn>2</mn></msubsup><mi
    mathvariant="normal">/</mi><mn>4</mn><msup><mo stretchy="false">)</mo><mi>k</mi></msup></mrow><mrow><mo
    stretchy="false">(</mo><mi>k</mi><mo stretchy="false">!</mo><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mfrac></mrow><annotation
    encoding="application/x-tex">\text{out}_{i} = I_0(\text{input}_{i}) = \sum_{k=0}^{\infty}
    \frac{(\text{input}_{i}^2/4)^k}{(k!)^2}</annotation></semantics></math> outi​=I0​(inputi​)=k=0∑∞​(k!)2(inputi2​/4)k​
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Computes the exponentially scaled zeroth order modified Bessel function of the
    first kind (as defined below) for each element of `input`.
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><msub><mtext>out</mtext><mi>i</mi></msub><mo>=</mo><mi>exp</mi><mo>⁡</mo><mo
    stretchy="false">(</mo><mo>−</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mi
    mathvariant="normal">∣</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>i</mi><mn>0</mn><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>exp</mi><mo>⁡</mo><mo
    stretchy="false">(</mo><mo>−</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mi
    mathvariant="normal">∣</mi><mo stretchy="false">)</mo><mo>∗</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mi
    mathvariant="normal">∞</mi></munderover><mfrac><mrow><mo stretchy="false">(</mo><msubsup><mtext>input</mtext><mi>i</mi><mn>2</mn></msubsup><mi
    mathvariant="normal">/</mi><mn>4</mn><msup><mo stretchy="false">)</mo><mi>k</mi></msup></mrow><mrow><mo
    stretchy="false">(</mo><mi>k</mi><mo stretchy="false">!</mo><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mfrac></mrow><annotation
    encoding="application/x-tex">\text{out}_{i} = \exp(-|x|) * i0(x) = \exp(-|x|)
    * \sum_{k=0}^{\infty} \frac{(\text{input}_{i}^2/4)^k}{(k!)^2}</annotation></semantics></math>
    outi​=exp(−∣x∣)∗i0(x)=exp(−∣x∣)∗k=0∑∞​(k!)2(inputi2​/4)k​
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Computes the first order modified Bessel function of the first kind (as defined
    below) for each element of `input`.
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><msub><mtext>out</mtext><mi>i</mi></msub><mo>=</mo><mfrac><mrow><mo
    stretchy="false">(</mo><msub><mtext>input</mtext><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>∗</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mi
    mathvariant="normal">∞</mi></munderover><mfrac><mrow><mo stretchy="false">(</mo><msubsup><mtext>input</mtext><mi>i</mi><mn>2</mn></msubsup><mi
    mathvariant="normal">/</mi><mn>4</mn><msup><mo stretchy="false">)</mo><mi>k</mi></msup></mrow><mrow><mo
    stretchy="false">(</mo><mi>k</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo><mo>∗</mo><mo
    stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo
    stretchy="false">!</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\text{out}_{i}
    = \frac{(\text{input}_{i})}{2} * \sum_{k=0}^{\infty} \frac{(\text{input}_{i}^2/4)^k}{(k!)
    * (k+1)!}</annotation></semantics></math> outi​=2(inputi​)​∗k=0∑∞​(k!)∗(k+1)!(inputi2​/4)k​
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Computes the exponentially scaled first order modified Bessel function of the
    first kind (as defined below) for each element of `input`.
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><msub><mtext>out</mtext><mi>i</mi></msub><mo>=</mo><mi>exp</mi><mo>⁡</mo><mo
    stretchy="false">(</mo><mo>−</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mi
    mathvariant="normal">∣</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>i</mi><mn>1</mn><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>exp</mi><mo>⁡</mo><mo
    stretchy="false">(</mo><mo>−</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mi
    mathvariant="normal">∣</mi><mo stretchy="false">)</mo><mo>∗</mo><mfrac><mrow><mo
    stretchy="false">(</mo><msub><mtext>input</mtext><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>∗</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mi
    mathvariant="normal">∞</mi></munderover><mfrac><mrow><mo stretchy="false">(</mo><msubsup><mtext>input</mtext><mi>i</mi><mn>2</mn></msubsup><mi
    mathvariant="normal">/</mi><mn>4</mn><msup><mo stretchy="false">)</mo><mi>k</mi></msup></mrow><mrow><mo
    stretchy="false">(</mo><mi>k</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo><mo>∗</mo><mo
    stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo
    stretchy="false">!</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\text{out}_{i}
    = \exp(-|x|) * i1(x) = \exp(-|x|) * \frac{(\text{input}_{i})}{2} * \sum_{k=0}^{\infty}
    \frac{(\text{input}_{i}^2/4)^k}{(k!) * (k+1)!}</annotation></semantics></math>
    outi​=exp(−∣x∣)∗i1(x)=exp(−∣x∣)∗2(inputi​)​∗k=0∑∞​(k!)∗(k+1)!(inputi2​/4)k​
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Alias for [`torch.log1p()`](generated/torch.log1p.html#torch.log1p "torch.log1p").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Computes the log of the area under the standard Gaussian probability density
    function, integrated from minus infinity to `input`, elementwise.
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><mtext>log_ndtr</mtext><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mi>log</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mfrac><mn>1</mn><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mfrac><msubsup><mo>∫</mo><mrow><mo>−</mo><mi
    mathvariant="normal">∞</mi></mrow><mi>x</mi></msubsup><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mi>t</mi><mn>2</mn></msup></mrow></msup><mi>d</mi><mi>t</mi><mo
    fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{log\_ndtr}(x)
    = \log\left(\frac{1}{\sqrt{2 \pi}}\int_{-\infty}^{x} e^{-\frac{1}{2}t^2} dt \right)</annotation></semantics></math>
    log_ndtr(x)=log(2π​1​∫−∞x​e−21​t2dt)
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Computes softmax followed by a logarithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'While mathematically equivalent to log(softmax(x)), doing these two operations
    separately is slower and numerically unstable. This function is computed as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><mtext>log_softmax</mtext><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo
    stretchy="false">)</mo><mo>=</mo><mi>log</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mfrac><mrow><mi>exp</mi><mo>⁡</mo><mo
    stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><munder><mo>∑</mo><mi>j</mi></munder><mi>exp</mi><mo>⁡</mo><mo
    stretchy="false">(</mo><msub><mi>x</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow></mfrac><mo
    fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{log\_softmax}(x_{i})
    = \log\left(\frac{\exp(x_i) }{ \sum_j \exp(x_j)} \right)</annotation></semantics></math>
    log_softmax(xi​)=log(∑j​exp(xj​)exp(xi​)​)
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dim** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")) – A dimension along which log_softmax will be computed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dtype** ([`torch.dtype`](tensor_attributes.html#torch.dtype "torch.dtype"),
    optional) – the desired data type of returned tensor. If specified, the input
    tensor is cast to `dtype` before the operation is performed. This is useful for
    preventing data type overflows. Default: None.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Returns a new tensor with the logit of the elements of `input`. `input` is clamped
    to [eps, 1 - eps] when eps is not None. When eps is None and `input` < 0 or `input`
    > 1, the function will yields NaN.
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mtable rowspacing="0.25em" columnalign="right
    left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>y</mi><mi>i</mi></msub></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mi>ln</mi><mo>⁡</mo><mo stretchy="false">(</mo><mfrac><msub><mi>z</mi><mi>i</mi></msub><mrow><mn>1</mn><mo>−</mo><msub><mi>z</mi><mi>i</mi></msub></mrow></mfrac><mo
    stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0"
    displaystyle="true"><msub><mi>z</mi><mi>i</mi></msub></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mrow><mo fence="true">{</mo><mtable
    rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><msub><mi>x</mi><mi>i</mi></msub></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mtext>if eps is None</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mtext>eps</mtext></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><msub><mi>x</mi><mi>i</mi></msub><mo><</mo><mtext>eps</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><msub><mi>x</mi><mi>i</mi></msub></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mrow><mtext>if eps</mtext><mo>≤</mo><msub><mi>x</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><mo>−</mo><mtext>eps</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo>−</mo><mtext>eps</mtext></mrow></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><msub><mi>x</mi><mi>i</mi></msub><mo>></mo><mn>1</mn><mo>−</mo><mtext>eps</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr></mtable><annotation
    encoding="application/x-tex">\begin{align} y_{i} &= \ln(\frac{z_{i}}{1 - z_{i}})
    \\ z_{i} &= \begin{cases} x_{i} & \text{if eps is None} \\ \text{eps} & \text{if
    } x_{i} < \text{eps} \\ x_{i} & \text{if } \text{eps} \leq x_{i} \leq 1 - \text{eps}
    \\ 1 - \text{eps} & \text{if } x_{i} > 1 - \text{eps} \end{cases} \end{align}</annotation></semantics></math>
    yi​zi​​=ln(1−zi​zi​​)=⎩⎨⎧​xi​epsxi​1−eps​if eps is Noneif xi​<epsif eps≤xi​≤1−epsif xi​>1−eps​​​
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**eps** ([*float*](https://docs.python.org/3/library/functions.html#float "(in
    Python v3.12)")*,* *optional*) – the epsilon for input clamp bound. Default: `None`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Alias for [`torch.logsumexp()`](generated/torch.logsumexp.html#torch.logsumexp
    "torch.logsumexp").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Computes the [multivariate log-gamma function](https://en.wikipedia.org/wiki/Multivariate_gamma_function)
    with dimension $p$p
    element-wise, given by
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi
    mathvariant="normal">Γ</mi><mi>p</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><mo>+</mo><mstyle
    scriptlevel="0" displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>p</mi></munderover><mi>log</mi><mo>⁡</mo><mrow><mo
    fence="true">(</mo><mi mathvariant="normal">Γ</mi><mrow><mo fence="true">(</mo><mi>a</mi><mo>−</mo><mfrac><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo
    fence="true">)</mo></mrow><mo fence="true">)</mo></mrow></mstyle></mrow><annotation
    encoding="application/x-tex">\log(\Gamma_{p}(a)) = C + \displaystyle \sum_{i=1}^{p}
    \log\left(\Gamma\left(a - \frac{i - 1}{2}\right)\right)</annotation></semantics></math>
    log(Γp​(a))=C+i=1∑p​log(Γ(a−2i−1​))
  prefs: []
  type: TYPE_NORMAL
- en: where <math><semantics><mrow><mi>C</mi><mo>=</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>π</mi><mo
    stretchy="false">)</mo><mo>⋅</mo><mfrac><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow><mn>4</mn></mfrac></mrow><annotation encoding="application/x-tex">C
    = \log(\pi) \cdot \frac{p (p - 1)}{4}</annotation></semantics></math>C=log(π)⋅4p(p−1)​
    and <math><semantics><mrow><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mo>−</mo><mo
    stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Gamma(-)</annotation></semantics></math>Γ(−)
    is the Gamma function.
  prefs: []
  type: TYPE_NORMAL
- en: All elements must be greater than $\frac{p - 1}{2}$2p−1​,
    otherwise the behavior is undefiend.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the tensor
    to compute the multivariate log-gamma function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**p** ([*int*](https://docs.python.org/3/library/functions.html#int "(in Python
    v3.12)")) – the number of dimensions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Computes the area under the standard Gaussian probability density function,
    integrated from minus infinity to `input`, elementwise.
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><mtext>ndtr</mtext><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mfrac><msubsup><mo>∫</mo><mrow><mo>−</mo><mi
    mathvariant="normal">∞</mi></mrow><mi>x</mi></msubsup><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mi>t</mi><mn>2</mn></msup></mrow></msup><mi>d</mi><mi>t</mi></mrow><annotation
    encoding="application/x-tex">\text{ndtr}(x) = \frac{1}{\sqrt{2 \pi}}\int_{-\infty}^{x}
    e^{-\frac{1}{2}t^2} dt</annotation></semantics></math> ndtr(x)=2π​1​∫−∞x​e−21​t2dt
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Computes the argument, x, for which the area under the Gaussian probability
    density function (integrated from minus infinity to x) is equal to `input`, elementwise.
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><mtext>ndtri</mtext><mo stretchy="false">(</mo><mi>p</mi><mo
    stretchy="false">)</mo><mo>=</mo><msqrt><mn>2</mn></msqrt><msup><mtext>erf</mtext><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo
    stretchy="false">(</mo><mn>2</mn><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">\text{ndtri}(p) = \sqrt{2}\text{erf}^{-1}(2p - 1)</annotation></semantics></math>
    ndtri(p)=2​erf−1(2p−1)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Also known as quantile function for Normal Distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Computes the $n^{th}$nth derivative
    of the digamma function on `input`. $n \geq 0$n≥0 is called
    the order of the polygamma function.
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><msup><mi>ψ</mi><mrow><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mfrac><msup><mi>d</mi><mrow><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></msup><mrow><mi>d</mi><msup><mi>x</mi><mrow><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></msup></mrow></mfrac><mi>ψ</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation
    encoding="application/x-tex">\psi^{(n)}(x) = \frac{d^{(n)}}{dx^{(n)}} \psi(x)</annotation></semantics></math>
    ψ(n)(x)=dx(n)d(n)​ψ(x)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This function is implemented only for nonnegative integers $n \geq 0$n≥0.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**n** ([*int*](https://docs.python.org/3/library/functions.html#int "(in Python
    v3.12)")) – the order of the polygamma function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Alias for [`torch.special.digamma()`](#torch.special.digamma "torch.special.digamma").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Alias for [`torch.round()`](generated/torch.round.html#torch.round "torch.round").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Scaled modified Bessel function of the second kind of order $0$0.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Scaled modified Bessel function of the second kind of order $1$1.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Computes the normalized sinc of `input.`
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><msub><mtext>out</mtext><mi>i</mi></msub><mo>=</mo><mrow><mo
    fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><msub><mtext>input</mtext><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>π</mi><msub><mtext>input</mtext><mi>i</mi></msub><mo
    stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>π</mi><msub><mtext>input</mtext><mi>i</mi></msub><mo
    stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mtext>otherwise</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation
    encoding="application/x-tex">\text{out}_{i} = \begin{cases} 1, & \text{if}\ \text{input}_{i}=0
    \\ \sin(\pi \text{input}_{i}) / (\pi \text{input}_{i}), & \text{otherwise} \end{cases}</annotation></semantics></math>
    outi​={1,sin(πinputi​)/(πinputi​),​if inputi​=0otherwise​
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Computes the softmax function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Softmax is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math><semantics><mrow><mtext>Softmax</mtext><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo
    stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo
    stretchy="false">)</mo></mrow><mrow><msub><mo>∑</mo><mi>j</mi></msub><mi>exp</mi><mo>⁡</mo><mo
    stretchy="false">(</mo><msub><mi>x</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation
    encoding="application/x-tex">\text{Softmax}(x_{i}) = \frac{\exp(x_i)}{\sum_j \exp(x_j)}</annotation></semantics></math>Softmax(xi​)=∑j​exp(xj​)exp(xi​)​
  prefs: []
  type: TYPE_NORMAL
- en: It is applied to all slices along dim, and will re-scale them so that the elements
    lie in the range [0, 1] and sum to 1.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dim** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")) – A dimension along which softmax will be computed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dtype** ([`torch.dtype`](tensor_attributes.html#torch.dtype "torch.dtype"),
    optional) – the desired data type of returned tensor. If specified, the input
    tensor is cast to `dtype` before the operation is performed. This is useful for
    preventing data type overflows. Default: None.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Spherical Bessel function of the first kind of order $0$0.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Computes `input * log1p(other)` with the following cases.
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><msub><mtext>out</mtext><mi>i</mi></msub><mo>=</mo><mrow><mo
    fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mtext>NaN</mtext></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><msub><mtext>other</mtext><mi>i</mi></msub><mo>=</mo><mtext>NaN</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mrow><mtext>if </mtext><msub><mtext>input</mtext><mi>i</mi></msub><mo>=</mo><mn>0.0</mn><mtext> and </mtext><msub><mtext>other</mtext><mi>i</mi></msub><mo
    stretchy="false">!</mo><mo>=</mo><mtext>NaN</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mrow><msub><mtext>input</mtext><mi>i</mi></msub><mo>∗</mo><mtext>log1p</mtext><mo
    stretchy="false">(</mo><msub><mtext>other</mtext><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mtext>otherwise</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation
    encoding="application/x-tex">\text{out}_{i} = \begin{cases} \text{NaN} & \text{if
    } \text{other}_{i} = \text{NaN} \\ 0 & \text{if } \text{input}_{i} = 0.0 \text{
    and } \text{other}_{i} != \text{NaN} \\ \text{input}_{i} * \text{log1p}(\text{other}_{i})&
    \text{otherwise} \end{cases}</annotation></semantics></math> outi​=⎩⎨⎧​NaN0inputi​∗log1p(otheri​)​if otheri​=NaNif inputi​=0.0 and otheri​!=NaNotherwise​
  prefs: []
  type: TYPE_NORMAL
- en: Similar to SciPy’s scipy.special.xlog1py.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** (*Number* *or* [*Tensor*](tensors.html#torch.Tensor "torch.Tensor"))
    – Multiplier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**other** (*Number* *or* [*Tensor*](tensors.html#torch.Tensor "torch.Tensor"))
    – Argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At least one of `input` or `other` must be a tensor.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Computes `input * log(other)` with the following cases.
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><msub><mtext>out</mtext><mi>i</mi></msub><mo>=</mo><mrow><mo
    fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mtext>NaN</mtext></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><msub><mtext>other</mtext><mi>i</mi></msub><mo>=</mo><mtext>NaN</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0"
    displaystyle="false"><mrow><mtext>if </mtext><msub><mtext>input</mtext><mi>i</mi></msub><mo>=</mo><mn>0.0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mrow><msub><mtext>input</mtext><mi>i</mi></msub><mo>∗</mo><mi>log</mi><mo>⁡</mo><mrow><mo
    stretchy="false">(</mo><msub><mtext>other</mtext><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle
    scriptlevel="0" displaystyle="false"><mtext>otherwise</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation
    encoding="application/x-tex">\text{out}_{i} = \begin{cases} \text{NaN} & \text{if
    } \text{other}_{i} = \text{NaN} \\ 0 & \text{if } \text{input}_{i} = 0.0 \\ \text{input}_{i}
    * \log{(\text{other}_{i})} & \text{otherwise} \end{cases}</annotation></semantics></math>
    outi​=⎩⎨⎧​NaN0inputi​∗log(otheri​)​if otheri​=NaNif inputi​=0.0otherwise​
  prefs: []
  type: TYPE_NORMAL
- en: Similar to SciPy’s scipy.special.xlogy.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** (*Number* *or* [*Tensor*](tensors.html#torch.Tensor "torch.Tensor"))
    – Multiplier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**other** (*Number* *or* [*Tensor*](tensors.html#torch.Tensor "torch.Tensor"))
    – Argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At least one of `input` or `other` must be a tensor.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Computes the Hurwitz zeta function, elementwise.
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><semantics><mrow><mi>ζ</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mi
    mathvariant="normal">∞</mi></munderover><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mi>q</mi><msup><mo
    stretchy="false">)</mo><mi>x</mi></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\zeta(x,
    q) = \sum_{k=0}^{\infty} \frac{1}{(k + q)^x}</annotation></semantics></math> ζ(x,q)=k=0∑∞​(k+q)x1​
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor corresponding to x.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**other** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor corresponding to q.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The Riemann zeta function corresponds to the case when q = 1
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
