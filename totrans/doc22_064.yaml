- en: torch.special
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pytorch.org/docs/stable/special.html](https://pytorch.org/docs/stable/special.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The torch.special module, modeled after SciPy’s [special](https://docs.scipy.org/doc/scipy/reference/special.html)
    module.
  prefs: []
  type: TYPE_NORMAL
- en: '## Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Airy function $\text{Ai}\left(\text{input}\right)$Ai(input).
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Bessel function of the first kind of order $0$0.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Bessel function of the first kind of order $1$1.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Computes the logarithmic derivative of the gamma function on input.
  prefs: []
  type: TYPE_NORMAL
- en: $\digamma(x) = \frac{d}{dx} \ln\left(\Gamma\left(x\right)\right)
    = \frac{\Gamma'(x)}{\Gamma(x)}$ ϝ(x)=dxd​ln(Γ(x))=Γ(x)Γ′(x)​
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the tensor
    to compute the digamma function on'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This function is similar to SciPy’s scipy.special.digamma.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: From PyTorch 1.8 onwards, the digamma function returns -Inf for 0. Previously
    it returned NaN for 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Computes the entropy on `input` (as defined below), elementwise.
  prefs: []
  type: TYPE_NORMAL
- en: $\begin{align} \text{entr(x)} = \begin{cases} -x *
    \ln(x) & x > 0 \\ 0 & x = 0.0 \\ -\infty & x < 0 \end{cases} \end{align}$
    entr(x)=⎩⎨⎧​−x∗ln(x)0−∞​x>0x=0.0x<0​​​
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Computes the error function of `input`. The error function is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: $\mathrm{erf}(x) = \frac{2}{\sqrt{\pi}} \int_{0}^{x}
    e^{-t^2} dt$ erf(x)=π​2​∫0x​e−t2dt
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Computes the complementary error function of `input`. The complementary error
    function is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: $\mathrm{erfc}(x) = 1 - \frac{2}{\sqrt{\pi}} \int_{0}^{x}
    e^{-t^2} dt$ erfc(x)=1−π​2​∫0x​e−t2dt
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Computes the scaled complementary error function for each element of `input`.
    The scaled complementary error function is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: $\mathrm{erfcx}(x) = e^{x^2} \mathrm{erfc}(x)$
    erfcx(x)=ex2erfc(x)
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Computes the inverse error function of `input`. The inverse error function
    is defined in the range $(-1, 1)$(−1,1) as:'
  prefs: []
  type: TYPE_NORMAL
- en: $\mathrm{erfinv}(\mathrm{erf}(x)) = x$
    erfinv(erf(x))=x
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Computes the base two exponential function of `input`.
  prefs: []
  type: TYPE_NORMAL
- en: $y_{i} = 2^{x_{i}}$
    yi​=2xi​
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Computes the expit (also known as the logistic sigmoid function) of the elements
    of `input`.
  prefs: []
  type: TYPE_NORMAL
- en: $\text{out}_{i} = \frac{1}{1 + e^{-\text{input}_{i}}}$
    outi​=1+e−inputi​1​
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Computes the exponential of the elements minus 1 of `input`.
  prefs: []
  type: TYPE_NORMAL
- en: $y_{i} = e^{x_{i}} - 1$
    yi​=exi​−1
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This function provides greater precision than exp(x) - 1 for small values of
    x.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Computes the regularized lower incomplete gamma function:'
  prefs: []
  type: TYPE_NORMAL
- en: $\text{out}_{i} = \frac{1}{\Gamma(\text{input}_i)}
    \int_0^{\text{other}_i} t^{\text{input}_i-1} e^{-t} dt$
    outi​=Γ(inputi​)1​∫0otheri​​tinputi​−1e−tdt
  prefs: []
  type: TYPE_NORMAL
- en: where both $\text{input}_i$inputi​
    and $\text{other}_i$otheri​
    are weakly positive and at least one is strictly positive. If both are zero or
    either is negative then $\text{out}_i=\text{nan}$outi​=nan.
    $\Gamma(\cdot)$Γ(⋅)
    in the equation above is the gamma function,
  prefs: []
  type: TYPE_NORMAL
- en: $\Gamma(\text{input}_i)
    = \int_0^\infty t^{(\text{input}_i-1)} e^{-t} dt.$
    Γ(inputi​)=∫0∞​t(inputi​−1)e−tdt.
  prefs: []
  type: TYPE_NORMAL
- en: See [`torch.special.gammaincc()`](#torch.special.gammaincc "torch.special.gammaincc")
    and [`torch.special.gammaln()`](#torch.special.gammaln "torch.special.gammaln")
    for related functions.
  prefs: []
  type: TYPE_NORMAL
- en: Supports [broadcasting to a common shape](notes/broadcasting.html#broadcasting-semantics)
    and float inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The backward pass with respect to `input` is not yet supported. Please open
    an issue on PyTorch’s Github to request it.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the first
    non-negative input tensor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**other** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the second
    non-negative input tensor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Computes the regularized upper incomplete gamma function:'
  prefs: []
  type: TYPE_NORMAL
- en: $\text{out}_{i} = \frac{1}{\Gamma(\text{input}_i)}
    \int_{\text{other}_i}^{\infty} t^{\text{input}_i-1} e^{-t} dt$
    outi​=Γ(inputi​)1​∫otheri​∞​tinputi​−1e−tdt
  prefs: []
  type: TYPE_NORMAL
- en: where both $\text{input}_i$inputi​
    and $\text{other}_i$otheri​
    are weakly positive and at least one is strictly positive. If both are zero or
    either is negative then $\text{out}_i=\text{nan}$outi​=nan.
    $\Gamma(\cdot)$Γ(⋅)
    in the equation above is the gamma function,
  prefs: []
  type: TYPE_NORMAL
- en: $\Gamma(\text{input}_i)
    = \int_0^\infty t^{(\text{input}_i-1)} e^{-t} dt.$
    Γ(inputi​)=∫0∞​t(inputi​−1)e−tdt.
  prefs: []
  type: TYPE_NORMAL
- en: See [`torch.special.gammainc()`](#torch.special.gammainc "torch.special.gammainc")
    and [`torch.special.gammaln()`](#torch.special.gammaln "torch.special.gammaln")
    for related functions.
  prefs: []
  type: TYPE_NORMAL
- en: Supports [broadcasting to a common shape](notes/broadcasting.html#broadcasting-semantics)
    and float inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The backward pass with respect to `input` is not yet supported. Please open
    an issue on PyTorch’s Github to request it.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the first
    non-negative input tensor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**other** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the second
    non-negative input tensor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Computes the natural logarithm of the absolute value of the gamma function on
    `input`.
  prefs: []
  type: TYPE_NORMAL
- en: $\text{out}_{i}
    = \ln \Gamma(|\text{input}_{i}|)$ outi​=lnΓ(∣inputi​∣)
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Computes the zeroth order modified Bessel function of the first kind for each
    element of `input`.
  prefs: []
  type: TYPE_NORMAL
- en: $\text{out}_{i} = I_0(\text{input}_{i}) = \sum_{k=0}^{\infty}
    \frac{(\text{input}_{i}^2/4)^k}{(k!)^2}$ outi​=I0​(inputi​)=k=0∑∞​(k!)2(inputi2​/4)k​
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Computes the exponentially scaled zeroth order modified Bessel function of the
    first kind (as defined below) for each element of `input`.
  prefs: []
  type: TYPE_NORMAL
- en: $\text{out}_{i} = \exp(-|x|) * i0(x) = \exp(-|x|)
    * \sum_{k=0}^{\infty} \frac{(\text{input}_{i}^2/4)^k}{(k!)^2}$
    outi​=exp(−∣x∣)∗i0(x)=exp(−∣x∣)∗k=0∑∞​(k!)2(inputi2​/4)k​
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Computes the first order modified Bessel function of the first kind (as defined
    below) for each element of `input`.
  prefs: []
  type: TYPE_NORMAL
- en: $\text{out}_{i}
    = \frac{(\text{input}_{i})}{2} * \sum_{k=0}^{\infty} \frac{(\text{input}_{i}^2/4)^k}{(k!)
    * (k+1)!}$ outi​=2(inputi​)​∗k=0∑∞​(k!)∗(k+1)!(inputi2​/4)k​
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Computes the exponentially scaled first order modified Bessel function of the
    first kind (as defined below) for each element of `input`.
  prefs: []
  type: TYPE_NORMAL
- en: $\text{out}_{i}
    = \exp(-|x|) * i1(x) = \exp(-|x|) * \frac{(\text{input}_{i})}{2} * \sum_{k=0}^{\infty}
    \frac{(\text{input}_{i}^2/4)^k}{(k!) * (k+1)!}$
    outi​=exp(−∣x∣)∗i1(x)=exp(−∣x∣)∗2(inputi​)​∗k=0∑∞​(k!)∗(k+1)!(inputi2​/4)k​
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Alias for [`torch.log1p()`](generated/torch.log1p.html#torch.log1p "torch.log1p").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Computes the log of the area under the standard Gaussian probability density
    function, integrated from minus infinity to `input`, elementwise.
  prefs: []
  type: TYPE_NORMAL
- en: $\text{log\_ndtr}(x)
    = \log\left(\frac{1}{\sqrt{2 \pi}}\int_{-\infty}^{x} e^{-\frac{1}{2}t^2} dt \right)$
    log_ndtr(x)=log(2π​1​∫−∞x​e−21​t2dt)
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Computes softmax followed by a logarithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'While mathematically equivalent to log(softmax(x)), doing these two operations
    separately is slower and numerically unstable. This function is computed as:'
  prefs: []
  type: TYPE_NORMAL
- en: $\text{log\_softmax}(x_{i})
    = \log\left(\frac{\exp(x_i) }{ \sum_j \exp(x_j)} \right)$
    log_softmax(xi​)=log(∑j​exp(xj​)exp(xi​)​)
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dim** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")) – A dimension along which log_softmax will be computed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dtype** ([`torch.dtype`](tensor_attributes.html#torch.dtype "torch.dtype"),
    optional) – the desired data type of returned tensor. If specified, the input
    tensor is cast to `dtype` before the operation is performed. This is useful for
    preventing data type overflows. Default: None.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Returns a new tensor with the logit of the elements of `input`. `input` is clamped
    to [eps, 1 - eps] when eps is not None. When eps is None and `input` < 0 or `input`
    > 1, the function will yields NaN.
  prefs: []
  type: TYPE_NORMAL
- en: $\begin{align} y_{i} &= \ln(\frac{z_{i}}{1 - z_{i}})
    \\ z_{i} &= \begin{cases} x_{i} & \text{if eps is None} \\ \text{eps} & \text{if
    } x_{i} < \text{eps} \\ x_{i} & \text{if } \text{eps} \leq x_{i} \leq 1 - \text{eps}
    \\ 1 - \text{eps} & \text{if } x_{i} > 1 - \text{eps} \end{cases} \end{align}$
    yi​zi​​=ln(1−zi​zi​​)=⎩⎨⎧​xi​epsxi​1−eps​if eps is Noneif xi​<epsif eps≤xi​≤1−epsif xi​>1−eps​​​
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**eps** ([*float*](https://docs.python.org/3/library/functions.html#float "(in
    Python v3.12)")*,* *optional*) – the epsilon for input clamp bound. Default: `None`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Alias for [`torch.logsumexp()`](generated/torch.logsumexp.html#torch.logsumexp
    "torch.logsumexp").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Computes the [multivariate log-gamma function](https://en.wikipedia.org/wiki/Multivariate_gamma_function)
    with dimension $p$p
    element-wise, given by
  prefs: []
  type: TYPE_NORMAL
- en: $\log(\Gamma_{p}(a)) = C + \displaystyle \sum_{i=1}^{p}
    \log\left(\Gamma\left(a - \frac{i - 1}{2}\right)\right)$
    log(Γp​(a))=C+i=1∑p​log(Γ(a−2i−1​))
  prefs: []
  type: TYPE_NORMAL
- en: where $C
    = \log(\pi) \cdot \frac{p (p - 1)}{4}$C=log(π)⋅4p(p−1)​
    and $\Gamma(-)$Γ(−)
    is the Gamma function.
  prefs: []
  type: TYPE_NORMAL
- en: All elements must be greater than $\frac{p - 1}{2}$2p−1​,
    otherwise the behavior is undefiend.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the tensor
    to compute the multivariate log-gamma function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**p** ([*int*](https://docs.python.org/3/library/functions.html#int "(in Python
    v3.12)")) – the number of dimensions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Computes the area under the standard Gaussian probability density function,
    integrated from minus infinity to `input`, elementwise.
  prefs: []
  type: TYPE_NORMAL
- en: $\text{ndtr}(x) = \frac{1}{\sqrt{2 \pi}}\int_{-\infty}^{x}
    e^{-\frac{1}{2}t^2} dt$ ndtr(x)=2π​1​∫−∞x​e−21​t2dt
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Computes the argument, x, for which the area under the Gaussian probability
    density function (integrated from minus infinity to x) is equal to `input`, elementwise.
  prefs: []
  type: TYPE_NORMAL
- en: $\text{ndtri}(p) = \sqrt{2}\text{erf}^{-1}(2p - 1)$
    ndtri(p)=2​erf−1(2p−1)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Also known as quantile function for Normal Distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Computes the $n^{th}$nth derivative
    of the digamma function on `input`. $n \geq 0$n≥0 is called
    the order of the polygamma function.
  prefs: []
  type: TYPE_NORMAL
- en: $\psi^{(n)}(x) = \frac{d^{(n)}}{dx^{(n)}} \psi(x)$
    ψ(n)(x)=dx(n)d(n)​ψ(x)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This function is implemented only for nonnegative integers $n \geq 0$n≥0.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**n** ([*int*](https://docs.python.org/3/library/functions.html#int "(in Python
    v3.12)")) – the order of the polygamma function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Alias for [`torch.special.digamma()`](#torch.special.digamma "torch.special.digamma").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Alias for [`torch.round()`](generated/torch.round.html#torch.round "torch.round").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Scaled modified Bessel function of the second kind of order $0$0.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Scaled modified Bessel function of the second kind of order $1$1.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Computes the normalized sinc of `input.`
  prefs: []
  type: TYPE_NORMAL
- en: $\text{out}_{i} = \begin{cases} 1, & \text{if}\ \text{input}_{i}=0
    \\ \sin(\pi \text{input}_{i}) / (\pi \text{input}_{i}), & \text{otherwise} \end{cases}$
    outi​={1,sin(πinputi​)/(πinputi​),​if inputi​=0otherwise​
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Computes the softmax function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Softmax is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: $\text{Softmax}(x_{i}) = \frac{\exp(x_i)}{\sum_j \exp(x_j)}$Softmax(xi​)=∑j​exp(xj​)exp(xi​)​
  prefs: []
  type: TYPE_NORMAL
- en: It is applied to all slices along dim, and will re-scale them so that the elements
    lie in the range [0, 1] and sum to 1.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dim** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")) – A dimension along which softmax will be computed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dtype** ([`torch.dtype`](tensor_attributes.html#torch.dtype "torch.dtype"),
    optional) – the desired data type of returned tensor. If specified, the input
    tensor is cast to `dtype` before the operation is performed. This is useful for
    preventing data type overflows. Default: None.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Spherical Bessel function of the first kind of order $0$0.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Computes `input * log1p(other)` with the following cases.
  prefs: []
  type: TYPE_NORMAL
- en: $\text{out}_{i} = \begin{cases} \text{NaN} & \text{if
    } \text{other}_{i} = \text{NaN} \\ 0 & \text{if } \text{input}_{i} = 0.0 \text{
    and } \text{other}_{i} != \text{NaN} \\ \text{input}_{i} * \text{log1p}(\text{other}_{i})&
    \text{otherwise} \end{cases}$ outi​=⎩⎨⎧​NaN0inputi​∗log1p(otheri​)​if otheri​=NaNif inputi​=0.0 and otheri​!=NaNotherwise​
  prefs: []
  type: TYPE_NORMAL
- en: Similar to SciPy’s scipy.special.xlog1py.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** (*Number* *or* [*Tensor*](tensors.html#torch.Tensor "torch.Tensor"))
    – Multiplier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**other** (*Number* *or* [*Tensor*](tensors.html#torch.Tensor "torch.Tensor"))
    – Argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At least one of `input` or `other` must be a tensor.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Computes `input * log(other)` with the following cases.
  prefs: []
  type: TYPE_NORMAL
- en: $\text{out}_{i} = \begin{cases} \text{NaN} & \text{if
    } \text{other}_{i} = \text{NaN} \\ 0 & \text{if } \text{input}_{i} = 0.0 \\ \text{input}_{i}
    * \log{(\text{other}_{i})} & \text{otherwise} \end{cases}$
    outi​=⎩⎨⎧​NaN0inputi​∗log(otheri​)​if otheri​=NaNif inputi​=0.0otherwise​
  prefs: []
  type: TYPE_NORMAL
- en: Similar to SciPy’s scipy.special.xlogy.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** (*Number* *or* [*Tensor*](tensors.html#torch.Tensor "torch.Tensor"))
    – Multiplier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**other** (*Number* *or* [*Tensor*](tensors.html#torch.Tensor "torch.Tensor"))
    – Argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At least one of `input` or `other` must be a tensor.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Computes the Hurwitz zeta function, elementwise.
  prefs: []
  type: TYPE_NORMAL
- en: $\zeta(x,
    q) = \sum_{k=0}^{\infty} \frac{1}{(k + q)^x}$ ζ(x,q)=k=0∑∞​(k+q)x1​
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor corresponding to x.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**other** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – the input
    tensor corresponding to q.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The Riemann zeta function corresponds to the case when q = 1
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Arguments
  prefs: []
  type: TYPE_NORMAL
- en: '**out** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*,* *optional*)
    – the output tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
