["```py\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\n\nclass ToyModel([nn.Module](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module \"torch.nn.Module\")):\n    def __init__(self):\n        super([ToyModel](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module \"torch.nn.Module\"), self).__init__()\n        self.net1 = [torch.nn.Linear](https://pytorch.org/docs/stable/generated/torch.nn.Linear.html#torch.nn.Linear \"torch.nn.Linear\")(10, 10).to('cuda:0')\n        self.relu = [torch.nn.ReLU](https://pytorch.org/docs/stable/generated/torch.nn.ReLU.html#torch.nn.ReLU \"torch.nn.ReLU\")()\n        self.net2 = [torch.nn.Linear](https://pytorch.org/docs/stable/generated/torch.nn.Linear.html#torch.nn.Linear \"torch.nn.Linear\")(10, 5).to('cuda:1')\n\n    def forward(self, x):\n        x = self.relu(self.net1(x.to('cuda:0')))\n        return self.net2(x.to('cuda:1')) \n```", "```py\nmodel = [ToyModel](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module \"torch.nn.Module\")()\n[loss_fn](https://pytorch.org/docs/stable/generated/torch.nn.MSELoss.html#torch.nn.MSELoss \"torch.nn.MSELoss\") = [nn.MSELoss](https://pytorch.org/docs/stable/generated/torch.nn.MSELoss.html#torch.nn.MSELoss \"torch.nn.MSELoss\")()\n[optimizer](https://pytorch.org/docs/stable/generated/torch.optim.SGD.html#torch.optim.SGD \"torch.optim.SGD\") = [optim.SGD](https://pytorch.org/docs/stable/generated/torch.optim.SGD.html#torch.optim.SGD \"torch.optim.SGD\")([model.parameters](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module.parameters \"torch.nn.Module.parameters\")(), lr=0.001)\n\n[optimizer.zero_grad](https://pytorch.org/docs/stable/generated/torch.optim.SGD.html#torch.optim.SGD.zero_grad \"torch.optim.SGD.zero_grad\")()\n[outputs](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = model([torch.randn](https://pytorch.org/docs/stable/generated/torch.randn.html#torch.randn \"torch.randn\")(20, 10))\n[labels](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = [torch.randn](https://pytorch.org/docs/stable/generated/torch.randn.html#torch.randn \"torch.randn\")(20, 5).to('cuda:1')\n[loss_fn](https://pytorch.org/docs/stable/generated/torch.nn.MSELoss.html#torch.nn.MSELoss \"torch.nn.MSELoss\")([outputs](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [labels](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")).backward()\n[optimizer.step](https://pytorch.org/docs/stable/generated/torch.optim.SGD.html#torch.optim.SGD.step \"torch.optim.SGD.step\")() \n```", "```py\nfrom torchvision.models.resnet import [ResNet](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module \"torch.nn.Module\"), [Bottleneck](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module \"torch.nn.Module\")\n\nnum_classes = 1000\n\nclass ModelParallelResNet50([ResNet](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module \"torch.nn.Module\")):\n    def __init__(self, *args, **kwargs):\n        super([ModelParallelResNet50](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module \"torch.nn.Module\"), self).__init__(\n            [Bottleneck](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module \"torch.nn.Module\"), [3, 4, 6, 3], num_classes=num_classes, *args, **kwargs)\n\n        self.seq1 = [nn.Sequential](https://pytorch.org/docs/stable/generated/torch.nn.Sequential.html#torch.nn.Sequential \"torch.nn.Sequential\")(\n            self.conv1,\n            self.bn1,\n            self.relu,\n            self.maxpool,\n\n            self.layer1,\n            self.layer2\n        ).to('cuda:0')\n\n        self.seq2 = [nn.Sequential](https://pytorch.org/docs/stable/generated/torch.nn.Sequential.html#torch.nn.Sequential \"torch.nn.Sequential\")(\n            self.layer3,\n            self.layer4,\n            self.avgpool,\n        ).to('cuda:1')\n\n        self.fc.to('cuda:1')\n\n    def forward(self, x):\n        x = self.seq2(self.seq1(x).to('cuda:1'))\n        return self.fc(x.view(x.size(0), -1)) \n```", "```py\nimport torchvision.models as models\n\nnum_batches = 3\nbatch_size = 120\nimage_w = 128\nimage_h = 128\n\ndef train(model):\n    [model.train](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module.train \"torch.nn.Module.train\")(True)\n    [loss_fn](https://pytorch.org/docs/stable/generated/torch.nn.MSELoss.html#torch.nn.MSELoss \"torch.nn.MSELoss\") = [nn.MSELoss](https://pytorch.org/docs/stable/generated/torch.nn.MSELoss.html#torch.nn.MSELoss \"torch.nn.MSELoss\")()\n    [optimizer](https://pytorch.org/docs/stable/generated/torch.optim.SGD.html#torch.optim.SGD \"torch.optim.SGD\") = [optim.SGD](https://pytorch.org/docs/stable/generated/torch.optim.SGD.html#torch.optim.SGD \"torch.optim.SGD\")([model.parameters](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module.parameters \"torch.nn.Module.parameters\")(), lr=0.001)\n\n    one_hot_indices = torch.LongTensor(batch_size) \\\n                           .random_(0, num_classes) \\\n                           .view(batch_size, 1)\n\n    for _ in range(num_batches):\n        # generate random inputs and labels\n        inputs = [torch.randn](https://pytorch.org/docs/stable/generated/torch.randn.html#torch.randn \"torch.randn\")(batch_size, 3, image_w, image_h)\n        [labels](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = [torch.zeros](https://pytorch.org/docs/stable/generated/torch.zeros.html#torch.zeros \"torch.zeros\")(batch_size, num_classes) \\\n                      .scatter_(1, one_hot_indices, 1)\n\n        # run forward pass\n        [optimizer.zero_grad](https://pytorch.org/docs/stable/generated/torch.optim.SGD.html#torch.optim.SGD.zero_grad \"torch.optim.SGD.zero_grad\")()\n        [outputs](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = model(inputs.to('cuda:0'))\n\n        # run backward pass\n        [labels](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\") = [labels](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\").to([outputs.device](https://pytorch.org/docs/stable/tensor_attributes.html#torch.device \"torch.device\"))\n        [loss_fn](https://pytorch.org/docs/stable/generated/torch.nn.MSELoss.html#torch.nn.MSELoss \"torch.nn.MSELoss\")([outputs](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), [labels](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\")).backward()\n        [optimizer.step](https://pytorch.org/docs/stable/generated/torch.optim.SGD.html#torch.optim.SGD.step \"torch.optim.SGD.step\")() \n```", "```py\nimport matplotlib.pyplot as plt\nplt.switch_backend('Agg')\nimport numpy as np\nimport timeit\n\nnum_repeat = 10\n\nstmt = \"train(model)\"\n\nsetup = \"model = ModelParallelResNet50()\"\nmp_run_times = timeit.repeat(\n    stmt, setup, number=1, repeat=num_repeat, globals=globals())\nmp_mean, mp_std = np.mean(mp_run_times), np.std(mp_run_times)\n\nsetup = \"import torchvision.models as models;\" + \\\n        \"model = models.resnet50(num_classes=num_classes).to('cuda:0')\"\nrn_run_times = timeit.repeat(\n    stmt, setup, number=1, repeat=num_repeat, globals=globals())\nrn_mean, rn_std = np.mean(rn_run_times), np.std(rn_run_times)\n\ndef plot(means, stds, [labels](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"), fig_name):\n    fig, ax = plt.subplots()\n    ax.bar(np.arange(len(means)), means, yerr=stds,\n           align='center', alpha=0.5, ecolor='red', capsize=10, width=0.6)\n    ax.set_ylabel('ResNet50 Execution Time (Second)')\n    ax.set_xticks(np.arange(len(means)))\n    ax.set_xticklabels([labels](https://pytorch.org/docs/stable/tensors.html#torch.Tensor \"torch.Tensor\"))\n    ax.yaxis.grid(True)\n    plt.tight_layout()\n    plt.savefig(fig_name)\n    plt.close(fig)\n\nplot([mp_mean, rn_mean],\n     [mp_std, rn_std],\n     ['Model Parallel', 'Single GPU'],\n     'mp_vs_rn.png') \n```", "```py\nclass PipelineParallelResNet50([ModelParallelResNet50](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module \"torch.nn.Module\")):\n    def __init__(self, split_size=20, *args, **kwargs):\n        super([PipelineParallelResNet50](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module \"torch.nn.Module\"), self).__init__(*args, **kwargs)\n        self.split_size = split_size\n\n    def forward(self, x):\n        splits = iter(x.split(self.split_size, dim=0))\n        s_next = next(splits)\n        s_prev = self.seq1(s_next).to('cuda:1')\n        ret = []\n\n        for s_next in splits:\n            # A. ``s_prev`` runs on ``cuda:1``\n            s_prev = self.seq2(s_prev)\n            ret.append(self.fc(s_prev.view(s_prev.size(0), -1)))\n\n            # B. ``s_next`` runs on ``cuda:0``, which can run concurrently with A\n            s_prev = self.seq1(s_next).to('cuda:1')\n\n        s_prev = self.seq2(s_prev)\n        ret.append(self.fc(s_prev.view(s_prev.size(0), -1)))\n\n        return [torch.cat](https://pytorch.org/docs/stable/generated/torch.cat.html#torch.cat \"torch.cat\")(ret)\n\nsetup = \"model = PipelineParallelResNet50()\"\npp_run_times = timeit.repeat(\n    stmt, setup, number=1, repeat=num_repeat, globals=globals())\npp_mean, pp_std = np.mean(pp_run_times), np.std(pp_run_times)\n\nplot([mp_mean, rn_mean, pp_mean],\n     [mp_std, rn_std, pp_std],\n     ['Model Parallel', 'Single GPU', 'Pipelining Model Parallel'],\n     'mp_vs_rn_vs_pp.png') \n```", "```py\nmeans = []\nstds = []\nsplit_sizes = [1, 3, 5, 8, 10, 12, 20, 40, 60]\n\nfor split_size in split_sizes:\n    setup = \"model = PipelineParallelResNet50(split_size=%d)\" % split_size\n    pp_run_times = timeit.repeat(\n        stmt, setup, number=1, repeat=num_repeat, globals=globals())\n    means.append(np.mean(pp_run_times))\n    stds.append(np.std(pp_run_times))\n\nfig, ax = plt.subplots()\nax.plot(split_sizes, means)\nax.errorbar(split_sizes, means, yerr=stds, ecolor='red', fmt='ro')\nax.set_ylabel('ResNet50 Execution Time (Second)')\nax.set_xlabel('Pipeline Split Size')\nax.set_xticks(split_sizes)\nax.yaxis.grid(True)\nplt.tight_layout()\nplt.savefig(\"split_size_tradeoff.png\")\nplt.close(fig) \n```"]