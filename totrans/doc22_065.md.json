["```py\ntorch.overrides.get_ignored_functions()\u00b6\n```", "```py\n>>> torch.Tensor.as_subclass in torch.overrides.get_ignored_functions()\nTrue\n>>> torch.add in torch.overrides.get_ignored_functions()\nFalse \n```", "```py\ntorch.overrides.get_overridable_functions()\u00b6\n```", "```py\ntorch.overrides.resolve_name(f)\u00b6\n```", "```py\ntorch.overrides.get_testing_overrides()\u00b6\n```", "```py\n>>> import inspect\n>>> my_add = torch.overrides.get_testing_overrides()[torch.add]\n>>> inspect.signature(my_add)\n<Signature (input, other, out=None)> \n```", "```py\ntorch.overrides.handle_torch_function(public_api, relevant_args, *args, **kwargs)\u00b6\n```", "```py\n>>> def func(a):\n...     if has_torch_function_unary(a):\n...         return handle_torch_function(func, (a,), a)\n...     return a + 0 \n```", "```py\ntorch.overrides.has_torch_function()\u00b6\n```", "```py\ntorch.overrides.is_tensor_like(inp)\u00b6\n```", "```py\n>>> class SubTensor(torch.Tensor): ...\n>>> is_tensor_like(SubTensor([0]))\nTrue \n```", "```py\n>>> is_tensor_like(6)\nFalse\n>>> is_tensor_like(None)\nFalse\n>>> class NotATensor: ...\n>>> is_tensor_like(NotATensor())\nFalse \n```", "```py\n>>> class TensorLike:\n...     @classmethod\n...     def __torch_function__(cls, func, types, args, kwargs):\n...         return -1\n>>> is_tensor_like(TensorLike())\nTrue \n```", "```py\ntorch.overrides.is_tensor_method_or_property(func)\u00b6\n```", "```py\n>>> is_tensor_method_or_property(torch.Tensor.add)\nTrue\n>>> is_tensor_method_or_property(torch.add)\nFalse \n```", "```py\ntorch.overrides.wrap_torch_function(dispatcher)\u00b6\n```", "```py\n>>> def dispatcher(a): # Must have the same signature as func\n...     return (a,)\n>>> @torch.overrides.wrap_torch_function(dispatcher)\n>>> def func(a): # This will make func dispatchable by __torch_function__\n...     return a + 0 \n```"]