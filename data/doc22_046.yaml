- en: Distributed communication package - torch.distributed
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式通信包 - torch.distributed
- en: 原文：[https://pytorch.org/docs/stable/distributed.html](https://pytorch.org/docs/stable/distributed.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://pytorch.org/docs/stable/distributed.html](https://pytorch.org/docs/stable/distributed.html)
- en: Note
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please refer to [PyTorch Distributed Overview](https://pytorch.org/tutorials/beginner/dist_overview.html)
    for a brief introduction to all features related to distributed training.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考[PyTorch分布式概述](https://pytorch.org/tutorials/beginner/dist_overview.html)以了解与分布式训练相关的所有功能的简要介绍。
- en: '## Backends'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '## 后端'
- en: '`torch.distributed` supports three built-in backends, each with different capabilities.
    The table below shows which functions are available for use with CPU / CUDA tensors.
    MPI supports CUDA only if the implementation used to build PyTorch supports it.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`torch.distributed`支持三种内置后端，每种具有不同的功能。下表显示了哪些函数可用于CPU / CUDA张量。如果用于构建PyTorch的实现支持，MPI仅支持CUDA。'
- en: '| Backend | `gloo` | `mpi` | `nccl` |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| 后端 | `gloo` | `mpi` | `nccl` |'
- en: '| --- | --- | --- | --- |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Device | CPU | GPU | CPU | GPU | CPU | GPU |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 设备 | CPU | GPU | CPU | GPU | CPU | GPU |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| send | ✓ | ✘ | ✓ | ? | ✘ | ✓ |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| send | ✓ | ✘ | ✓ | ? | ✘ | ✓ |'
- en: '| recv | ✓ | ✘ | ✓ | ? | ✘ | ✓ |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| recv | ✓ | ✘ | ✓ | ? | ✘ | ✓ |'
- en: '| broadcast | ✓ | ✓ | ✓ | ? | ✘ | ✓ |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| broadcast | ✓ | ✓ | ✓ | ? | ✘ | ✓ |'
- en: '| all_reduce | ✓ | ✓ | ✓ | ? | ✘ | ✓ |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| all_reduce | ✓ | ✓ | ✓ | ? | ✘ | ✓ |'
- en: '| reduce | ✓ | ✘ | ✓ | ? | ✘ | ✓ |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| reduce | ✓ | ✘ | ✓ | ? | ✘ | ✓ |'
- en: '| all_gather | ✓ | ✘ | ✓ | ? | ✘ | ✓ |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| all_gather | ✓ | ✘ | ✓ | ? | ✘ | ✓ |'
- en: '| gather | ✓ | ✘ | ✓ | ? | ✘ | ✓ |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| gather | ✓ | ✘ | ✓ | ? | ✘ | ✓ |'
- en: '| scatter | ✓ | ✘ | ✓ | ? | ✘ | ✓ |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| scatter | ✓ | ✘ | ✓ | ? | ✘ | ✓ |'
- en: '| reduce_scatter | ✘ | ✘ | ✘ | ✘ | ✘ | ✓ |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| reduce_scatter | ✘ | ✘ | ✘ | ✘ | ✘ | ✓ |'
- en: '| all_to_all | ✘ | ✘ | ✓ | ? | ✘ | ✓ |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| all_to_all | ✘ | ✘ | ✓ | ? | ✘ | ✓ |'
- en: '| barrier | ✓ | ✘ | ✓ | ? | ✘ | ✓ |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| barrier | ✓ | ✘ | ✓ | ? | ✘ | ✓ |'
- en: Backends that come with PyTorch[](#backends-that-come-with-pytorch "Permalink
    to this heading")
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PyTorch附带的后端[](#backends-that-come-with-pytorch "跳转到此标题")
- en: PyTorch distributed package supports Linux (stable), MacOS (stable), and Windows
    (prototype). By default for Linux, the Gloo and NCCL backends are built and included
    in PyTorch distributed (NCCL only when building with CUDA). MPI is an optional
    backend that can only be included if you build PyTorch from source. (e.g. building
    PyTorch on a host that has MPI installed.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: PyTorch分布式包支持Linux（稳定）、MacOS（稳定）和Windows（原型）。默认情况下，对于Linux，Gloo和NCCL后端已构建并包含在PyTorch分布式中（仅在使用CUDA构建时才包括NCCL）。MPI是一个可选的后端，只有在从源代码构建PyTorch时才能包含（例如，在安装了MPI的主机上构建PyTorch）。
- en: Note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'As of PyTorch v1.8, Windows supports all collective communications backend
    but NCCL, If the init_method argument of [`init_process_group()`](#torch.distributed.init_process_group
    "torch.distributed.init_process_group") points to a file it must adhere to the
    following schema:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 截至PyTorch v1.8，Windows支持所有集体通信后端，但不支持NCCL，如果[`init_process_group()`](#torch.distributed.init_process_group
    "torch.distributed.init_process_group")的init_method参数指向文件，则必须遵循以下模式：
- en: Local file system, `init_method="file:///d:/tmp/some_file"`
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地文件系统，`init_method="file:///d:/tmp/some_file"`
- en: Shared file system, `init_method="file://////{machine_name}/{share_folder_name}/some_file"`
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享文件系统，`init_method="file://////{machine_name}/{share_folder_name}/some_file"`
- en: Same as on Linux platform, you can enable TcpStore by setting environment variables,
    MASTER_ADDR and MASTER_PORT.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与Linux平台相同，您可以通过设置环境变量MASTER_ADDR和MASTER_PORT来启用TcpStore。
- en: Which backend to use?
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应该使用哪个后端？
- en: 'In the past, we were often asked: “which backend should I use?”.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，我们经常被问到：“我应该使用哪个后端？”。
- en: Rule of thumb
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经验法则
- en: Use the NCCL backend for distributed **GPU** training
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NCCL后端进行分布式**GPU**训练
- en: Use the Gloo backend for distributed **CPU** training.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gloo后端进行分布式**CPU**训练。
- en: GPU hosts with InfiniBand interconnect
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有InfiniBand互连的GPU主机
- en: Use NCCL, since it’s the only backend that currently supports InfiniBand and
    GPUDirect.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NCCL，因为它是目前唯一支持InfiniBand和GPUDirect的后端。
- en: GPU hosts with Ethernet interconnect
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有以太网互连的GPU主机
- en: Use NCCL, since it currently provides the best distributed GPU training performance,
    especially for multiprocess single-node or multi-node distributed training. If
    you encounter any problem with NCCL, use Gloo as the fallback option. (Note that
    Gloo currently runs slower than NCCL for GPUs.)
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NCCL，因为它目前提供了最佳的分布式GPU训练性能，特别适用于多进程单节点或多节点分布式训练。如果遇到任何NCCL问题，请使用Gloo作为备选方案。（请注意，目前Gloo在GPU上运行速度比NCCL慢。）
- en: CPU hosts with InfiniBand interconnect
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有InfiniBand互连的CPU主机
- en: If your InfiniBand has enabled IP over IB, use Gloo, otherwise, use MPI instead.
    We are planning on adding InfiniBand support for Gloo in the upcoming releases.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的InfiniBand启用了IP over IB，请使用Gloo，否则请使用MPI。我们计划在即将发布的版本中为Gloo添加InfiniBand支持。
- en: CPU hosts with Ethernet interconnect
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有以太网互连的CPU主机
- en: Use Gloo, unless you have specific reasons to use MPI.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非有特定原因要使用MPI，否则请使用Gloo。
- en: Common environment variables[](#common-environment-variables "Permalink to this
    heading")
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见环境变量[](#common-environment-variables "跳转到此标题")
- en: Choosing the network interface to use[](#choosing-the-network-interface-to-use
    "Permalink to this heading")
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择要使用的网络接口[](#choosing-the-network-interface-to-use "跳转到此标题")
- en: 'By default, both the NCCL and Gloo backends will try to find the right network
    interface to use. If the automatically detected interface is not correct, you
    can override it using the following environment variables (applicable to the respective
    backend):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，NCCL和Gloo后端都会尝试找到正确的网络接口。如果自动检测到的接口不正确，您可以使用以下环境变量覆盖它（适用于相应的后端）：
- en: '**NCCL_SOCKET_IFNAME**, for example `export NCCL_SOCKET_IFNAME=eth0`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NCCL_SOCKET_IFNAME**，例如`export NCCL_SOCKET_IFNAME=eth0`'
- en: '**GLOO_SOCKET_IFNAME**, for example `export GLOO_SOCKET_IFNAME=eth0`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GLOO_SOCKET_IFNAME**，例如`export GLOO_SOCKET_IFNAME=eth0`'
- en: 'If you’re using the Gloo backend, you can specify multiple interfaces by separating
    them by a comma, like this: `export GLOO_SOCKET_IFNAME=eth0,eth1,eth2,eth3`. The
    backend will dispatch operations in a round-robin fashion across these interfaces.
    It is imperative that all processes specify the same number of interfaces in this
    variable.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Gloo后端，可以通过逗号分隔它们来指定多个接口，就像这样：`export GLOO_SOCKET_IFNAME=eth0,eth1,eth2,eth3`。后端将在这些接口之间以循环方式分发操作。所有进程在此变量中指定相同数量的接口是至关重要的。
- en: Other NCCL environment variables[](#other-nccl-environment-variables "Permalink
    to this heading")
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他NCCL环境变量
- en: '**Debugging** - in case of NCCL failure, you can set `NCCL_DEBUG=INFO` to print
    an explicit warning message as well as basic NCCL initialization information.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试** - 在NCCL失败的情况下，您可以设置`NCCL_DEBUG=INFO`来打印明确的警告消息以及基本的NCCL初始化信息。'
- en: You may also use `NCCL_DEBUG_SUBSYS` to get more details about a specific aspect
    of NCCL. For example, `NCCL_DEBUG_SUBSYS=COLL` would print logs of collective
    calls, which may be helpful when debugging hangs, especially those caused by collective
    type or message size mismatch. In case of topology detection failure, it would
    be helpful to set `NCCL_DEBUG_SUBSYS=GRAPH` to inspect the detailed detection
    result and save as reference if further help from NCCL team is needed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`NCCL_DEBUG_SUBSYS`来获取有关NCCL特定方面的更多详细信息。例如，`NCCL_DEBUG_SUBSYS=COLL`将打印集体调用的日志，这在调试挂起时可能会有所帮助，特别是由于集体类型或消息大小不匹配而引起的情况。在拓扑检测失败的情况下，设置`NCCL_DEBUG_SUBSYS=GRAPH`以检查详细的检测结果，并在需要NCCL团队进一步帮助时保存为参考是有帮助的。
- en: '**Performance tuning** - NCCL performs automatic tuning based on its topology
    detection to save users’ tuning effort. On some socket-based systems, users may
    still try tuning `NCCL_SOCKET_NTHREADS` and `NCCL_NSOCKS_PERTHREAD` to increase
    socket network bandwidth. These two environment variables have been pre-tuned
    by NCCL for some cloud providers, such as AWS or GCP.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能调优** - NCCL根据其拓扑检测执行自动调优，以节省用户的调优工作。在某些基于套接字的系统上，用户仍可以尝试调整`NCCL_SOCKET_NTHREADS`和`NCCL_NSOCKS_PERTHREAD`以增加套接字网络带宽。这两个环境变量已经被NCCL预调整，适用于一些云服务提供商，如AWS或GCP。'
- en: For a full list of NCCL environment variables, please refer to [NVIDIA NCCL’s
    official documentation](https://docs.nvidia.com/deeplearning/sdk/nccl-developer-guide/docs/env.html)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有关NCCL环境变量的完整列表，请参考[NVIDIA NCCL官方文档](https://docs.nvidia.com/deeplearning/sdk/nccl-developer-guide/docs/env.html)
- en: '## Basics'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 基础知识
- en: The torch.distributed package provides PyTorch support and communication primitives
    for multiprocess parallelism across several computation nodes running on one or
    more machines. The class [`torch.nn.parallel.DistributedDataParallel()`](generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel
    "torch.nn.parallel.DistributedDataParallel") builds on this functionality to provide
    synchronous distributed training as a wrapper around any PyTorch model. This differs
    from the kinds of parallelism provided by [Multiprocessing package - torch.multiprocessing](multiprocessing.html)
    and [`torch.nn.DataParallel()`](generated/torch.nn.DataParallel.html#torch.nn.DataParallel
    "torch.nn.DataParallel") in that it supports multiple network-connected machines
    and in that the user must explicitly launch a separate copy of the main training
    script for each process.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: torch.distributed包提供了PyTorch支持和通信原语，用于在一个或多个机器上运行的多进程并行计算节点之间的支持。类[`torch.nn.parallel.DistributedDataParallel()`](generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel
    "torch.nn.parallel.DistributedDataParallel")基于此功能构建，以提供同步分布式训练作为任何PyTorch模型的包装器。这与[Multiprocessing
    package - torch.multiprocessing](multiprocessing.html)和[`torch.nn.DataParallel()`](generated/torch.nn.DataParallel.html#torch.nn.DataParallel
    "torch.nn.DataParallel")提供的并行方式不同，它支持多个网络连接的机器，并且用户必须显式启动主训练脚本的每个进程的单独副本。
- en: 'In the single-machine synchronous case, torch.distributed or the [`torch.nn.parallel.DistributedDataParallel()`](generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel
    "torch.nn.parallel.DistributedDataParallel") wrapper may still have advantages
    over other approaches to data-parallelism, including [`torch.nn.DataParallel()`](generated/torch.nn.DataParallel.html#torch.nn.DataParallel
    "torch.nn.DataParallel"):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在单机同步情况下，torch.distributed或[`torch.nn.parallel.DistributedDataParallel()`](generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel
    "torch.nn.parallel.DistributedDataParallel")包装器可能仍然比其他数据并行方法具有优势，包括[`torch.nn.DataParallel()`](generated/torch.nn.DataParallel.html#torch.nn.DataParallel
    "torch.nn.DataParallel")：
- en: Each process maintains its own optimizer and performs a complete optimization
    step with each iteration. While this may appear redundant, since the gradients
    have already been gathered together and averaged across processes and are thus
    the same for every process, this means that no parameter broadcast step is needed,
    reducing time spent transferring tensors between nodes.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个进程维护自己的优化器，并在每次迭代中执行完整的优化步骤。虽然这可能看起来是多余的，因为梯度已经被收集并在进程之间平均化，因此对于每个进程来说是相同的，但这意味着不需要参数广播步骤，减少了在节点之间传输张量所花费的时间。
- en: Each process contains an independent Python interpreter, eliminating the extra
    interpreter overhead and “GIL-thrashing” that comes from driving several execution
    threads, model replicas, or GPUs from a single Python process. This is especially
    important for models that make heavy use of the Python runtime, including models
    with recurrent layers or many small components.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个进程包含一个独立的Python解释器，消除了从单个Python进程驱动多个执行线程、模型副本或GPU时产生的额外解释器开销和“GIL-thrashing”。这对于大量使用Python运行时的模型特别重要，包括具有循环层或许多小组件的模型。
- en: Initialization
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化
- en: The package needs to be initialized using the [`torch.distributed.init_process_group()`](#torch.distributed.init_process_group
    "torch.distributed.init_process_group") or [`torch.distributed.device_mesh.init_device_mesh()`](#torch.distributed.device_mesh.init_device_mesh
    "torch.distributed.device_mesh.init_device_mesh") function before calling any
    other methods. Both block until all processes have joined.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用任何其他方法之前，需要使用[`torch.distributed.init_process_group()`](#torch.distributed.init_process_group
    "torch.distributed.init_process_group")或[`torch.distributed.device_mesh.init_device_mesh()`](#torch.distributed.device_mesh.init_device_mesh
    "torch.distributed.device_mesh.init_device_mesh")函数初始化包。两者都会阻塞，直到所有进程都加入。
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Return `True` if the distributed package is available.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分布式包可用，则返回`True`。
- en: Otherwise, `torch.distributed` does not expose any other APIs. Currently, `torch.distributed`
    is available on Linux, MacOS and Windows. Set `USE_DISTRIBUTED=1` to enable it
    when building PyTorch from source. Currently, the default value is `USE_DISTRIBUTED=1`
    for Linux and Windows, `USE_DISTRIBUTED=0` for MacOS.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，`torch.distributed`不公开任何其他API。目前，`torch.distributed`在Linux、MacOS和Windows上可用。在构建PyTorch时，设置`USE_DISTRIBUTED=1`以启用它。目前，默认值为Linux和Windows为`USE_DISTRIBUTED=1`，MacOS为`USE_DISTRIBUTED=0`。
- en: Return type
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.12)")'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[bool]'
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Initialize the default distributed process group.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化默认的分布式进程组。
- en: This will also initialize the distributed package.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将初始化分布式包。
- en: 'There are 2 main ways to initialize a process group:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要初始化进程组的方法：
- en: Specify `store`, `rank`, and `world_size` explicitly.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 明确指定`store`、`rank`和`world_size`。
- en: Specify `init_method` (a URL string) which indicates where/how to discover peers.
    Optionally specify `rank` and `world_size`, or encode all required parameters
    in the URL and omit them.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定`init_method`（一个URL字符串），指示在哪里/如何发现对等体。可选地指定`rank`和`world_size`，或在URL中编码所有必需的参数并省略它们。
- en: If neither is specified, `init_method` is assumed to be “env://”.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定，则假定`init_method`为“env://”。
- en: Parameters
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**backend** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)") *or* [*Backend*](#torch.distributed.Backend "torch.distributed.Backend")*,*
    *optional*) – The backend to use. Depending on build-time configurations, valid
    values include `mpi`, `gloo`, `nccl`, and `ucc`. If the backend is not provided,
    then both a `gloo` and `nccl` backend will be created, see notes below for how
    multiple backends are managed. This field can be given as a lowercase string (e.g.,
    `"gloo"`), which can also be accessed via [`Backend`](#torch.distributed.Backend
    "torch.distributed.Backend") attributes (e.g., `Backend.GLOO`). If using multiple
    processes per machine with `nccl` backend, each process must have exclusive access
    to every GPU it uses, as sharing GPUs between processes can result in deadlocks.
    `ucc` backend is experimental.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**backend**（*str*或*Backend*，可选） - 要使用的后端。根据构建时的配置，有效值包括`mpi`、`gloo`、`nccl`和`ucc`。如果未提供后端，则将创建`gloo`和`nccl`后端，有关如何管理多个后端的说明，请参见下面的注释。此字段可以作为小写字符串（例如，`"gloo"`）给出，也可以通过[`Backend`](#torch.distributed.Backend
    "torch.distributed.Backend")属性（例如，`Backend.GLOO`）访问。如果使用`nccl`后端的每个机器上的多个进程，每个进程必须独占使用它使用的每个GPU，因为在进程之间共享GPU可能导致死锁。`ucc`后端是实验性的。'
- en: '**init_method** ([*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*,* *optional*) – URL specifying how to initialize the process
    group. Default is “env://” if no `init_method` or `store` is specified. Mutually
    exclusive with `store`.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**init_method**（*str*，可选） - 指定如何初始化进程组的URL。如果未指定`init_method`或`store`，则默认为“env://”。与`store`互斥。'
- en: '**world_size** ([*int*](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.12)")*,* *optional*) – Number of processes participating in the
    job. Required if `store` is specified.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**world_size**（*int*，可选） - 参与作业的进程数。如果指定了`store`，则需要。'
- en: '**rank** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")*,* *optional*) – Rank of the current process (it should be a number
    between 0 and `world_size`-1). Required if `store` is specified.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rank**（*int*，可选） - 当前进程的等级（应为0到`world_size`-1之间的数字）。如果指定了`store`，则需要。'
- en: '**store** ([*Store*](#torch.distributed.Store "torch.distributed.Store")*,*
    *optional*) – Key/value store accessible to all workers, used to exchange connection/address
    information. Mutually exclusive with `init_method`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**store**（*Store*，可选） - 所有工作进程都可以访问的键/值存储，用于交换连接/地址信息。与`init_method`互斥。'
- en: '**timeout** (*timedelta**,* *optional*) – Timeout for operations executed against
    the process group. Default value is 10 minutes for NCCL and 30 minutes for other
    backends. This is the duration after which collectives will be aborted asynchronously
    and the process will crash. This is done since CUDA execution is async and it
    is no longer safe to continue executing user code since failed async NCCL operations
    might result in subsequent CUDA operations running on corrupted data. When TORCH_NCCL_BLOCKING_WAIT
    is set, the process will block and wait for this timeout.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**timeout**（*timedelta*，可选） - 对执行的操作的超时时间。NCCL的默认值为10分钟，其他后端为30分钟。这是在此持续时间后异步中止集合，并且进程将崩溃。这是因为CUDA执行是异步的，不再安全继续执行用户代码，因为失败的异步NCCL操作可能导致后续CUDA操作在损坏的数据上运行。当设置TORCH_NCCL_BLOCKING_WAIT时，进程将阻塞并等待此超时。'
- en: '**group_name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*,* *optional**,* *deprecated*) – Group name. This argument
    is ignored'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group_name**（*str*，可选，已弃用） - 组名。此参数将被忽略'
- en: '**pg_options** (*ProcessGroupOptions**,* *optional*) – process group options
    specifying what additional options need to be passed in during the construction
    of specific process groups. As of now, the only options we support is `ProcessGroupNCCL.Options`
    for the `nccl` backend, `is_high_priority_stream` can be specified so that the
    nccl backend can pick up high priority cuda streams when there’re compute kernels
    waiting.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pg_options**（*ProcessGroupOptions**,* *可选*） - 指定在构建特定进程组时需要传递的其他选项的进程组选项。目前，我们支持的唯一选项是`ProcessGroupNCCL.Options`用于`nccl`后端，可以指定`is_high_priority_stream`，以便nccl后端可以在有计算内核等待时选择高优先级的cuda流。'
- en: Note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To enable `backend == Backend.MPI`, PyTorch needs to be built from source on
    a system that supports MPI.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用`backend == Backend.MPI`，PyTorch需要在支持MPI的系统上从源代码构建。
- en: Note
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Support for multiple backends is experimental. Currently when no backend is
    specified, both `gloo` and `nccl` backends will be created. The `gloo` backend
    will be used for collectives with CPU tensors and the `nccl` backend will be used
    for collectives with CUDA tensors. A custom backend can be specified by passing
    in a string with format “<device_type>:<backend_name>,<device_type>:<backend_name>”,
    e.g. “cpu:gloo,cuda:custom_backend”.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 支持多个后端是实验性的。当前，当未指定后端时，将创建`gloo`和`nccl`后端。`gloo`后端将用于CPU张量的集合，`nccl`后端将用于CUDA张量的集合。可以通过传入格式为“<device_type>:<backend_name>,<device_type>:<backend_name>”的字符串来指定自定义后端，例如“cpu:gloo,cuda:custom_backend”。
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Initializes a DeviceMesh based on device_type, mesh_shape, and mesh_dim_names
    parameters.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 根据device_type、mesh_shape和mesh_dim_names参数初始化一个DeviceMesh。
- en: This creates a DeviceMesh with an n-dimensional array layout, where n is the
    length of mesh_shape. If mesh_dim_names is provided, each dimension is labeled
    as mesh_dim_names[i].
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个具有n维数组布局的DeviceMesh，其中n是mesh_shape的长度。如果提供了mesh_dim_names，则每个维度都标记为mesh_dim_names[i]。
- en: Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: init_device_mesh follows SPMD programming model, meaning the same PyTorch Python
    program runs on all processes/ranks in the cluster. Ensure mesh_shape (the dimensions
    of the nD array describing device layout) is identical across all ranks. Inconsistent
    mesh_shape may lead to hanging.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: init_device_mesh遵循SPMD编程模型，这意味着相同的PyTorch Python程序在集群中的所有进程/排名上运行。确保mesh_shape（描述设备布局的nD数组的维度）在所有排名上都是相同的。不一致的mesh_shape可能导致挂起。
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If no process group is found, init_device_mesh will initialize distributed process
    group/groups required for distributed communications behind the scene.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未找到任何进程组，则init_device_mesh将在幕后初始化分布式通信所需的分布式进程组/组。
- en: Parameters
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**device_type** ([*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")) – The device type of the mesh. Currently supports: “cpu”,
    “cuda/cuda-like”.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**device_type**（[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(在Python v3.12中)")） - 网格的设备类型。目前支持："cpu"、"cuda/cuda-like"。'
- en: '**mesh_shape** (*Tuple**[*[*int*](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.12)")*]*) – A tuple defining the dimensions of the multi-dimensional
    array describing the layout of devices.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mesh_shape**（*Tuple**[*[*int*](https://docs.python.org/3/library/functions.html#int
    "(在Python v3.12中)")*]*) - 一个定义描述设备布局的多维数组的维度的元组。'
- en: '**mesh_dim_names** (*Tuple**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*]**,* *optional*) – A tuple of mesh dimension names to assign
    to each dimension of the multi-dimensional array describing the layout of devices.
    Its length must match the length of mesh_shape. Each string in mesh_dim_names
    must be unique.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mesh_dim_names**（*Tuple**[*[*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(在Python v3.12中)")*]**,* *可选*） - 一个元组，包含要分配给描述设备布局的多维数组的每个维度的网格维度名称。其长度必须与mesh_shape的长度相匹配。mesh_dim_names中的每个字符串必须是唯一的。'
- en: Returns
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: A [`DeviceMesh`](#torch.distributed.device_mesh.DeviceMesh "torch.distributed.device_mesh.DeviceMesh")
    object representing the device layout.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个[`DeviceMesh`](#torch.distributed.device_mesh.DeviceMesh "torch.distributed.device_mesh.DeviceMesh")对象，表示设备布局。
- en: Return type
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[DeviceMesh](#torch.distributed.device_mesh.DeviceMesh "torch.distributed.device_mesh.DeviceMesh")'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[DeviceMesh](#torch.distributed.device_mesh.DeviceMesh "torch.distributed.device_mesh.DeviceMesh")'
- en: 'Example::'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '示例::'
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Check if the default process group has been initialized.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 检查默认进程组是否已初始化。
- en: Return type
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.12)")'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[bool](https://docs.python.org/3/library/functions.html#bool "(在Python v3.12中)")'
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Check if the MPI backend is available.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 检查MPI后端是否可用。
- en: Return type
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.12)")'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[bool](https://docs.python.org/3/library/functions.html#bool "(在Python v3.12中)")'
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Check if the NCCL backend is available.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 检查NCCL后端是否可用。
- en: Return type
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.12)")'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[bool](https://docs.python.org/3/library/functions.html#bool "(在Python v3.12中)")'
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Check if the Gloo backend is available.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 检查Gloo后端是否可用。
- en: Return type
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.12)")'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[bool](https://docs.python.org/3/library/functions.html#bool "(在Python v3.12中)")'
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Check whether this process was launched with `torch.distributed.elastic` (aka
    torchelastic).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 检查此进程是否是使用`torch.distributed.elastic`（又名torchelastic）启动的。
- en: The existence of `TORCHELASTIC_RUN_ID` environment variable is used as a proxy
    to determine whether the current process was launched with torchelastic. This
    is a reasonable proxy since `TORCHELASTIC_RUN_ID` maps to the rendezvous id which
    is always a non-null value indicating the job id for peer discovery purposes..
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`TORCHELASTIC_RUN_ID`环境变量的存在用作代理，以确定当前进程是否是使用torchelastic启动的。这是一个合理的代理，因为`TORCHELASTIC_RUN_ID`映射到总会是非空值的会合id，指示对等发现目的的作业id。'
- en: Return type
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.12)")'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[bool](https://docs.python.org/3/library/functions.html#bool "(在Python v3.12中)")'
- en: '* * *'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Currently three initialization methods are supported:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 目前支持三种初始化方法：
- en: TCP initialization
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP初始化
- en: There are two ways to initialize using TCP, both requiring a network address
    reachable from all processes and a desired `world_size`. The first way requires
    specifying an address that belongs to the rank 0 process. This initialization
    method requires that all processes have manually specified ranks.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种使用TCP进行初始化的方法，都需要一个所有进程都可以访问的网络地址和一个期望的`world_size`。第一种方法需要指定属于rank 0进程的地址。这种初始化方法要求所有进程都手动指定了rank。
- en: Note that multicast address is not supported anymore in the latest distributed
    package. `group_name` is deprecated as well.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在最新的分布式包中不再支持多播地址。`group_name`也已被弃用。
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Shared file-system initialization[](#shared-file-system-initialization "Permalink
    to this heading")
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享文件系统初始化
- en: Another initialization method makes use of a file system that is shared and
    visible from all machines in a group, along with a desired `world_size`. The URL
    should start with `file://` and contain a path to a non-existent file (in an existing
    directory) on a shared file system. File-system initialization will automatically
    create that file if it doesn’t exist, but will not delete the file. Therefore,
    it is your responsibility to make sure that the file is cleaned up before the
    next [`init_process_group()`](#torch.distributed.init_process_group "torch.distributed.init_process_group")
    call on the same file path/name.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种初始化方法利用了一个共享的文件系统，该文件系统对所有机器可见，并且具有所需的`world_size`。URL应以`file://`开头，并包含指向共享文件系统上不存在文件（在现有目录中）的路径。文件系统初始化将自动创建该文件（如果不存在），但不会删除该文件。因此，在下次在相同文件路径/名称上调用`init_process_group()`之前，您有责任确保清理文件。
- en: Note that automatic rank assignment is not supported anymore in the latest distributed
    package and `group_name` is deprecated as well.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在最新的分布式包中不再支持自动分配rank，`group_name`也已被弃用。
- en: Warning
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: This method assumes that the file system supports locking using `fcntl` - most
    local systems and NFS support it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法假定文件系统支持使用`fcntl`进行锁定 - 大多数本地系统和NFS都支持它。
- en: Warning
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: This method will always create the file and try its best to clean up and remove
    the file at the end of the program. In other words, each initialization with the
    file init method will need a brand new empty file in order for the initialization
    to succeed. If the same file used by the previous initialization (which happens
    not to get cleaned up) is used again, this is unexpected behavior and can often
    cause deadlocks and failures. Therefore, even though this method will try its
    best to clean up the file, if the auto-delete happens to be unsuccessful, it is
    your responsibility to ensure that the file is removed at the end of the training
    to prevent the same file to be reused again during the next time. This is especially
    important if you plan to call [`init_process_group()`](#torch.distributed.init_process_group
    "torch.distributed.init_process_group") multiple times on the same file name.
    In other words, if the file is not removed/cleaned up and you call [`init_process_group()`](#torch.distributed.init_process_group
    "torch.distributed.init_process_group") again on that file, failures are expected.
    The rule of thumb here is that, make sure that the file is non-existent or empty
    every time [`init_process_group()`](#torch.distributed.init_process_group "torch.distributed.init_process_group")
    is called.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将始终创建文件，并尽力在程序结束时清理和删除文件。换句话说，每次使用文件初始化方法进行初始化时，都需要一个全新的空文件才能成功初始化。如果再次使用之前初始化时使用的相同文件（未被清理）则会导致意外行为，通常会导致死锁和失败。因此，即使这种方法会尽力清理文件，如果自动删除失败，您有责任确保在训练结束时删除文件，以防止下次再次重用相同的文件。如果您计划在相同的文件名上多次调用`init_process_group()`，这一点尤为重要。换句话说，如果文件未被删除/清理，并且您再次在该文件上调用`init_process_group()`，则可能会导致失败。这里的经验法则是，确保每次调用`init_process_group()`时文件不存在或为空。
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Environment variable initialization[](#environment-variable-initialization "Permalink
    to this heading")
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境变量初始化
- en: 'This method will read the configuration from environment variables, allowing
    one to fully customize how the information is obtained. The variables to be set
    are:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将从环境变量中读取配置，允许完全自定义信息的获取方式。需要设置的变量包括：
- en: '`MASTER_PORT` - required; has to be a free port on machine with rank 0'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MASTER_PORT` - 必需；必须是rank 0机器上的空闲端口'
- en: '`MASTER_ADDR` - required (except for rank 0); address of rank 0 node'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MASTER_ADDR` - 必需（除了rank 0）；rank 0节点的地址'
- en: '`WORLD_SIZE` - required; can be set either here, or in a call to init function'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORLD_SIZE` - 必需；可以在这里设置，也可以在调用初始化函数时设置'
- en: '`RANK` - required; can be set either here, or in a call to init function'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RANK` - 必需；可以在这里设置，也可以在调用初始化函数时设置'
- en: The machine with rank 0 will be used to set up all connections.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: rank 0的机器将用于建立所有连接。
- en: This is the default method, meaning that `init_method` does not have to be specified
    (or can be `env://`).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认方法，意味着不必指定`init_method`（或者可以是`env://`）。
- en: Post-Initialization
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化后
- en: Once [`torch.distributed.init_process_group()`](#torch.distributed.init_process_group
    "torch.distributed.init_process_group") was run, the following functions can be
    used. To check whether the process group has already been initialized use [`torch.distributed.is_initialized()`](#torch.distributed.is_initialized
    "torch.distributed.is_initialized").
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行了`torch.distributed.init_process_group()`，就可以使用以下函数。要检查进程组是否已经初始化，请使用`torch.distributed.is_initialized()`。
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: An enum-like class for backends.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 用于后端的类似枚举的类。
- en: 'Available backends: GLOO, NCCL, UCC, MPI, and other registered backends.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的后端：GLOO、NCCL、UCC、MPI和其他已注册的后端。
- en: The values of this class are lowercase strings, e.g., `"gloo"`. They can be
    accessed as attributes, e.g., `Backend.NCCL`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此类的值是小写字符串，例如`"gloo"`。它们可以作为属性访问，例如`Backend.NCCL`。
- en: This class can be directly called to parse the string, e.g., `Backend(backend_str)`
    will check if `backend_str` is valid, and return the parsed lowercase string if
    so. It also accepts uppercase strings, e.g., `Backend("GLOO")` returns `"gloo"`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类可以直接调用以解析字符串，例如，`Backend(backend_str)`将检查`backend_str`是否有效，如果有效，则返回解析后的小写字符串。它也接受大写字符串，例如，`Backend("GLOO")`返回`"gloo"`。
- en: Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The entry `Backend.UNDEFINED` is present but only used as initial value of some
    fields. Users should neither use it directly nor assume its existence.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 条目`Backend.UNDEFINED`存在，但仅用作某些字段的初始值。用户既不应直接使用它，也不应假定其存在。
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Register a new backend with the given name and instantiating function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用给定名称和实例化函数注册新后端。
- en: This class method is used by 3rd party `ProcessGroup` extension to register
    new backends.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此类方法由第三方`ProcessGroup`扩展用于注册新后端。
- en: Parameters
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – Backend name of the `ProcessGroup` extension. It should match
    the one in `init_process_group()`.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**name**（[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python
    v3.12)")）- `ProcessGroup`扩展的后端名称。它应与`init_process_group()`中的名称匹配。'
- en: '**func** (*function*) – Function handler that instantiates the backend. The
    function should be implemented in the backend extension and takes four arguments,
    including `store`, `rank`, `world_size`, and `timeout`.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**func**（*函数*）- 实例化后端的函数处理程序。该函数应在后端扩展中实现，并接受四个参数，包括`store`，`rank`，`world_size`和`timeout`。'
- en: '**extended_api** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – Whether the backend supports extended argument
    structure. Default: `False`. If set to `True`, the backend will get an instance
    of `c10d::DistributedBackendOptions`, and a process group options object as defined
    by the backend implementation.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**extended_api**（[*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *可选*）- 后端是否支持扩展参数结构。默认值：`False`。如果设置为`True`，后端将获得一个`c10d::DistributedBackendOptions`实例，以及由后端实现定义的进程组选项对象。'
- en: '**device** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)") *or* [*list*](https://docs.python.org/3/library/stdtypes.html#list
    "(in Python v3.12)") *of* [*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*,* *optional*) – device type this backend supports, e.g.
    “cpu”, “cuda”, etc. If None, assuming both “cpu” and “cuda”'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**device**（[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)") *或* [*list*](https://docs.python.org/3/library/stdtypes.html#list
    "(in Python v3.12)") *of* [*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")*,* *可选*）- 此后端支持的设备类型，例如“cpu”，“cuda”等。如果为None，则假定同时支持“cpu”和“cuda”。'
- en: Note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This support of 3rd party backend is experimental and subject to change.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方后端支持是实验性的，可能会发生变化。
- en: '[PRE13]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Return the backend of the given process group.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 返回给定进程组的后端。
- en: Parameters
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**group** (*ProcessGroup**,* *optional*) – The process group to work on. The
    default is the general main process group. If another specific group is specified,
    the calling process must be part of `group`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**group**（*ProcessGroup**,* *可选*）- 要处理的进程组。默认为一般的主进程组。如果指定了另一个特定组，则调用进程必须是`group`的一部分。'
- en: Returns
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: The backend of the given process group as a lower case string.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 给定进程组的后端作为小写字符串。
- en: Return type
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.12)")'
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Return the rank of the current process in the provided `group`, default otherwise.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 返回提供的`group`中当前进程的等级，否则默认。
- en: Rank is a unique identifier assigned to each process within a distributed process
    group. They are always consecutive integers ranging from 0 to `world_size`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 等级是分布式进程组中每个进程分配的唯一标识符。它们始终是从0到`world_size`的连续整数。
- en: Parameters
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**group** (*ProcessGroup**,* *optional*) – The process group to work on. If
    None, the default process group will be used.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**group**（*ProcessGroup**,* *可选*）- 要处理的进程组。如果为None，则将使用默认进程组。'
- en: Returns
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: The rank of the process group -1, if not part of the group
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是组的一部分，则进程组的等级为-1
- en: Return type
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")'
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Return the number of processes in the current process group.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 返回当前进程组中的进程数。
- en: Parameters
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**group** (*ProcessGroup**,* *optional*) – The process group to work on. If
    None, the default process group will be used.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**group**（*ProcessGroup**,* *可选*）- 要处理的进程组。如果为None，则将使用默认进程组。'
- en: Returns
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: The world size of the process group -1, if not part of the group
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 进程组的世界大小为-1，如果不是组的一部分
- en: Return type
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")'
- en: '* * *'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Distributed Key-Value Store[](#distributed-key-value-store "Permalink to this
    heading")
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式键值存储[](#distributed-key-value-store "跳转到此标题")
- en: 'The distributed package comes with a distributed key-value store, which can
    be used to share information between processes in the group as well as to initialize
    the distributed package in [`torch.distributed.init_process_group()`](#torch.distributed.init_process_group
    "torch.distributed.init_process_group") (by explicitly creating the store as an
    alternative to specifying `init_method`.) There are 3 choices for Key-Value Stores:
    [`TCPStore`](#torch.distributed.TCPStore "torch.distributed.TCPStore"), [`FileStore`](#torch.distributed.FileStore
    "torch.distributed.FileStore"), and [`HashStore`](#torch.distributed.HashStore
    "torch.distributed.HashStore").'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式包带有一个分布式键值存储，可用于在组中的进程之间共享信息，以及在[`torch.distributed.init_process_group()`](#torch.distributed.init_process_group
    "torch.distributed.init_process_group")中初始化分布式包（通过显式创建存储作为指定`init_method`的替代方法）。有3种键值存储选择：[`TCPStore`](#torch.distributed.TCPStore
    "torch.distributed.TCPStore")，[`FileStore`](#torch.distributed.FileStore "torch.distributed.FileStore")和[`HashStore`](#torch.distributed.HashStore
    "torch.distributed.HashStore")。
- en: '[PRE16]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Base class for all store implementations, such as the 3 provided by PyTorch
    distributed: ([`TCPStore`](#torch.distributed.TCPStore "torch.distributed.TCPStore"),
    [`FileStore`](#torch.distributed.FileStore "torch.distributed.FileStore"), and
    [`HashStore`](#torch.distributed.HashStore "torch.distributed.HashStore")).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 所有存储实现的基类，例如PyTorch分布式提供的3个存储：（[`TCPStore`](#torch.distributed.TCPStore "torch.distributed.TCPStore")，[`FileStore`](#torch.distributed.FileStore
    "torch.distributed.FileStore")和[`HashStore`](#torch.distributed.HashStore "torch.distributed.HashStore")）。
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A TCP-based distributed key-value store implementation. The server store holds
    the data, while the client stores can connect to the server store over TCP and
    perform actions such as `set()` to insert a key-value pair, `get()` to retrieve
    a key-value pair, etc. There should always be one server store initialized because
    the client store(s) will wait for the server to establish a connection.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 基于TCP的分布式键值存储实现。服务器存储保存数据，而客户端存储可以通过TCP连接到服务器存储并执行诸如`set()`（插入键值对）、`get()`（检索键值对）等操作。应始终初始化一个服务器存储，因为客户端存储将等待服务器建立连接。
- en: Parameters
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**host_name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")) – The hostname or IP Address the server store should run
    on.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**host_name**（[*str*](https://docs.python.org/3/library/stdtypes.html#str "(在Python
    v3.12中)")） - 服务器存储应运行的主机名或IP地址。'
- en: '**port** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")) – The port on which the server store should listen for incoming
    requests.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口**（[*int*](https://docs.python.org/3/library/functions.html#int "(在Python
    v3.12中)")） - 服务器存储应监听传入请求的端口。'
- en: '**world_size** ([*int*](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.12)")*,* *optional*) – The total number of store users (number
    of clients + 1 for the server). Default is None (None indicates a non-fixed number
    of store users).'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**world_size**（[*int*](https://docs.python.org/3/library/functions.html#int
    "(在Python v3.12中)")，*可选*） - 存储用户的总数（客户端数量+1为服务器）。默认值为None（None表示存储用户数量不固定）。'
- en: '**is_master** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – True when initializing the server store
    and False for client stores. Default is False.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**is_master**（[*bool*](https://docs.python.org/3/library/functions.html#bool
    "(在Python v3.12中)")，*可选*） - 在初始化服务器存储时为True，对于客户端存储为False。默认值为False。'
- en: '**timeout** (*timedelta**,* *optional*) – Timeout used by the store during
    initialization and for methods such as `get()` and `wait()`. Default is timedelta(seconds=300)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超时**（*timedelta**，*可选*） - 存储在初始化期间和诸如`get()`和`wait()`等方法中使用的超时。默认值为timedelta(seconds=300)'
- en: '**wait_for_workers** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – Whether to wait for all the workers to connect
    with the server store. This is only applicable when world_size is a fixed value.
    Default is True.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wait_for_workers**（[*bool*](https://docs.python.org/3/library/functions.html#bool
    "(在Python v3.12中)")，*可选*） - 是否等待所有工作进程连接到服务器存储。仅当world_size是固定值时才适用。默认值为True。'
- en: '**multi_tenant** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – If True, all `TCPStore` instances in the
    current process with the same host/port will use the same underlying `TCPServer`.
    Default is False.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**multi_tenant**（[*bool*](https://docs.python.org/3/library/functions.html#bool
    "(在Python v3.12中)")，*可选*） - 如果为True，则当前进程中所有具有相同主机/端口的`TCPStore`实例将使用相同的底层`TCPServer`。默认值为False。'
- en: '**master_listen_fd** ([*int*](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.12)")*,* *optional*) – If specified, the underlying `TCPServer`
    will listen on this file descriptor, which must be a socket already bound to `port`.
    Useful to avoid port assignment races in some scenarios. Default is None (meaning
    the server creates a new socket and attempts to bind it to `port`).'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**master_listen_fd**（[*int*](https://docs.python.org/3/library/functions.html#int
    "(在Python v3.12中)")，*可选*） - 如果指定，底层的`TCPServer`将在此文件描述符上监听，该描述符必须是已绑定到`port`的套接字。在某些情况下，有助于避免端口分配竞争。默认值为None（表示服务器创建一个新套接字并尝试将其绑定到`port`）。'
- en: 'Example::'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '示例::'
- en: '[PRE18]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A thread-safe store implementation based on an underlying hashmap. This store
    can be used within the same process (for example, by other threads), but cannot
    be used across processes.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 基于底层哈希映射的线程安全存储实现。此存储可以在同一进程中使用（例如，由其他线程），但不能跨进程使用。
- en: 'Example::'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '示例::'
- en: '[PRE20]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A store implementation that uses a file to store the underlying key-value pairs.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文件存储底层键值对的存储实现。
- en: Parameters
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**file_name** ([*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")) – path of the file in which to store the key-value pairs'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**file_name**（[*str*](https://docs.python.org/3/library/stdtypes.html#str "(在Python
    v3.12中)")） - 存储键值对的文件路径'
- en: '**world_size** ([*int*](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.12)")*,* *optional*) – The total number of processes using the
    store. Default is -1 (a negative value indicates a non-fixed number of store users).'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**world_size**（[*int*](https://docs.python.org/3/library/functions.html#int
    "(在Python v3.12中)")，*可选*） - 使用存储的进程总数。默认值为-1（负值表示存储用户数量不固定）。'
- en: 'Example::'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '示例::'
- en: '[PRE22]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A wrapper around any of the 3 key-value stores ([`TCPStore`](#torch.distributed.TCPStore
    "torch.distributed.TCPStore"), [`FileStore`](#torch.distributed.FileStore "torch.distributed.FileStore"),
    and [`HashStore`](#torch.distributed.HashStore "torch.distributed.HashStore"))
    that adds a prefix to each key inserted to the store.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对任何3个键值存储（[`TCPStore`](#torch.distributed.TCPStore "torch.distributed.TCPStore")，[`FileStore`](#torch.distributed.FileStore
    "torch.distributed.FileStore")和[`HashStore`](#torch.distributed.HashStore "torch.distributed.HashStore")）的包装，将前缀添加到插入存储的每个键。
- en: Parameters
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**prefix** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – The prefix string that is prepended to each key before being
    inserted into the store.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前缀**（[*str*](https://docs.python.org/3/library/stdtypes.html#str "(在Python
    v3.12中)")） - 在插入存储之前添加到每个键的前缀字符串。'
- en: '**store** (*torch.distributed.store*) – A store object that forms the underlying
    key-value store.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**store**（*torch.distributed.store*） - 形成底层键值存储的存储对象。'
- en: '[PRE24]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Inserts the key-value pair into the store based on the supplied `key` and `value`.
    If `key` already exists in the store, it will overwrite the old value with the
    new supplied `value`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 根据提供的`key`和`value`将键值对插入存储。如果`key`已经存在于存储中，则将旧值用新提供的`value`覆盖。
- en: Parameters
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**key** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python
    v3.12)")) – The key to be added to the store.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**key** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(在Python
    v3.12中)")) - 要添加到存储中的键。'
- en: '**value** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)")) – The value associated with `key` to be added to the store.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**value** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(在Python
    v3.12中)")) - 要添加到存储中的与`key`关联的值。'
- en: 'Example::'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '示例::'
- en: '[PRE25]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Retrieves the value associated with the given `key` in the store. If `key` is
    not present in the store, the function will wait for `timeout`, which is defined
    when initializing the store, before throwing an exception.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 检索存储中与给定`key`关联的值。如果`key`不在存储中，则函数将等待`timeout`，在初始化存储时定义，然后抛出异常。
- en: Parameters
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**key** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python
    v3.12)")) – The function will return the value associated with this key.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**key** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(在Python
    v3.12中)")) - 函数将返回与此键关联的值。'
- en: Returns
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: Value associated with `key` if `key` is in the store.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`key`在存储中，则与`key`关联的值。
- en: 'Example::'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '示例::'
- en: '[PRE27]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first call to add for a given `key` creates a counter associated with `key`
    in the store, initialized to `amount`. Subsequent calls to add with the same `key`
    increment the counter by the specified `amount`. Calling `add()` with a key that
    has already been set in the store by `set()` will result in an exception.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的`key`，第一次调用`add`会在存储中创建与`key`关联的计数器，初始化为`amount`。后续使用相同`key`调用`add`会将计数器递增指定的`amount`。对已经通过`set()`在存储中设置的键调用`add()`将导致异常。
- en: Parameters
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**key** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python
    v3.12)")) – The key in the store whose counter will be incremented.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**key** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(在Python
    v3.12中)")) - 将增加计数器的存储中的键。'
- en: '**amount** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")) – The quantity by which the counter will be incremented.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**amount** ([*int*](https://docs.python.org/3/library/functions.html#int "(在Python
    v3.12中)")) - 计数器将增加的数量。'
- en: 'Example::'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '示例::'
- en: '[PRE29]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Inserts the key-value pair into the store based on the supplied `key` and performs
    comparison between `expected_value` and `desired_value` before inserting. `desired_value`
    will only be set if `expected_value` for the `key` already exists in the store
    or if `expected_value` is an empty string.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 根据提供的`key`将键值对插入存储，并在插入之前执行`expected_value`和`desired_value`之间的比较。只有当存储中已经存在`key`的`expected_value`或`expected_value`为空字符串时，才会设置`desired_value`。
- en: Parameters
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**key** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python
    v3.12)")) – The key to be checked in the store.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**key** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(在Python
    v3.12中)")) - 要在存储中检查的键。'
- en: '**expected_value** ([*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")) – The value associated with `key` to be checked before insertion.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**expected_value** ([*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(在Python v3.12中)")) - 在插入之前要检查与`key`关联的值。'
- en: '**desired_value** ([*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")) – The value associated with `key` to be added to the store.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**desired_value** ([*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(在Python v3.12中)")) - 要添加到存储中的与`key`关联的值。'
- en: 'Example::'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '示例::'
- en: '[PRE31]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Overloaded function.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 重载函数。
- en: 'wait(self: torch._C._distributed_c10d.Store, arg0: List[str]) -> None'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'wait(self: torch._C._distributed_c10d.Store, arg0: List[str]) -> None'
- en: Waits for each key in `keys` to be added to the store. If not all keys are set
    before the `timeout` (set during store initialization), then `wait` will throw
    an exception.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 等待将`keys`中的每个键添加到存储中。如果在`timeout`（在存储初始化期间设置）之前未设置所有键，则`wait`将抛出异常。
- en: Parameters
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**keys** ([*list*](https://docs.python.org/3/library/stdtypes.html#list "(in
    Python v3.12)")) – List of keys on which to wait until they are set in the store.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**keys** ([*list*](https://docs.python.org/3/library/stdtypes.html#list "(在Python
    v3.12中)")) - 等待直到它们在存储中设置的键列表。'
- en: 'Example::'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '示例::'
- en: '[PRE33]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'wait(self: torch._C._distributed_c10d.Store, arg0: List[str], arg1: datetime.timedelta)
    -> None'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'wait(self: torch._C._distributed_c10d.Store, arg0: List[str], arg1: datetime.timedelta)
    -> None'
- en: Waits for each key in `keys` to be added to the store, and throws an exception
    if the keys have not been set by the supplied `timeout`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 等待将`keys`中的每个键添加到存储中，如果在提供的`timeout`之前未设置键，则抛出异常。
- en: Parameters
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**keys** ([*list*](https://docs.python.org/3/library/stdtypes.html#list "(in
    Python v3.12)")) – List of keys on which to wait until they are set in the store.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**keys** ([*list*](https://docs.python.org/3/library/stdtypes.html#list "(在Python
    v3.12中)")) - 等待直到它们在存储中设置的键列表。'
- en: '**timeout** (*timedelta*) – Time to wait for the keys to be added before throwing
    an exception.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**timeout** (*timedelta*) - 等待键添加到存储中的时间，然后抛出异常。'
- en: 'Example::'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '示例::'
- en: '[PRE34]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Returns the number of keys set in the store. Note that this number will typically
    be one greater than the number of keys added by `set()` and `add()` since one
    key is used to coordinate all the workers using the store.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 返回存储中设置的键数。请注意，此数字通常比`set()`和`add()`添加的键数多一个，因为一个键用于协调使用存储的所有工作进程。
- en: Warning
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: When used with the [`TCPStore`](#torch.distributed.TCPStore "torch.distributed.TCPStore"),
    `num_keys` returns the number of keys written to the underlying file. If the store
    is destructed and another store is created with the same file, the original keys
    will be retained.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当与[`TCPStore`](#torch.distributed.TCPStore "torch.distributed.TCPStore")一起使用时，`num_keys`返回写入基础文件的键数。如果销毁存储并创建具有相同文件的另一个存储，则原始键将保留。
- en: Returns
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: The number of keys present in the store.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 存储中存在的键数。
- en: 'Example::'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '示例::'
- en: '[PRE36]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Deletes the key-value pair associated with `key` from the store. Returns true
    if the key was successfully deleted, and false if it was not.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 从存储中删除与`key`关联的键值对。如果成功删除键，则返回true，如果未成功删除，则返回false。
- en: Warning
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The `delete_key` API is only supported by the [`TCPStore`](#torch.distributed.TCPStore
    "torch.distributed.TCPStore") and [`HashStore`](#torch.distributed.HashStore "torch.distributed.HashStore").
    Using this API with the [`FileStore`](#torch.distributed.FileStore "torch.distributed.FileStore")
    will result in an exception.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete_key` API仅由[`TCPStore`](#torch.distributed.TCPStore "torch.distributed.TCPStore")和[`HashStore`](#torch.distributed.HashStore
    "torch.distributed.HashStore")支持。在[`FileStore`](#torch.distributed.FileStore "torch.distributed.FileStore")中使用此API将导致异常。'
- en: Parameters
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**key** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python
    v3.12)")) – The key to be deleted from the store'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**key**（[*str*](https://docs.python.org/3/library/stdtypes.html#str "(在Python
    v3.12中)")） - 要从存储中删除的键'
- en: Returns
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: True if `key` was deleted, otherwise False.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功删除`key`，则为True，否则为False。
- en: 'Example::'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '示例::'
- en: '[PRE38]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Sets the store’s default timeout. This timeout is used during initialization
    and in `wait()` and `get()`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 设置存储的默认超时时间。此超时时间在初始化和`wait()`以及`get()`中使用。
- en: Parameters
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**timeout** (*timedelta*) – timeout to be set in the store.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**timeout**（*timedelta*） - 要在存储中设置的超时时间。'
- en: 'Example::'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '示例::'
- en: '[PRE40]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Groups
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组
- en: By default collectives operate on the default group (also called the world)
    and require all processes to enter the distributed function call. However, some
    workloads can benefit from more fine-grained communication. This is where distributed
    groups come into play. [`new_group()`](#torch.distributed.new_group "torch.distributed.new_group")
    function can be used to create new groups, with arbitrary subsets of all processes.
    It returns an opaque group handle that can be given as a `group` argument to all
    collectives (collectives are distributed functions to exchange information in
    certain well-known programming patterns).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，集体操作在默认组（也称为全局组）上运行，并要求所有进程进入分布式函数调用。但是，某些工作负载可以从更精细的通信中受益。这就是分布式组发挥作用的地方。[`new_group()`](#torch.distributed.new_group
    "torch.distributed.new_group")函数可用于创建新组，其中包含所有进程的任意子集。它返回一个不透明的组句柄，可以作为所有集体操作的`group`参数传递（集体操作是在某些众所周知的编程模式中交换信息的分布式函数）。
- en: '[PRE41]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Create a new distributed group.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的分布式组。
- en: This function requires that all processes in the main group (i.e. all processes
    that are part of the distributed job) enter this function, even if they are not
    going to be members of the group. Additionally, groups should be created in the
    same order in all processes.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数要求主组中的所有进程（即分布式作业的所有进程）进入此函数，即使它们不打算成为该组的成员。此外，应在所有进程中以相同顺序创建组。
- en: Warning
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Using multiple process groups with the `NCCL` backend concurrently is not safe
    and the user should perform explicit synchronization in their application to ensure
    only one process group is used at a time. This means collectives from one process
    group should have completed execution on the device (not just enqueued since CUDA
    execution is async) before collectives from another process group are enqueued.
    See [Using multiple NCCL communicators concurrently](https://docs.nvidia.com/deeplearning/nccl/user-guide/docs/usage/communicators.html#using-multiple-nccl-communicators-concurrently)
    for more details.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 同时使用具有`NCCL`后端的多个进程组是不安全的，用户应在其应用程序中执行显式同步，以确保一次只使用一个进程组。这意味着一个进程组的集体操作应在设备上完成执行（而不仅仅是入队，因为CUDA执行是异步的），然后才能入队另一个进程组的集体操作。有关更多详细信息，请参阅[同时使用多个NCCL通信器](https://docs.nvidia.com/deeplearning/nccl/user-guide/docs/usage/communicators.html#using-multiple-nccl-communicators-concurrently)。
- en: Parameters
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**ranks** ([*list*](https://docs.python.org/3/library/stdtypes.html#list "(in
    Python v3.12)")*[*[*int*](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.12)")*]*) – List of ranks of group members. If `None`, will be
    set to all ranks. Default is `None`.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ranks**（[*list*](https://docs.python.org/3/library/stdtypes.html#list "(在Python
    v3.12中)")*[*[*int*](https://docs.python.org/3/library/functions.html#int "(在Python
    v3.12中)")*]*) - 组成员的排名列表。如果为`None`，将设置为所有排名。默认为`None`。'
- en: '**timeout** (*timedelta**,* *optional*) – see init_process_group for details
    and default value.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**timeout**（*timedelta**,* *可选*) - 有关详细信息和默认值，请参见init_process_group。'
- en: '**backend** ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in
    Python v3.12)") *or* [*Backend*](#torch.distributed.Backend "torch.distributed.Backend")*,*
    *optional*) – The backend to use. Depending on build-time configurations, valid
    values are `gloo` and `nccl`. By default uses the same backend as the global group.
    This field should be given as a lowercase string (e.g., `"gloo"`), which can also
    be accessed via [`Backend`](#torch.distributed.Backend "torch.distributed.Backend")
    attributes (e.g., `Backend.GLOO`). If `None` is passed in, the backend corresponding
    to the default process group will be used. Default is `None`.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**backend**（[*str*](https://docs.python.org/3/library/stdtypes.html#str "(在Python
    v3.12中)") *或* [*Backend*](#torch.distributed.Backend "torch.distributed.Backend")*,*
    *可选*) - 要使用的后端。根据构建时的配置，有效值为`gloo`和`nccl`。默认情况下使用与全局组相同的后端。此字段应作为小写字符串（例如，`"gloo"`）给出，也可以通过[`Backend`](#torch.distributed.Backend
    "torch.distributed.Backend")属性（例如，`Backend.GLOO`）访问。如果传入`None`，将使用与默认进程组对应的后端。默认为`None`。'
- en: '**pg_options** (*ProcessGroupOptions**,* *optional*) – process group options
    specifying what additional options need to be passed in during the construction
    of specific process groups. i.e. for the `nccl` backend, `is_high_priority_stream`
    can be specified so that process group can pick up high priority cuda streams.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pg_options**（*ProcessGroupOptions**,* *可选*) - 指定在构建特定进程组时需要传递的其他选项的进程组选项。例如，对于`nccl`后端，可以指定`is_high_priority_stream`，以便进程组可以选择高优先级的cuda流。'
- en: '**use_local_synchronization** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – perform a group-local barrier at the end
    of the process group creation. This is different in that non-member ranks don’t
    need to call into API and don’t join the barrier.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**use_local_synchronization** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(在 Python v3.12 中)")*,* *可选*) - 在进程组创建结束时执行组本地屏障。这与非成员排名不需要调用 API 并且不加入屏障不同。'
- en: Returns
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值
- en: A handle of distributed group that can be given to collective calls or None
    if the rank is not part of `ranks`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 一个分布式组的句柄，可以提供给集体调用，如果排名不在 `ranks` 中，则返回 None。
- en: N.B. use_local_synchronization doesn’t work with MPI.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`use_local_synchronization` 与 MPI 不兼容。
- en: N.B. While use_local_synchronization=True can be significantly faster with larger
    clusters and small process groups, care must be taken since it changes cluster
    behavior as non-member ranks don’t join the group barrier().
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：虽然 `use_local_synchronization=True` 在较大集群和小进程组中可以显著提高速度，但必须小心，因为它会改变集群行为，非成员排名不会加入组屏障。
- en: N.B. use_local_synchronization=True can lead to deadlocks when each rank creates
    multiple overlaping process groups. To avoid that, make sure all ranks follow
    the same global creation order.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当每个排名创建多个重叠进程组时，`use_local_synchronization=True` 可能会导致死锁。为避免这种情况，请确保所有排名遵循相同的全局创建顺序。
- en: '[PRE42]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Translate a global rank into a group rank.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 将全局排名转换为组排名。
- en: '`global_rank` must be part of `group` otherwise this raises RuntimeError.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `global_rank` 必须是 `group` 的一部分，否则会引发 RuntimeError。
- en: Parameters
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**group** (*ProcessGroup*) – ProcessGroup to find the relative rank.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group** (*ProcessGroup*) - 要查找相对排名的进程组。'
- en: '**global_rank** ([*int*](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.12)")) – Global rank to query.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**global_rank** ([*int*](https://docs.python.org/3/library/functions.html#int
    "(在 Python v3.12 中)")) - 要查询的全局排名。'
- en: Returns
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值
- en: Group rank of `global_rank` relative to `group`
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`group` 相对于 `group` 的组排名'
- en: Return type
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '[int](https://docs.python.org/3/library/functions.html#int "(在 Python v3.12
    中)")'
- en: N.B. calling this function on the default process group returns identity
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在默认进程组上调用此函数会返回身份
- en: '[PRE43]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Translate a group rank into a global rank.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 将组排名转换为全局排名。
- en: '`group_rank` must be part of group otherwise this raises RuntimeError.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `group_rank` 必须是组的一部分，否则会引发 RuntimeError。
- en: Parameters
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**group** (*ProcessGroup*) – ProcessGroup to find the global rank from.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group** (*ProcessGroup*) - 要从中找到全局排名的进程组。'
- en: '**group_rank** ([*int*](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.12)")) – Group rank to query.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group_rank** ([*int*](https://docs.python.org/3/library/functions.html#int
    "(在 Python v3.12 中)")) - 要查询的组排名。'
- en: Returns
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值
- en: Global rank of `group_rank` relative to `group`
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`group_rank` 相对于 `group` 的全局排名'
- en: Return type
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '[int](https://docs.python.org/3/library/functions.html#int "(在 Python v3.12
    中)")'
- en: N.B. calling this function on the default process group returns identity
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在默认进程组上调用此函数会返回身份
- en: '[PRE44]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Get all ranks associated with `group`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 获取与 `group` 关联的所有排名。
- en: Parameters
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**group** (*ProcessGroup*) – ProcessGroup to get all ranks from.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**group** (*ProcessGroup*) - 要获取所有排名的进程组。'
- en: Returns
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值
- en: List of global ranks ordered by group rank.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 按组排名排序的全局排名列表。
- en: DeviceMesh
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DeviceMesh
- en: DeviceMesh is a higher level abstraction that manages process groups (or NCCL
    communicators). It allows user to easily create inter node and intra node process
    groups without worrying about how to set up the ranks correctly for different
    sub process groups, and it helps manage those distributed process group easily.
    [`init_device_mesh()`](#torch.distributed.device_mesh.init_device_mesh "torch.distributed.device_mesh.init_device_mesh")
    function can be used to create new DeviceMesh, with a mesh shape describing the
    device topology.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: DeviceMesh 是一个更高级的抽象，管理进程组（或 NCCL 通信器）。它允许用户轻松创建节点间和节点内的进程组，而无需担心如何为不同的子进程组正确设置排名，并且它有助于轻松管理这些分布式进程组。[`init_device_mesh()`](#torch.distributed.device_mesh.init_device_mesh
    "torch.distributed.device_mesh.init_device_mesh") 函数可用于创建新的 DeviceMesh，其中包含描述设备拓扑的网格形状。
- en: '[PRE45]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: DeviceMesh represents a mesh of devices, where layout of devices could be represented
    as a n-d dimension array, and each value of the n-d dimensional array is the global
    id of the default process group ranks.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: DeviceMesh 表示设备的网格，其中设备的布局可以表示为 n-d 维度数组，n-d 维度数组的每个值是默认进程组排名的全局 id。
- en: DeviceMesh could be used to describe the layout of devices across the cluster,
    and serves as a proxy for communication among the device lists within the cluster.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: DeviceMesh 可以用于描述集群中设备的布局，并作为集群内设备列表之间通信的代理。
- en: DeviceMesh can be used as a context manager.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: DeviceMesh 可以用作上下文管理器。
- en: Note
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: DeviceMesh follows SPMD programming model, which means the same PyTorch Python
    program is running on all processes/ranks in the cluster. Therefore, users need
    to make sure the mesh array (which describes the layout of devices) should be
    identical across all ranks. Inconsistent mesh will lead to silent hang.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: DeviceMesh 遵循 SPMD 编程模型，这意味着相同的 PyTorch Python 程序在集群中的所有进程/排名上运行。因此，用户需要确保网格数组（描述设备布局）在所有排名中都是相同的。不一致的网格会导致潜在的挂起。
- en: Parameters
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**device_type** ([*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)")) – The device type of the mesh. Currently supports: “cpu”,
    “cuda/cuda-like”.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**device_type** ([*str*](https://docs.python.org/3/library/stdtypes.html#str
    "(在 Python v3.12 中)")) - 网格的设备类型。目前支持："cpu"，"cuda/cuda-like"。'
- en: '**mesh** (*ndarray*) – A multi-dimensional array or an integer tensor describing
    the layout of devices, where the IDs are global IDs of the default process group.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mesh** (*ndarray*) - 描述设备布局的多维数组或整数张量，其中 ID 是默认进程组的全局 ID。'
- en: Returns
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值
- en: A [`DeviceMesh`](#torch.distributed.device_mesh.DeviceMesh "torch.distributed.device_mesh.DeviceMesh")
    object representing the device layout.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 表示设备布局的 [`DeviceMesh`](#torch.distributed.device_mesh.DeviceMesh "torch.distributed.device_mesh.DeviceMesh")
    对象。
- en: Return type
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[DeviceMesh](#torch.distributed.device_mesh.DeviceMesh "torch.distributed.device_mesh.DeviceMesh")'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: DeviceMesh
- en: The following program runs on each process/rank in an SPMD manner. In this example,
    we have 2 hosts with 4 GPUs each. A reduction over the first dimension of mesh
    will reduce across columns (0, 4), .. and (3, 7), a reduction over the second
    dimension of mesh reduces across rows (0, 1, 2, 3) and (4, 5, 6, 7).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序以 SPMD 方式在每个进程/等级上运行。在这个例子中，我们有2个主机，每个主机有4个GPU。对网格的第一维进行归约将横跨列（0, 4），..
    和（3, 7），对网格的第二维进行归约将横跨行（0, 1, 2, 3）和（4, 5, 6, 7）。
- en: 'Example::'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE46]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Point-to-point communication[](#point-to-point-communication "Permalink to this
    heading")
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点对点通信
- en: '[PRE47]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Send a tensor synchronously.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 同步发送张量。
- en: Parameters
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**tensor** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – Tensor
    to send.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tensor**（*Tensor*）- 要发送的张量。'
- en: '**dst** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")) – Destination rank. Destination rank should not be the same as
    the rank of the current process.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dst**（*int*）- 目标等级。目标等级不应与当前进程的等级相同。'
- en: '**group** (*ProcessGroup**,* *optional*) – The process group to work on. If
    None, the default process group will be used.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group**（*ProcessGroup*，可选）- 要操作的进程组。如果为None，则将使用默认进程组。'
- en: '**tag** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")*,* *optional*) – Tag to match send with remote recv'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tag**（*int*，可选）- 用于匹配发送和接收的标签'
- en: '[PRE48]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Receives a tensor synchronously.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 同步接收张量。
- en: Parameters
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**tensor** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – Tensor
    to fill with received data.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tensor**（*Tensor*）- 用于填充接收数据的张量。'
- en: '**src** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")*,* *optional*) – Source rank. Will receive from any process if
    unspecified.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**src**（*int*，可选）- 源等级。如果未指定，则将从任何进程接收。'
- en: '**group** (*ProcessGroup**,* *optional*) – The process group to work on. If
    None, the default process group will be used.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group**（*ProcessGroup*，可选）- 要操作的进程组。如果为None，则将使用默认进程组。'
- en: '**tag** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")*,* *optional*) – Tag to match recv with remote send'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tag**（*int*，可选）- 用于匹配接收和远程发送的标签'
- en: Returns
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: Sender rank -1, if not part of the group
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 发送方等级为-1，如果不是组的一部分
- en: Return type
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '[int](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)")'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: '[`isend()`](#torch.distributed.isend "torch.distributed.isend") and [`irecv()`](#torch.distributed.irecv
    "torch.distributed.irecv") return distributed request objects when used. In general,
    the type of this object is unspecified as they should never be created manually,
    but they are guaranteed to support two methods:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`isend()` 和 `irecv()` 在使用时返回分布式请求对象。一般来说，这个对象的类型是未指定的，因为它们不应该手动创建，但是它们保证支持两种方法：'
- en: '`is_completed()` - returns True if the operation has finished'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_completed()` - 如果操作已完成则返回True'
- en: '`wait()` - will block the process until the operation is finished. `is_completed()`
    is guaranteed to return True once it returns.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait()` - 将阻塞进程，直到操作完成。一旦返回，`is_completed()` 保证返回True。'
- en: '[PRE49]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Send a tensor asynchronously.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 异步发送张量。
- en: Warning
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Modifying `tensor` before the request completes causes undefined behavior.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求完成之前修改 `tensor` 会导致未定义的行为。
- en: Warning
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: '`tag` is not supported with the NCCL backend.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`tag` 在 NCCL 后端不受支持。'
- en: Parameters
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**tensor** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – Tensor
    to send.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tensor**（*Tensor*）- 要发送的张量。'
- en: '**dst** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")) – Destination rank.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dst**（*int*）- 目标等级。'
- en: '**group** (*ProcessGroup**,* *optional*) – The process group to work on. If
    None, the default process group will be used.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group**（*ProcessGroup*，可选）- 要操作的进程组。如果为None，则将使用默认进程组。'
- en: '**tag** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")*,* *optional*) – Tag to match send with remote recv'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tag**（*int*，可选）- 用于匹配发送和远程接收的标签'
- en: Returns
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: A distributed request object. None, if not part of the group
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式请求对象。如果不是组的一部分，则为None
- en: Return type
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '*Work*'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 工作
- en: '[PRE50]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Receives a tensor asynchronously.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 异步接收张量。
- en: Warning
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: '`tag` is not supported with the NCCL backend.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`tag` 在 NCCL 后端不受支持。'
- en: Parameters
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**tensor** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – Tensor
    to fill with received data.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tensor**（*Tensor*）- 用于填充接收数据的张量。'
- en: '**src** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")*,* *optional*) – Source rank. Will receive from any process if
    unspecified.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**src**（*int*，可选）- 源等级。如果未指定，则将从任何进程接收。'
- en: '**group** (*ProcessGroup**,* *optional*) – The process group to work on. If
    None, the default process group will be used.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group**（*ProcessGroup*，可选）- 要操作的进程组。如果为None，则将使用默认进程组。'
- en: '**tag** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")*,* *optional*) – Tag to match recv with remote send'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tag**（*int*，可选）- 用于匹配接收和远程发送的标签'
- en: Returns
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: A distributed request object. None, if not part of the group
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式请求对象。如果不是组的一部分，则为None
- en: Return type
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型
- en: '*Work*'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 工作
- en: '[PRE51]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Send or Receive a batch of tensors asynchronously and return a list of requests.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 异步发送或接收一批张量，并返回请求列表。
- en: Process each of the operations in `p2p_op_list` and return the corresponding
    requests. NCCL, Gloo, and UCC backend are currently supported.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 `p2p_op_list` 中的每个操作并返回相应的请求。目前支持 NCCL、Gloo 和 UCC 后端。
- en: Parameters
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**p2p_op_list** – A list of point-to-point operations(type of each operator
    is `torch.distributed.P2POp`). The order of the isend/irecv in the list matters
    and it needs to match with corresponding isend/irecv on the remote end.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**p2p_op_list** - 一组点对点操作（每个操作符的类型是 `torch.distributed.P2POp`）。列表中isend/irecv的顺序很重要，需要与远程端对应的isend/irecv匹配。'
- en: Returns
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: A list of distributed request objects returned by calling the corresponding
    op in the op_list.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用op_list中相应的op返回的分布式请求对象列表。
- en: Examples
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE52]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that when this API is used with the NCCL PG backend, users must set the
    current GPU device with torch.cuda.set_device, otherwise it will lead to unexpected
    hang issues.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当此API与NCCL PG后端一起使用时，用户必须使用torch.cuda.set_device设置当前GPU设备，否则会导致意外挂起问题。
- en: In addition, if this API is the first collective call in the `group` passed
    to `dist.P2POp`, all ranks of the `group` must participate in this API call; otherwise,
    the behavior is undefined. If this API call is not the first collective call in
    the `group`, batched P2P operations involving only a subset of ranks of the `group`
    are allowed.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果此API是传递给`dist.P2POp`的`group`中的第一个集合调用，则`group`的所有等级必须参与此API调用；否则，行为是未定义的。如果此API调用不是`group`中的第一个集合调用，则允许涉及`group`的部分等级的批量P2P操作。
- en: '[PRE53]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: A class to build point-to-point operations for `batch_isend_irecv`.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 用于构建`batch_isend_irecv`的点对点操作的类。
- en: This class builds the type of P2P operation, communication buffer, peer rank,
    Process Group, and tag. Instances of this class will be passed to `batch_isend_irecv`
    for point-to-point communications.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 此类构建P2P操作类型、通信缓冲区、对等等级、进程组和标签。此类的实例将传递给`batch_isend_irecv`以进行点对点通信。
- en: Parameters
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**op** (*Callable*) – A function to send data to or receive data from a peer
    process. The type of `op` is either `torch.distributed.isend` or `torch.distributed.irecv`.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**op**（*Callable*） - 用于向对等进程发送数据或接收数据的函数。`op`的类型可以是`torch.distributed.isend`或`torch.distributed.irecv`。'
- en: '**tensor** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – Tensor
    to send or receive.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tensor**（[*Tensor*](tensors.html#torch.Tensor)） - 要发送或接收的张量。'
- en: '**peer** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")) – Destination or source rank.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**peer**（[*int*](https://docs.python.org/3/library/functions.html#int)） - 目标或源等级。'
- en: '**group** (*ProcessGroup**,* *optional*) – The process group to work on. If
    None, the default process group will be used.'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group**（*ProcessGroup**,* *可选*） - 要操作的进程组。如果为None，则将使用默认进程组。'
- en: '**tag** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")*,* *optional*) – Tag to match send with recv.'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tag**（[*int*](https://docs.python.org/3/library/functions.html#int) *，* *可选*）
    - 用于匹配发送和接收的标签。'
- en: Synchronous and asynchronous collective operations[](#synchronous-and-asynchronous-collective-operations
    "Permalink to this heading")
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步和异步集合操作
- en: 'Every collective operation function supports the following two kinds of operations,
    depending on the setting of the `async_op` flag passed into the collective:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集合操作函数支持以下两种操作，取决于传入集合的`async_op`标志的设置：
- en: '**Synchronous operation** - the default mode, when `async_op` is set to `False`.
    When the function returns, it is guaranteed that the collective operation is performed.
    In the case of CUDA operations, it is not guaranteed that the CUDA operation is
    completed, since CUDA operations are asynchronous. For CPU collectives, any further
    function calls utilizing the output of the collective call will behave as expected.
    For CUDA collectives, function calls utilizing the output on the same CUDA stream
    will behave as expected. Users must take care of synchronization under the scenario
    of running under different streams. For details on CUDA semantics such as stream
    synchronization, see [CUDA Semantics](https://pytorch.org/docs/stable/notes/cuda.html).
    See the below script to see examples of differences in these semantics for CPU
    and CUDA operations.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '**同步操作** - 默认模式，当`async_op`设置为`False`时。当函数返回时，保证执行集合操作。对于CUDA操作，不能保证CUDA操作已完成，因为CUDA操作是异步的。对于CPU集合，任何进一步使用集合调用输出的函数调用将按预期运行。对于CUDA集合，使用相同CUDA流上的输出的函数调用将按预期运行。用户必须在在不同流下运行的情况下进行同步处理。有关CUDA语义（如流同步）的详细信息，请参阅[CUDA语义](https://pytorch.org/docs/stable/notes/cuda.html)。请查看下面的脚本，了解CPU和CUDA操作中这些语义差异的示例。'
- en: '**Asynchronous operation** - when `async_op` is set to True. The collective
    operation function returns a distributed request object. In general, you don’t
    need to create it manually and it is guaranteed to support two methods:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步操作** - 当`async_op`设置为True时。集合操作函数返回一个分布式请求对象。通常，您不需要手动创建它，它保证支持两种方法：'
- en: '`is_completed()` - in the case of CPU collectives, returns `True` if completed.
    In the case of CUDA operations, returns `True` if the operation has been successfully
    enqueued onto a CUDA stream and the output can be utilized on the default stream
    without further synchronization.'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_completed()` - 对于CPU集合，如果已完成，则返回`True`。对于CUDA操作，如果操作已成功排队到CUDA流并且输出可以在默认流上使用而无需进一步同步，则返回`True`。'
- en: '`wait()` - in the case of CPU collectives, will block the process until the
    operation is completed. In the case of CUDA collectives, will block until the
    operation has been successfully enqueued onto a CUDA stream and the output can
    be utilized on the default stream without further synchronization.'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait()` - 对于CPU集合，将阻塞进程直到操作完成。对于CUDA集合，将阻塞直到操作已成功排队到CUDA流并且输出可以在默认流上使用而无需进一步同步。'
- en: '`get_future()` - returns `torch._C.Future` object. Supported for NCCL, also
    supported for most operations on GLOO and MPI, except for peer to peer operations.
    Note: as we continue adopting Futures and merging APIs, `get_future()` call might
    become redundant.'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_future()` - 返回`torch._C.Future`对象。支持NCCL，也支持GLOO和MPI上的大多数操作，除了点对点操作。注意：随着我们继续采用Futures并合并API，`get_future()`调用可能变得多余。'
- en: '**Example**'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: 'The following code can serve as a reference regarding semantics for CUDA operations
    when using distributed collectives. It shows the explicit need to synchronize
    when using collective outputs on different CUDA streams:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可作为使用分布式集合时CUDA操作语义的参考。它显示了在不同CUDA流上使用集合输出时显式需要同步的需求：
- en: '[PRE54]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Collective functions
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合函数
- en: '[PRE55]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Broadcasts the tensor to the whole group.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 将张量广播到整个组。
- en: '`tensor` must have the same number of elements in all processes participating
    in the collective.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`张量`必须在参与集合的所有进程中具有相同数量的元素。'
- en: Parameters
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**tensor** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – Data to
    be sent if `src` is the rank of current process, and tensor to be used to save
    received data otherwise.'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**张量**（[*张量*](tensors.html#torch.Tensor "torch.Tensor"） - 如果`src`是当前进程的等级，则要发送的数据，否则要用于保存接收到的数据的张量。'
- en: '**src** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")) – Source rank.'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**src**（[*int*](https://docs.python.org/3/library/functions.html#int "(在Python
    v3.12中)")） - 源等级。'
- en: '**group** (*ProcessGroup**,* *optional*) – The process group to work on. If
    None, the default process group will be used.'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组**（*ProcessGroup**,* *可选*） - 要处理的进程组。如果为None，则将使用默认进程组。'
- en: '**async_op** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – Whether this op should be an async op'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**async_op**（[*bool*](https://docs.python.org/3/library/functions.html#bool
    "(在Python v3.12中)")，可选） - 此操作是否应为异步操作'
- en: Returns
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: Async work handle, if async_op is set to True. None, if not async_op or if not
    part of the group
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 异步工作句柄，如果async_op设置为True。如果不是async_op或不是组的一部分，则为None
- en: '[PRE56]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Broadcasts picklable objects in `object_list` to the whole group.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 将`object_list`中的可picklable对象广播到整个组。
- en: Similar to [`broadcast()`](#torch.distributed.broadcast "torch.distributed.broadcast"),
    but Python objects can be passed in. Note that all objects in `object_list` must
    be picklable in order to be broadcasted.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 与[`broadcast()`](#torch.distributed.broadcast "torch.distributed.broadcast")类似，但可以传递Python对象。请注意，`object_list`中的所有对象必须是可picklable的，以便进行广播。
- en: Parameters
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**object_list** (*List**[**Any**]*) – List of input objects to broadcast. Each
    object must be picklable. Only objects on the `src` rank will be broadcast, but
    each rank must provide lists of equal sizes.'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**object_list**（*List**[**Any**]*） - 要广播的输入对象列表。每个对象必须是可picklable的。只有`src`等级上的对象将被广播，但每个等级必须提供相同大小的列表。'
- en: '**src** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")) – Source rank from which to broadcast `object_list`.'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**src**（[*int*](https://docs.python.org/3/library/functions.html#int "(在Python
    v3.12中)")） - 要广播`object_list`的源等级。'
- en: '**group** – (ProcessGroup, optional): The process group to work on. If None,
    the default process group will be used. Default is `None`.'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组** - （ProcessGroup，可选）：要处理的进程组。如果为None，则将使用默认进程组。默认为`None`。'
- en: '**device** (`torch.device`, optional) – If not None, the objects are serialized
    and converted to tensors which are moved to the `device` before broadcasting.
    Default is `None`.'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备**（`torch.device`，可选） - 如果不是None，则对象将被序列化并转换为张量，然后在广播之前移动到`device`。默认为`None`。'
- en: Returns
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: '`None`. If rank is part of the group, `object_list` will contain the broadcasted
    objects from `src` rank.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`无`。如果等级是组的一部分，则`object_list`将包含来自`src`等级的广播对象。'
- en: Note
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For NCCL-based process groups, internal tensor representations of objects must
    be moved to the GPU device before communication takes place. In this case, the
    device used is given by `torch.cuda.current_device()` and it is the user’s responsibility
    to ensure that this is set so that each rank has an individual GPU, via `torch.cuda.set_device()`.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于NCCL的进程组，对象的内部张量表示必须在通信发生之前移动到GPU设备。在这种情况下，使用的设备由`torch.cuda.current_device()`给出，用户有责任确保设置了这一点，以便每个等级都有一个独立的GPU，通过`torch.cuda.set_device()`。
- en: Note
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this API differs slightly from the [`all_gather()`](#torch.distributed.all_gather
    "torch.distributed.all_gather") collective since it does not provide an `async_op`
    handle and thus will be a blocking call.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此API与[`all_gather()`](#torch.distributed.all_gather "torch.distributed.all_gather")集合略有不同，因为它不提供`async_op`句柄，因此将是一个阻塞调用。
- en: Warning
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: '[`broadcast_object_list()`](#torch.distributed.broadcast_object_list "torch.distributed.broadcast_object_list")
    uses `pickle` module implicitly, which is known to be insecure. It is possible
    to construct malicious pickle data which will execute arbitrary code during unpickling.
    Only call this function with data you trust.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '[`broadcast_object_list()`](#torch.distributed.broadcast_object_list "torch.distributed.broadcast_object_list")隐式使用`pickle`模块，这是已知不安全的。可以构造恶意pickle数据，在解pickle时执行任意代码。只能使用信任的数据调用此函数。'
- en: Warning
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Calling [`broadcast_object_list()`](#torch.distributed.broadcast_object_list
    "torch.distributed.broadcast_object_list") with GPU tensors is not well supported
    and inefficient as it incurs GPU -> CPU transfer since tensors would be pickled.
    Please consider using [`broadcast()`](#torch.distributed.broadcast "torch.distributed.broadcast")
    instead.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GPU张量调用[`broadcast_object_list()`](#torch.distributed.broadcast_object_list
    "torch.distributed.broadcast_object_list")不受良好支持且效率低下，因为它会导致GPU -> CPU传输，因为张量将被pickled。请考虑使用[`broadcast()`](#torch.distributed.broadcast
    "torch.distributed.broadcast")代替。
- en: 'Example::'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '示例::'
- en: '[PRE57]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Reduces the tensor data across all machines in a way that all get the final
    result.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有机器上减少张量数据，以便所有人都获得最终结果。
- en: After the call `tensor` is going to be bitwise identical in all processes.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 调用后，`张量`在所有进程中将是按位相同的。
- en: Complex tensors are supported.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 支持复杂张量。
- en: Parameters
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**tensor** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – Input and
    output of the collective. The function operates in-place.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**张量**（[*张量*](tensors.html#torch.Tensor "torch.Tensor"） - 集合的输入和输出。该函数原地操作。'
- en: '**op** (*optional*) – One of the values from `torch.distributed.ReduceOp` enum.
    Specifies an operation used for element-wise reductions.'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**op**（*可选*） - `torch.distributed.ReduceOp`枚举中的一个值。指定用于逐元素减少的操作。'
- en: '**group** (*ProcessGroup**,* *optional*) – The process group to work on. If
    None, the default process group will be used.'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组**（*ProcessGroup**,* *可选*） - 要处理的进程组。如果为None，则将使用默认进程组。'
- en: '**async_op** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – Whether this op should be an async op'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**async_op**（[*bool*](https://docs.python.org/3/library/functions.html#bool
    "(在Python v3.12中)")*,* *可选*）- 此操作是否应为异步操作'
- en: Returns
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: Async work handle, if async_op is set to True. None, if not async_op or if not
    part of the group
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 异步工作句柄，如果async_op设置为True。如果不是async_op或不是组的一部分，则为None
- en: Examples
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE59]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Reduces the tensor data across all machines.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有机器上减少张量数据。
- en: Only the process with rank `dst` is going to receive the final result.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 只有等级为`dst`的进程将接收最终结果。
- en: Parameters
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**tensor** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – Input and
    output of the collective. The function operates in-place.'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tensor**（[*Tensor*](tensors.html#torch.Tensor "torch.Tensor")）- 集体的输入和输出。该函数原地操作。'
- en: '**dst** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")) – Destination rank'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dst**（[*int*](https://docs.python.org/3/library/functions.html#int "(在Python
    v3.12中)")）- 目标等级'
- en: '**op** (*optional*) – One of the values from `torch.distributed.ReduceOp` enum.
    Specifies an operation used for element-wise reductions.'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**op**（*可选*）- `torch.distributed.ReduceOp`枚举中的值之一。指定用于逐元素减少的操作。'
- en: '**group** (*ProcessGroup**,* *optional*) – The process group to work on. If
    None, the default process group will be used.'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group**（*ProcessGroup**,* *可选*）- 要操作的进程组。如果为None，则将使用默认进程组。'
- en: '**async_op** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – Whether this op should be an async op'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**async_op**（[*bool*](https://docs.python.org/3/library/functions.html#bool
    "(在Python v3.12中)")*,* *可选*）- 此操作是否应为异步操作'
- en: Returns
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: Async work handle, if async_op is set to True. None, if not async_op or if not
    part of the group
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 异步工作句柄，如果async_op设置为True。如果不是async_op或不是组的一部分，则为None
- en: '[PRE62]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Gathers tensors from the whole group in a list.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 从整个组中收集张量到列表中。
- en: Complex tensors are supported.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 支持复杂张量。
- en: Parameters
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**tensor_list** ([*list*](https://docs.python.org/3/library/stdtypes.html#list
    "(in Python v3.12)")*[*[*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*]*)
    – Output list. It should contain correctly-sized tensors to be used for output
    of the collective.'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tensor_list**（[*list*](https://docs.python.org/3/library/stdtypes.html#list
    "(在Python v3.12中)")*[*[*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*]*)-
    输出列表。它应该包含正确大小的张量，用于集体的输出。'
- en: '**tensor** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – Tensor
    to be broadcast from current process.'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tensor**（[*Tensor*](tensors.html#torch.Tensor "torch.Tensor")）- 要从当前进程广播的张量。'
- en: '**group** (*ProcessGroup**,* *optional*) – The process group to work on. If
    None, the default process group will be used.'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group**（*ProcessGroup**,* *可选*）- 要操作的进程组。如果为None，则将使用默认进程组。'
- en: '**async_op** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – Whether this op should be an async op'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**async_op**（[*bool*](https://docs.python.org/3/library/functions.html#bool
    "(在Python v3.12中)")*,* *可选*）- 此操作是否应为异步操作'
- en: Returns
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: Async work handle, if async_op is set to True. None, if not async_op or if not
    part of the group
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 异步工作句柄，如果async_op设置为True。如果不是async_op或不是组的一部分，则为None
- en: Examples
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE63]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Gather tensors from all ranks and put them in a single output tensor.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 从所有等级中收集张量并将它们放入单个输出张量中。
- en: Parameters
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**output_tensor** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) –
    Output tensor to accommodate tensor elements from all ranks. It must be correctly
    sized to have one of the following forms: (i) a concatenation of all the input
    tensors along the primary dimension; for definition of “concatenation”, see `torch.cat()`;
    (ii) a stack of all the input tensors along the primary dimension; for definition
    of “stack”, see `torch.stack()`. Examples below may better explain the supported
    output forms.'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**output_tensor**（[*Tensor*](tensors.html#torch.Tensor "torch.Tensor")）- 输出张量，用于容纳所有等级的张量元素。它必须正确大小，以具有以下形式之一：（i）沿着主要维度连接所有输入张量；有关“连接”的定义，请参见`torch.cat()`；（ii）沿着主要维度堆叠所有输入张量；有关“堆叠”的定义，请参见`torch.stack()`。下面的示例可能更好地解释支持的输出形式。'
- en: '**input_tensor** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – Tensor
    to be gathered from current rank. Different from the `all_gather` API, the input
    tensors in this API must have the same size across all ranks.'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**input_tensor**（[*Tensor*](tensors.html#torch.Tensor "torch.Tensor")）- 要从当前等级收集的张量。与`all_gather`
    API中的输入张量不同，此API中的输入张量在所有等级上必须具有相同的大小。'
- en: '**group** (*ProcessGroup**,* *optional*) – The process group to work on. If
    None, the default process group will be used.'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group**（*ProcessGroup**,* *可选*）- 要操作的进程组。如果为None，则将使用默认进程组。'
- en: '**async_op** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – Whether this op should be an async op'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**async_op**（[*bool*](https://docs.python.org/3/library/functions.html#bool
    "(在Python v3.12中)")*,* *可选*）- 此操作是否应为异步操作'
- en: Returns
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: Async work handle, if async_op is set to True. None, if not async_op or if not
    part of the group
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 异步工作句柄，如果async_op设置为True。如果不是async_op或不是组的一部分，则为None
- en: Examples
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE66]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Warning
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The Gloo backend does not support this API.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: Gloo后端不支持此API。
- en: '[PRE67]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Gathers picklable objects from the whole group into a list.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 从整个组中收集可picklable对象到列表中。
- en: Similar to [`all_gather()`](#torch.distributed.all_gather "torch.distributed.all_gather"),
    but Python objects can be passed in. Note that the object must be picklable in
    order to be gathered.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于[`all_gather()`](#torch.distributed.all_gather "torch.distributed.all_gather")，但可以传递Python对象。请注意，对象必须是可picklable的才能被收集。
- en: Parameters
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**object_list** ([*list*](https://docs.python.org/3/library/stdtypes.html#list
    "(in Python v3.12)")*[**Any**]*) – Output list. It should be correctly sized as
    the size of the group for this collective and will contain the output.'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**object_list**（[*list*](https://docs.python.org/3/library/stdtypes.html#list
    "(在Python v3.12中)")*[**Any**]*)- 输出列表。它应该正确大小，作为此集体的组大小，并将包含输出。'
- en: '**obj** (*Any*) – Pickable Python object to be broadcast from current process.'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**obj**（*Any*）- 要从当前进程广播的可pickable Python对象。'
- en: '**group** (*ProcessGroup**,* *optional*) – The process group to work on. If
    None, the default process group will be used. Default is `None`.'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group**（*ProcessGroup**,* *可选*）- 要操作的进程组。如果为None，则将使用默认进程组。默认为`None`。'
- en: Returns
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: None. If the calling rank is part of this group, the output of the collective
    will be populated into the input `object_list`. If the calling rank is not part
    of the group, the passed in `object_list` will be unmodified.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用等级是此组的一部分，则集合的输出将填充到输入的 `object_list` 中。如果调用等级不是组的一部分，则传入的 `object_list`
    将不会被修改。
- en: Note
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this API differs slightly from the [`all_gather()`](#torch.distributed.all_gather
    "torch.distributed.all_gather") collective since it does not provide an `async_op`
    handle and thus will be a blocking call.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此 API 与 [`all_gather()`](#torch.distributed.all_gather "torch.distributed.all_gather")
    集合略有不同，因为它不提供 `async_op` 句柄，因此将是一个阻塞调用。
- en: Note
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For NCCL-based processed groups, internal tensor representations of objects
    must be moved to the GPU device before communication takes place. In this case,
    the device used is given by `torch.cuda.current_device()` and it is the user’s
    responsiblity to ensure that this is set so that each rank has an individual GPU,
    via `torch.cuda.set_device()`.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于 NCCL 的处理组，对象的内部张量表示必须在通信之前移动到 GPU 设备。在这种情况下，使用的设备由 `torch.cuda.current_device()`
    给出，用户有责任确保每个等级都有独立的 GPU，通过 `torch.cuda.set_device()`。
- en: Warning
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: '[`all_gather_object()`](#torch.distributed.all_gather_object "torch.distributed.all_gather_object")
    uses `pickle` module implicitly, which is known to be insecure. It is possible
    to construct malicious pickle data which will execute arbitrary code during unpickling.
    Only call this function with data you trust.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '[`all_gather_object()`](#torch.distributed.all_gather_object "torch.distributed.all_gather_object")
    隐式使用 `pickle` 模块，已知存在安全问题。可能构造恶意的 pickle 数据，在反序列化时执行任意代码。只能在信任的数据上调用此函数。'
- en: Warning
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Calling [`all_gather_object()`](#torch.distributed.all_gather_object "torch.distributed.all_gather_object")
    with GPU tensors is not well supported and inefficient as it incurs GPU -> CPU
    transfer since tensors would be pickled. Please consider using [`all_gather()`](#torch.distributed.all_gather
    "torch.distributed.all_gather") instead.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GPU 张量调用 [`all_gather_object()`](#torch.distributed.all_gather_object "torch.distributed.all_gather_object")
    不受良好支持且效率低下，因为会导致 GPU -> CPU 传输，因为张量将被 pickled。请考虑使用 [`all_gather()`](#torch.distributed.all_gather
    "torch.distributed.all_gather")。
- en: 'Example::'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '示例::'
- en: '[PRE68]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Gathers a list of tensors in a single process.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个进程中收集张量列表。
- en: Parameters
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**tensor** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – Input tensor.'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tensor** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – 输入张量。'
- en: '**gather_list** ([*list*](https://docs.python.org/3/library/stdtypes.html#list
    "(in Python v3.12)")*[*[*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*]**,*
    *optional*) – List of appropriately-sized tensors to use for gathered data (default
    is None, must be specified on the destination rank)'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gather_list** ([*list*](https://docs.python.org/3/library/stdtypes.html#list
    "(in Python v3.12)")*[*[*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*]**,*
    *optional*) – 用于收集数据的适当大小的张量列表（默认为 None，在目标等级上必须指定）'
- en: '**dst** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")*,* *optional*) – Destination rank (default is 0)'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dst** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")*,* *optional*) – 目标等级（默认为 0）'
- en: '**group** (*ProcessGroup**,* *optional*) – The process group to work on. If
    None, the default process group will be used.'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group** (*ProcessGroup**,* *optional*) – 要操作的处理组。如果为 None，则将使用默认处理组。'
- en: '**async_op** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – Whether this op should be an async op'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**async_op** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – 此操作是否应为异步操作'
- en: Returns
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: Async work handle, if async_op is set to True. None, if not async_op or if not
    part of the group
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 async_op 设置为 True，则为异步工作句柄。如果不是 async_op 或不是组的一部分，则为 None
- en: '[PRE70]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Gathers picklable objects from the whole group in a single process.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个进程中从整个组中收集可 pickle 的对象。
- en: Similar to [`gather()`](#torch.distributed.gather "torch.distributed.gather"),
    but Python objects can be passed in. Note that the object must be picklable in
    order to be gathered.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 [`gather()`](#torch.distributed.gather "torch.distributed.gather")，但可以传递
    Python 对象。请注意，对象必须是可 pickle 的才能被收集。
- en: Parameters
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**obj** (*Any*) – Input object. Must be picklable.'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**obj** (*Any*) – 输入对象。必须是可 pickle 的。'
- en: '**object_gather_list** ([*list*](https://docs.python.org/3/library/stdtypes.html#list
    "(in Python v3.12)")*[**Any**]*) – Output list. On the `dst` rank, it should be
    correctly sized as the size of the group for this collective and will contain
    the output. Must be `None` on non-dst ranks. (default is `None`)'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**object_gather_list** ([*list*](https://docs.python.org/3/library/stdtypes.html#list
    "(in Python v3.12)")*[**Any**]*) – 输出列表。在 `dst` 等级上，它应该正确大小，作为此集合的组大小，并包含输出。在非目标等级上必须为
    `None`。（默认为 `None`）'
- en: '**dst** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")*,* *optional*) – Destination rank. (default is 0)'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dst** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")*,* *optional*) – 目标等级。（默认为 0）'
- en: '**group** – (ProcessGroup, optional): The process group to work on. If None,
    the default process group will be used. Default is `None`.'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group** – (ProcessGroup, optional): 要操作的处理组。如果为 None，则将使用默认处理组。默认为 `None`。'
- en: Returns
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: None. On the `dst` rank, `object_gather_list` will contain the output of the
    collective.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: None。在 `dst` 等级上，`object_gather_list` 将包含集合的输出。
- en: Note
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this API differs slightly from the gather collective since it does
    not provide an async_op handle and thus will be a blocking call.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此 API 与 gather 集合略有不同，因为它不提供 async_op 句柄，因此将是一个阻塞调用。
- en: Note
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For NCCL-based processed groups, internal tensor representations of objects
    must be moved to the GPU device before communication takes place. In this case,
    the device used is given by `torch.cuda.current_device()` and it is the user’s
    responsiblity to ensure that this is set so that each rank has an individual GPU,
    via `torch.cuda.set_device()`.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于 NCCL 的处理组，对象的内部张量表示必须在通信之前移动到 GPU 设备。在这种情况下，使用的设备由 `torch.cuda.current_device()`
    给出，用户有责任确保每个等级都有独立的 GPU，通过 `torch.cuda.set_device()`。
- en: Warning
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: '[`gather_object()`](#torch.distributed.gather_object "torch.distributed.gather_object")
    uses `pickle` module implicitly, which is known to be insecure. It is possible
    to construct malicious pickle data which will execute arbitrary code during unpickling.
    Only call this function with data you trust.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '[`gather_object()`](#torch.distributed.gather_object "torch.distributed.gather_object")隐式使用`pickle`模块，这是不安全的。可能构造恶意的pickle数据，在解pickle时执行任意代码。只能使用信任的数据调用此函数。'
- en: Warning
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Calling [`gather_object()`](#torch.distributed.gather_object "torch.distributed.gather_object")
    with GPU tensors is not well supported and inefficient as it incurs GPU -> CPU
    transfer since tensors would be pickled. Please consider using [`gather()`](#torch.distributed.gather
    "torch.distributed.gather") instead.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GPU张量调用[`gather_object()`](#torch.distributed.gather_object "torch.distributed.gather_object")不受良好支持且效率低下，因为会导致GPU
    -> CPU传输，因为张量将被pickled。请考虑改用[`gather()`](#torch.distributed.gather "torch.distributed.gather")。
- en: 'Example::'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '示例::'
- en: '[PRE71]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Scatters a list of tensors to all processes in a group.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 将张量列表分散到组中的所有进程。
- en: Each process will receive exactly one tensor and store its data in the `tensor`
    argument.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程将收到一个张量，并将其数据存储在`tensor`参数中。
- en: Complex tensors are supported.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 支持复杂张量。
- en: Parameters
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**tensor** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – Output
    tensor.'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tensor**（[*Tensor*](tensors.html#torch.Tensor "torch.Tensor")） - 输出张量。'
- en: '**scatter_list** ([*list*](https://docs.python.org/3/library/stdtypes.html#list
    "(in Python v3.12)")*[*[*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*]*)
    – List of tensors to scatter (default is None, must be specified on the source
    rank)'
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**scatter_list**（[*list*](https://docs.python.org/3/library/stdtypes.html#list
    "(in Python v3.12)")*[*[*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*]*)
    - 要分散的张量列表（默认为None，必须在源秩上指定）'
- en: '**src** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")) – Source rank (default is 0)'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**src**（[*int*](https://docs.python.org/3/library/functions.html#int "(in Python
    v3.12)")） - 源秩（默认为0）'
- en: '**group** (*ProcessGroup**,* *optional*) – The process group to work on. If
    None, the default process group will be used.'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group**（*ProcessGroup**,* *可选*） - 要处理的进程组。如果为None，则将使用默认进程组。'
- en: '**async_op** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – Whether this op should be an async op'
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**async_op**（[*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")，可选） - 此操作是否应为异步操作'
- en: Returns
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: Async work handle, if async_op is set to True. None, if not async_op or if not
    part of the group
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 如果async_op设置为True，则为异步工作句柄。如果不是async_op或不是组的一部分，则为None
- en: Note
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that all Tensors in scatter_list must have the same size.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，scatter_list中的所有张量必须具有相同的大小。
- en: 'Example::'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '示例::'
- en: '[PRE73]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Scatters picklable objects in `scatter_object_input_list` to the whole group.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 将`scatter_object_input_list`中的可picklable对象分散到整个组中。
- en: Similar to [`scatter()`](#torch.distributed.scatter "torch.distributed.scatter"),
    but Python objects can be passed in. On each rank, the scattered object will be
    stored as the first element of `scatter_object_output_list`. Note that all objects
    in `scatter_object_input_list` must be picklable in order to be scattered.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于[`scatter()`](#torch.distributed.scatter "torch.distributed.scatter")，但可以传递Python对象。在每个秩上，分散的对象将存储为`scatter_object_output_list`的第一个元素。请注意，`scatter_object_input_list`中的所有对象必须是可picklable的才能被分散。
- en: Parameters
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**scatter_object_output_list** (*List**[**Any**]*) – Non-empty list whose first
    element will store the object scattered to this rank.'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**scatter_object_output_list**（*List**[**Any**]*） - 非空列表，其第一个元素将存储分散到此秩的对象。'
- en: '**scatter_object_input_list** (*List**[**Any**]*) – List of input objects to
    scatter. Each object must be picklable. Only objects on the `src` rank will be
    scattered, and the argument can be `None` for non-src ranks.'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**scatter_object_input_list**（*List**[**Any**]*） - 要分散的输入对象列表。每个对象必须是可picklable的。只有`src`秩上的对象才会被分散，对于非src秩，参数可以为`None`。'
- en: '**src** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")) – Source rank from which to scatter `scatter_object_input_list`.'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**src**（[*int*](https://docs.python.org/3/library/functions.html#int "(in Python
    v3.12)")） - 从中分散`scatter_object_input_list`的源秩。'
- en: '**group** – (ProcessGroup, optional): The process group to work on. If None,
    the default process group will be used. Default is `None`.'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group** - （ProcessGroup，可选）：要处理的进程组。如果为None，则将使用默认进程组。默认为`None`。'
- en: Returns
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: '`None`. If rank is part of the group, `scatter_object_output_list` will have
    its first element set to the scattered object for this rank.'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`。如果秩是组的一部分，则`scatter_object_output_list`的第一个元素将设置为此秩的分散对象。'
- en: Note
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this API differs slightly from the scatter collective since it does
    not provide an `async_op` handle and thus will be a blocking call.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此API与scatter collective略有不同，因为它不提供`async_op`句柄，因此将是一个阻塞调用。
- en: Warning
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: '[`scatter_object_list()`](#torch.distributed.scatter_object_list "torch.distributed.scatter_object_list")
    uses `pickle` module implicitly, which is known to be insecure. It is possible
    to construct malicious pickle data which will execute arbitrary code during unpickling.
    Only call this function with data you trust.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scatter_object_list()`](#torch.distributed.scatter_object_list "torch.distributed.scatter_object_list")隐式使用`pickle`模块，这是不安全的。可能构造恶意的pickle数据，在解pickle时执行任意代码。只能使用信任的数据调用此函数。'
- en: Warning
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Calling [`scatter_object_list()`](#torch.distributed.scatter_object_list "torch.distributed.scatter_object_list")
    with GPU tensors is not well supported and inefficient as it incurs GPU -> CPU
    transfer since tensors would be pickled. Please consider using [`scatter()`](#torch.distributed.scatter
    "torch.distributed.scatter") instead.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GPU张量调用[`scatter_object_list()`](#torch.distributed.scatter_object_list "torch.distributed.scatter_object_list")不受良好支持且效率低下，因为会导致GPU
    -> CPU传输，因为张量将被pickled。请考虑改用[`scatter()`](#torch.distributed.scatter "torch.distributed.scatter")。
- en: 'Example::'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '示例::'
- en: '[PRE75]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Reduces, then scatters a list of tensors to all processes in a group.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 将张量列表减少，然后分散到组中的所有进程。
- en: Parameters
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**output** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – Output
    tensor.'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出**（[*Tensor*](tensors.html#torch.Tensor "torch.Tensor")） - 输出张量。'
- en: '**input_list** ([*list*](https://docs.python.org/3/library/stdtypes.html#list
    "(in Python v3.12)")*[*[*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*]*)
    – List of tensors to reduce and scatter.'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**input_list** ([*list*](https://docs.python.org/3/library/stdtypes.html#list
    "(in Python v3.12)")*[*[*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*]*)
    – 要减少和分散的张量列表。'
- en: '**op** (*optional*) – One of the values from `torch.distributed.ReduceOp` enum.
    Specifies an operation used for element-wise reductions.'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**op** (*optional*) – `torch.distributed.ReduceOp`枚举中的一个值。指定用于逐元素减少的操作。'
- en: '**group** (*ProcessGroup**,* *optional*) – The process group to work on. If
    None, the default process group will be used.'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group** (*ProcessGroup**,* *optional*) – 要操作的进程组。如果为None，则将使用默认进程组。'
- en: '**async_op** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – Whether this op should be an async op.'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**async_op** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – 此操作是否应为异步操作。'
- en: Returns
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: Async work handle, if async_op is set to True. None, if not async_op or if not
    part of the group.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 如果async_op设置为True，则为异步工作句柄。如果不是async_op或不是组的一部分，则为None。
- en: '[PRE77]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Reduces, then scatters a tensor to all ranks in a group.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 将张量减少，然后分散到组中的所有秩。
- en: Parameters
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**output** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – Output
    tensor. It should have the same size across all ranks.'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**output** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – 输出张量。在所有秩上应具有相同的大小。'
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – Input tensor
    to be reduced and scattered. Its size should be output tensor size times the world
    size. The input tensor can have one of the following shapes: (i) a concatenation
    of the output tensors along the primary dimension, or (ii) a stack of the output
    tensors along the primary dimension. For definition of “concatenation”, see `torch.cat()`.
    For definition of “stack”, see `torch.stack()`.'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – 要减少和分散的输入张量。其大小应为输出张量大小乘以world
    size。输入张量可以具有以下形状之一：(i) 沿主维度连接的输出张量，或(ii) 沿主维度堆叠的输出张量。有关“连接”的定义，请参见`torch.cat()`。有关“堆叠”的定义，请参见`torch.stack()`。'
- en: '**group** (*ProcessGroup**,* *optional*) – The process group to work on. If
    None, the default process group will be used.'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group** (*ProcessGroup**,* *optional*) – 要操作的进程组。如果为None，则将使用默认进程组。'
- en: '**async_op** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – Whether this op should be an async op.'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**async_op** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – 此操作是否应为异步操作。'
- en: Returns
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: Async work handle, if async_op is set to True. None, if not async_op or if not
    part of the group.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 如果async_op设置为True，则为异步工作句柄。如果不是async_op或不是组的一部分，则为None。
- en: Examples
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE78]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Warning
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The Gloo backend does not support this API.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: Gloo后端不支持此API。
- en: '[PRE79]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Split input tensor and then scatter the split list to all processes in a group.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 拆分输入张量，然后将拆分列表分散到组中的所有进程。
- en: Later the received tensors are concatenated from all the processes in the group
    and returned as a single output tensor.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，从组中的所有进程接收的张量将连接起来，并作为单个输出张量返回。
- en: Complex tensors are supported.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 支持复杂张量。
- en: Parameters
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**output** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – Gathered
    concatenated output tensor.'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**output** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – 收集的连接输出张量。'
- en: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – Input tensor
    to scatter.'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**input** ([*Tensor*](tensors.html#torch.Tensor "torch.Tensor")) – 要分散的输入张量。'
- en: '**output_split_sizes** – (list[Int], optional): Output split sizes for dim
    0 if specified None or empty, dim 0 of `output` tensor must divide equally by
    `world_size`.'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**output_split_sizes** – (list[Int], optional): 如果指定为None或为空，则dim 0的`output`张量的输出分割大小必须能够被`world_size`均匀分割。'
- en: '**input_split_sizes** – (list[Int], optional): Input split sizes for dim 0
    if specified None or empty, dim 0 of `input` tensor must divide equally by `world_size`.'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**input_split_sizes** – (list[Int], optional): 如果指定为None或为空，则dim 0的`input`张量的输入分割大小必须能够被`world_size`均匀分割。'
- en: '**group** (*ProcessGroup**,* *optional*) – The process group to work on. If
    None, the default process group will be used.'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group** (*ProcessGroup**,* *optional*) – 要操作的进程组。如果为None，则将使用默认进程组。'
- en: '**async_op** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – Whether this op should be an async op.'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**async_op** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – 此操作是否应为异步操作。'
- en: Returns
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: Async work handle, if async_op is set to True. None, if not async_op or if not
    part of the group.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 如果async_op设置为True，则为异步工作句柄。如果不是async_op或不是组的一部分，则为None。
- en: Warning
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: all_to_all_single is experimental and subject to change.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: all_to_all_single是实验性的，可能会更改。
- en: Examples
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE80]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Scatters list of input tensors to all processes in a group and return gathered
    list of tensors in output list.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 将输入张量列表分散到组中的所有进程，并返回输出列表中收集的张量列表。
- en: Complex tensors are supported.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 支持复杂张量。
- en: Parameters
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**output_tensor_list** ([*list*](https://docs.python.org/3/library/stdtypes.html#list
    "(in Python v3.12)")*[*[*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*]*)
    – List of tensors to be gathered one per rank.'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**output_tensor_list** ([*list*](https://docs.python.org/3/library/stdtypes.html#list
    "(in Python v3.12)")*[*[*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*]*)
    – 要收集的张量列表，每个秩一个。'
- en: '**input_tensor_list** ([*list*](https://docs.python.org/3/library/stdtypes.html#list
    "(in Python v3.12)")*[*[*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*]*)
    – List of tensors to scatter one per rank.'
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**input_tensor_list** ([*list*](https://docs.python.org/3/library/stdtypes.html#list
    "(in Python v3.12)")*[*[*Tensor*](tensors.html#torch.Tensor "torch.Tensor")*]*)
    – 要分散的张量列表，每个秩一个。'
- en: '**group** (*ProcessGroup**,* *optional*) – The process group to work on. If
    None, the default process group will be used.'
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group** (*ProcessGroup**,* *optional*) – 要操作的进程组。如果为None，则将使用默认进程组。'
- en: '**async_op** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – Whether this op should be an async op.'
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**async_op** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – 此操作是否应为异步操作。'
- en: Returns
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: Async work handle, if async_op is set to True. None, if not async_op or if not
    part of the group.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 如果async_op设置为True，则返回异步工作句柄。如果不是async_op或者不是组的一部分，则返回None。
- en: Warning
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: all_to_all is experimental and subject to change.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: all_to_all是实验性的，可能会发生变化。
- en: Examples
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE85]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Synchronize all processes.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 同步所有进程。
- en: This collective blocks processes until the whole group enters this function,
    if async_op is False, or if async work handle is called on wait().
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 此集合会阻塞进程，直到整个组进入此函数，如果async_op为False，或者在wait()上调用异步工作句柄。
- en: Parameters
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**group** (*ProcessGroup**,* *optional*) – The process group to work on. If
    None, the default process group will be used.'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group**（*ProcessGroup**,* *可选*） - 要操作的进程组。如果为None，则将使用默认进程组。'
- en: '**async_op** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – Whether this op should be an async op'
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**async_op**（[*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *可选*） - 此操作是否应为异步操作'
- en: '**device_ids** (*[*[*int*](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.12)")*]**,* *optional*) – List of device/GPU ids.'
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**device_ids**（*[*[*int*](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.12)")*]**,* *可选*） - 设备/GPU id列表。'
- en: Returns
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: Async work handle, if async_op is set to True. None, if not async_op or if not
    part of the group
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 如果async_op设置为True，则返回异步工作句柄。如果不是async_op或者不是组的一部分，则返回None。
- en: '[PRE90]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Synchronize processes similar to `torch.distributed.barrier`, but consider a
    configurable timeout.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`torch.distributed.barrier`的进程同步，但考虑可配置的超时时间。
- en: It is able to report ranks that did not pass this barrier within the provided
    timeout. Specifically, for non-zero ranks, will block until a send/recv is processed
    from rank 0. Rank 0 will block until all send /recv from other ranks are processed,
    and will report failures for ranks that failed to respond in time. Note that if
    one rank does not reach the monitored_barrier (for example due to a hang), all
    other ranks would fail in monitored_barrier.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 它能够报告在提供的超时时间内未通过此屏障的排名。具体来说，对于非零排名，将阻塞直到从排名0处处理了一个发送/接收操作。排名0将阻塞直到所有其他排名的发送/接收操作都被处理，并将报告未能及时响应的排名的失败。请注意，如果一个排名未达到受监控的屏障（例如由于挂起），则所有其他排名都将在受监控的屏障中失败。
- en: This collective will block all processes/ranks in the group, until the whole
    group exits the function successfully, making it useful for debugging and synchronizing.
    However, it can have a performance impact and should only be used for debugging
    or scenarios that require full synchronization points on the host-side. For debugging
    purposes, this barrier can be inserted before the application’s collective calls
    to check if any ranks are desynchronized.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 此集合将阻塞组中的所有进程/排名，直到整个组成功退出函数，这对于调试和同步非常有用。但是，它可能会对性能产生影响，应仅用于调试或需要在主机端进行完全同步点的情况。出于调试目的，可以在应用程序的集合调用之前插入此屏障，以检查是否有任何排名不同步。
- en: Note
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this collective is only supported with the GLOO backend.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此集合仅在使用GLOO后端时受支持。
- en: Parameters
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**group** (*ProcessGroup**,* *optional*) – The process group to work on. If
    `None`, the default process group will be used.'
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group**（*ProcessGroup**,* *可选*） - 要操作的进程组。如果为`None`，则将使用默认进程组。'
- en: '**timeout** ([*datetime.timedelta*](https://docs.python.org/3/library/datetime.html#datetime.timedelta
    "(in Python v3.12)")*,* *optional*) – Timeout for monitored_barrier. If `None`,
    the default process group timeout will be used.'
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**timeout**（[*datetime.timedelta*](https://docs.python.org/3/library/datetime.html#datetime.timedelta
    "(in Python v3.12)")*,* *可选*） - 受监控屏障的超时时间。如果为`None`，将使用默认的进程组超时时间。'
- en: '**wait_all_ranks** ([*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *optional*) – Whether to collect all failed ranks or not.
    By default, this is `False` and `monitored_barrier` on rank 0 will throw on the
    first failed rank it encounters in order to fail fast. By setting `wait_all_ranks=True`
    `monitored_barrier` will collect all failed ranks and throw an error containing
    information about all failed ranks.'
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wait_all_ranks**（[*bool*](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)")*,* *可选*） - 是否收集所有失败的排名。默认情况下，此值为`False`，并且在排名0处的`monitored_barrier`会在遇到第一个失败的排名时立即抛出异常。通过设置`wait_all_ranks=True`，`monitored_barrier`将收集所有失败的排名，并抛出一个包含所有失败排名信息的错误。'
- en: Returns
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: '`None`.'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`。'
- en: 'Example::'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '示例::'
- en: '[PRE91]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'An enum-like class for available reduction operations: `SUM`, `PRODUCT`, `MIN`,
    `MAX`, `BAND`, `BOR`, `BXOR`, and `PREMUL_SUM`.'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 可用规约操作的类似枚举类：`SUM`、`PRODUCT`、`MIN`、`MAX`、`BAND`、`BOR`、`BXOR`和`PREMUL_SUM`。
- en: '`BAND`, `BOR`, and `BXOR` reductions are not available when using the `NCCL`
    backend.'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`NCCL`后端时，`BAND`、`BOR`和`BXOR`规约不可用。
- en: '`AVG` divides values by the world size before summing across ranks. `AVG` is
    only available with the `NCCL` backend, and only for NCCL versions 2.10 or later.'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '`AVG`在跨排名求和之前将值除以世界大小。`AVG`仅在使用`NCCL`后端时可用，并且仅适用于NCCL版本2.10或更高版本。'
- en: '`PREMUL_SUM` multiplies inputs by a given scalar locally before reduction.
    `PREMUL_SUM` is only available with the `NCCL` backend, and only available for
    NCCL versions 2.11 or later. Users are supposed to use `torch.distributed._make_nccl_premul_sum`.'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '`PREMUL_SUM`在规约之前本地将输入乘以给定的标量。`PREMUL_SUM`仅在使用`NCCL`后端时可用，并且仅适用于NCCL版本2.11或更高版本。用户应该使用`torch.distributed._make_nccl_premul_sum`。'
- en: Additionally, `MAX`, `MIN` and `PRODUCT` are not supported for complex tensors.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于复杂张量，不支持`MAX`、`MIN`和`PRODUCT`。
- en: The values of this class can be accessed as attributes, e.g., `ReduceOp.SUM`.
    They are used in specifying strategies for reduction collectives, e.g., [`reduce()`](#torch.distributed.reduce
    "torch.distributed.reduce").
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将此类的值作为属性访问，例如`ReduceOp.SUM`。它们用于指定规约集合的策略，例如[`reduce()`](#torch.distributed.reduce
    "torch.distributed.reduce")。
- en: This class does not support `__members__` property.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 此类不支持`__members__`属性。
- en: '[PRE93]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Deprecated enum-like class for reduction operations: `SUM`, `PRODUCT`, `MIN`,
    and `MAX`.'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 已弃用的类似枚举的规约操作类：`SUM`、`PRODUCT`、`MIN`和`MAX`。
- en: '[`ReduceOp`](#torch.distributed.ReduceOp "torch.distributed.ReduceOp") is recommended
    to use instead.'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用[`ReduceOp`](#torch.distributed.ReduceOp "torch.distributed.ReduceOp")。
- en: Profiling Collective Communication[](#profiling-collective-communication "Permalink
    to this heading")
  id: totrans-695
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合通信性能分析[](#profiling-collective-communication "跳转到此标题")
- en: 'Note that you can use `torch.profiler` (recommended, only available after 1.8.1)
    or `torch.autograd.profiler` to profile collective communication and point-to-point
    communication APIs mentioned here. All out-of-the-box backends (`gloo`, `nccl`,
    `mpi`) are supported and collective communication usage will be rendered as expected
    in profiling output/traces. Profiling your code is the same as any regular torch
    operator:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以使用`torch.profiler`（推荐，仅在1.8.1之后可用）或`torch.autograd.profiler`来分析此处提到的集合通信和点对点通信API。所有开箱即用的后端（`gloo`、`nccl`、`mpi`）都受支持，并且集合通信的使用将如预期般呈现在分析输出/跟踪中。对您的代码进行分析与任何常规torch运算符相同：
- en: '[PRE94]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Please refer to the [profiler documentation](https://pytorch.org/docs/main/profiler.html)
    for a full overview of profiler features.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 有关分析器功能的完整概述，请参阅[分析器文档](https://pytorch.org/docs/main/profiler.html)。
- en: Multi-GPU collective functions[](#multi-gpu-collective-functions "Permalink
    to this heading")
  id: totrans-699
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多GPU集合功能[](#multi-gpu-collective-functions "跳转到此标题")
- en: Warning
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The multi-GPU functions (which stand for multiple GPUs per CPU thread) are deprecated.
    As of today, PyTorch Distributed’s preferred programming model is one device per
    thread, as exemplified by the APIs in this document. If you are a backend developer
    and want to support multiple devices per thread, please contact PyTorch Distributed’s
    maintainers.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 多GPU功能（代表每个CPU线程多个GPU）已被弃用。截至目前，PyTorch分布式的首选编程模型是每个线程一个设备，正如本文档中的API所示。如果您是后端开发人员，并希望支持每个线程多个设备，请联系PyTorch分布式的维护人员。
- en: '## Third-party backends'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '## 第三方后端'
- en: Besides the builtin GLOO/MPI/NCCL backends, PyTorch distributed supports third-party
    backends through a run-time register mechanism. For references on how to develop
    a third-party backend through C++ Extension, please refer to [Tutorials - Custom
    C++ and CUDA Extensions](https://pytorch.org/tutorials/advanced/cpp_extension.html)
    and `test/cpp_extensions/cpp_c10d_extension.cpp`. The capability of third-party
    backends are decided by their own implementations.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置的GLOO/MPI/NCCL后端，PyTorch分布式还通过运行时注册机制支持第三方后端。有关如何通过C++扩展开发第三方后端的参考，请参阅[Tutorials
    - Custom C++ and CUDA Extensions](https://pytorch.org/tutorials/advanced/cpp_extension.html)和`test/cpp_extensions/cpp_c10d_extension.cpp`。第三方后端的功能由其自身的实现决定。
- en: The new backend derives from `c10d::ProcessGroup` and registers the backend
    name and the instantiating interface through [`torch.distributed.Backend.register_backend()`](#torch.distributed.Backend.register_backend
    "torch.distributed.Backend.register_backend") when imported.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 新后端源自`c10d::ProcessGroup`，并在导入时通过[`torch.distributed.Backend.register_backend()`](#torch.distributed.Backend.register_backend
    "torch.distributed.Backend.register_backend")注册后端名称和实例化接口。
- en: When manually importing this backend and invoking [`torch.distributed.init_process_group()`](#torch.distributed.init_process_group
    "torch.distributed.init_process_group") with the corresponding backend name, the
    `torch.distributed` package runs on the new backend.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 当手动导入此后端并调用[`torch.distributed.init_process_group()`](#torch.distributed.init_process_group
    "torch.distributed.init_process_group")与相应的后端名称时，`torch.distributed`包将在新后端上运行。
- en: Warning
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The support of third-party backend is experimental and subject to change.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方后端的支持是实验性的，可能会发生变化。
- en: Launch utility
  id: totrans-708
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动实用程序
- en: The torch.distributed package also provides a launch utility in torch.distributed.launch.
    This helper utility can be used to launch multiple processes per node for distributed
    training.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: torch.distributed包还提供了一个启动实用程序在torch.distributed.launch中。此辅助实用程序可用于在分布式训练中为每个节点启动多个进程。
- en: Module `torch.distributed.launch`.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 模块`torch.distributed.launch`。
- en: '`torch.distributed.launch` is a module that spawns up multiple distributed
    training processes on each of the training nodes.'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '`torch.distributed.launch`是一个模块，可以在每个训练节点上生成多个分布式训练进程。'
- en: Warning
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: This module is going to be deprecated in favor of [torchrun](elastic/run.html#launcher-api).
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块将被弃用，转而使用[torchrun](elastic/run.html#launcher-api)。
- en: The utility can be used for single-node distributed training, in which one or
    more processes per node will be spawned. The utility can be used for either CPU
    training or GPU training. If the utility is used for GPU training, each distributed
    process will be operating on a single GPU. This can achieve well-improved single-node
    training performance. It can also be used in multi-node distributed training,
    by spawning up multiple processes on each node for well-improved multi-node distributed
    training performance as well. This will especially be beneficial for systems with
    multiple Infiniband interfaces that have direct-GPU support, since all of them
    can be utilized for aggregated communication bandwidth.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 此实用程序可用于单节点分布式训练，其中每个节点将生成一个或多个进程。此实用程序可用于CPU训练或GPU训练。如果用于GPU训练，每个分布式进程将在单个GPU上运行。这可以实现良好的单节点训练性能改进。它也可以用于多节点分布式训练，通过在每个节点上生成多个进程来实现良好的多节点分布式训练性能。这对于具有多个Infiniband接口并具有直接GPU支持的系统特别有益，因为所有这些接口都可以用于聚合通信带宽。
- en: In both cases of single-node distributed training or multi-node distributed
    training, this utility will launch the given number of processes per node (`--nproc-per-node`).
    If used for GPU training, this number needs to be less or equal to the number
    of GPUs on the current system (`nproc_per_node`), and each process will be operating
    on a single GPU from *GPU 0 to GPU (nproc_per_node - 1)*.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是单节点分布式训练还是多节点分布式训练，此实用程序将在每个节点上启动给定数量的进程（`--nproc-per-node`）。如果用于GPU训练，此数字需要小于或等于当前系统上的GPU数量（`nproc_per_node`），并且每个进程将在从*GPU
    0到GPU（nproc_per_node - 1）*的单个GPU上运行。
- en: '**How to use this module:**'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何使用此模块：**'
- en: Single-Node multi-process distributed training
  id: totrans-717
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单节点多进程分布式训练
- en: '[PRE95]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Multi-Node multi-process distributed training: (e.g. two nodes)'
  id: totrans-719
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多节点多进程分布式训练：（例如两个节点）
- en: 'Node 1: *(IP: 192.168.1.1, and has a free port: 1234)*'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 节点1：*(IP：192.168.1.1，并且有一个空闲端口：1234)*
- en: '[PRE96]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Node 2:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '节点2:'
- en: '[PRE97]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'To look up what optional arguments this module offers:'
  id: totrans-724
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查找此模块提供的可选参数：
- en: '[PRE98]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '**Important Notices:**'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要通知：**'
- en: 1\. This utility and multi-process distributed (single-node or multi-node) GPU
    training currently only achieves the best performance using the NCCL distributed
    backend. Thus NCCL backend is the recommended backend to use for GPU training.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 此实用程序和多进程分布式（单节点或多节点）GPU训练目前仅使用NCCL分布式后端实现最佳性能。因此，NCCL后端是GPU训练的推荐后端。
- en: '2\. In your training program, you must parse the command-line argument: `--local-rank=LOCAL_PROCESS_RANK`,
    which will be provided by this module. If your training program uses GPUs, you
    should ensure that your code only runs on the GPU device of LOCAL_PROCESS_RANK.
    This can be done by:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 在您的训练程序中，您必须解析命令行参数：`--local-rank=LOCAL_PROCESS_RANK`，这将由此模块提供。如果您的训练程序使用GPU，您应该确保您的代码仅在LOCAL_PROCESS_RANK的GPU设备上运行。可以通过以下方式实现：
- en: Parsing the local_rank argument
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 解析`local_rank`参数
- en: '[PRE99]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Set your device to local rank using either
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方法将您的设备设置为本地等级
- en: '[PRE100]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: or
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE101]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 3\. In your training program, you are supposed to call the following function
    at the beginning to start the distributed backend. It is strongly recommended
    that `init_method=env://`. Other init methods (e.g. `tcp://`) may work, but `env://`
    is the one that is officially supported by this module.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 在您的训练程序中，您应该在开始时调用以下函数以启动分布式后端。强烈建议使用`init_method=env://`。其他初始化方法（例如`tcp://`）可能有效，但`env://`是此模块官方支持的方法。
- en: '[PRE102]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 4\. In your training program, you can either use regular distributed functions
    or use [`torch.nn.parallel.DistributedDataParallel()`](generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel
    "torch.nn.parallel.DistributedDataParallel") module. If your training program
    uses GPUs for training and you would like to use [`torch.nn.parallel.DistributedDataParallel()`](generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel
    "torch.nn.parallel.DistributedDataParallel") module, here is how to configure
    it.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 在您的训练程序中，您可以使用常规的分布式函数或使用[`torch.nn.parallel.DistributedDataParallel()`](generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel
    "torch.nn.parallel.DistributedDataParallel")模块。如果您的训练程序使用GPU进行训练，并且您想要使用[`torch.nn.parallel.DistributedDataParallel()`](generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel
    "torch.nn.parallel.DistributedDataParallel")模块，以下是如何配置它的方法。
- en: '[PRE103]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Please ensure that `device_ids` argument is set to be the only GPU device id
    that your code will be operating on. This is generally the local rank of the process.
    In other words, the `device_ids` needs to be `[args.local_rank]`, and `output_device`
    needs to be `args.local_rank` in order to use this utility
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保`device_ids`参数设置为您的代码将在其上运行的唯一GPU设备ID。通常这是进程的本地等级。换句话说，`device_ids`需要是`[args.local_rank]`，`output_device`需要是`args.local_rank`，以便使用此实用程序。
- en: 5\. Another way to pass `local_rank` to the subprocesses via environment variable
    `LOCAL_RANK`. This behavior is enabled when you launch the script with `--use-env=True`.
    You must adjust the subprocess example above to replace `args.local_rank` with
    `os.environ['LOCAL_RANK']`; the launcher will not pass `--local-rank` when you
    specify this flag.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 通过环境变量`LOCAL_RANK`将`local_rank`传递给子进程的另一种方法。当您使用`--use-env=True`启动脚本时，将启用此行为。您必须调整上面的子进程示例，将`args.local_rank`替换为`os.environ['LOCAL_RANK']`；当您指定此标志时，启动器将不会传递`--local-rank`。
- en: Warning
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: '`local_rank` is NOT globally unique: it is only unique per process on a machine.
    Thus, don’t use it to decide if you should, e.g., write to a networked filesystem.
    See [https://github.com/pytorch/pytorch/issues/12042](https://github.com/pytorch/pytorch/issues/12042)
    for an example of how things can go wrong if you don’t do this correctly.'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '`local_rank`并非全局唯一：它仅在一台机器上的每个进程中是唯一的。因此，不要使用它来决定是否应该写入网络文件系统等。请参阅[https://github.com/pytorch/pytorch/issues/12042](https://github.com/pytorch/pytorch/issues/12042)以了解如果不正确处理可能会出现问题的示例。'
- en: Spawn utility
  id: totrans-743
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成实用程序
- en: The [Multiprocessing package - torch.multiprocessing](multiprocessing.html#multiprocessing-doc)
    package also provides a `spawn` function in [`torch.multiprocessing.spawn()`](multiprocessing.html#module-torch.multiprocessing.spawn
    "torch.multiprocessing.spawn"). This helper function can be used to spawn multiple
    processes. It works by passing in the function that you want to run and spawns
    N processes to run it. This can be used for multiprocess distributed training
    as well.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '[Multiprocessing package - torch.multiprocessing](multiprocessing.html#multiprocessing-doc)包还提供了一个在[`torch.multiprocessing.spawn()`](multiprocessing.html#module-torch.multiprocessing.spawn
    "torch.multiprocessing.spawn")中的`spawn`函数。这个辅助函数可以用来生成多个进程。它通过传入您想要运行的函数并生成N个进程来运行它。这也可以用于多进程分布式训练。'
- en: For references on how to use it, please refer to [PyTorch example - ImageNet
    implementation](https://github.com/pytorch/examples/tree/master/imagenet)
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何使用它的参考，请参阅[PyTorch示例 - ImageNet实现](https://github.com/pytorch/examples/tree/master/imagenet)
- en: Note that this function requires Python 3.4 or higher.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此函数要求Python 3.4或更高版本。
- en: Debugging `torch.distributed` applications[](#debugging-torch-distributed-applications
    "Permalink to this heading")
  id: totrans-747
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试`torch.distributed`应用程序[](#debugging-torch-distributed-applications "跳转到此标题的永久链接")
- en: 'Debugging distributed applications can be challenging due to hard to understand
    hangs, crashes, or inconsistent behavior across ranks. `torch.distributed` provides
    a suite of tools to help debug training applications in a self-serve fashion:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 由于难以理解的挂起、崩溃或在等级之间的不一致行为，调试分布式应用程序可能具有挑战性。`torch.distributed`提供了一套工具来帮助以自助方式调试训练应用程序：
- en: Monitored Barrier
  id: totrans-749
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监控屏障
- en: 'As of v1.10, [`torch.distributed.monitored_barrier()`](#torch.distributed.monitored_barrier
    "torch.distributed.monitored_barrier") exists as an alternative to [`torch.distributed.barrier()`](#torch.distributed.barrier
    "torch.distributed.barrier") which fails with helpful information about which
    rank may be faulty when crashing, i.e. not all ranks calling into [`torch.distributed.monitored_barrier()`](#torch.distributed.monitored_barrier
    "torch.distributed.monitored_barrier") within the provided timeout. [`torch.distributed.monitored_barrier()`](#torch.distributed.monitored_barrier
    "torch.distributed.monitored_barrier") implements a host-side barrier using `send`/`recv`
    communication primitives in a process similar to acknowledgements, allowing rank
    0 to report which rank(s) failed to acknowledge the barrier in time. As an example,
    consider the following function where rank 1 fails to call into [`torch.distributed.monitored_barrier()`](#torch.distributed.monitored_barrier
    "torch.distributed.monitored_barrier") (in practice this could be due to an application
    bug or hang in a previous collective):'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 从v1.10开始，[`torch.distributed.monitored_barrier()`](#torch.distributed.monitored_barrier
    "torch.distributed.monitored_barrier")作为[`torch.distributed.barrier()`](#torch.distributed.barrier
    "torch.distributed.barrier")的替代存在，当崩溃时提供有关可能存在故障的rank的有用信息，即在规定的超时内未调用到[`torch.distributed.monitored_barrier()`](#torch.distributed.monitored_barrier
    "torch.distributed.monitored_barrier")的所有rank。[`torch.distributed.monitored_barrier()`](#torch.distributed.monitored_barrier
    "torch.distributed.monitored_barrier")使用`send`/`recv`通信原语实现主机端的屏障，类似于确认，允许rank
    0报告哪些rank未能及时确认屏障。例如，考虑以下函数，其中rank 1未能调用[`torch.distributed.monitored_barrier()`](#torch.distributed.monitored_barrier
    "torch.distributed.monitored_barrier")（实际上，这可能是由于应用程序错误或在先前的集体操作中挂起）：
- en: '[PRE104]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The following error message is produced on rank 0, allowing the user to determine
    which rank(s) may be faulty and investigate further:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 在rank 0上产生以下错误消息，允许用户确定哪个rank可能存在故障并进一步调查：
- en: '[PRE105]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '`TORCH_DISTRIBUTED_DEBUG`'
  id: totrans-754
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`TORCH_DISTRIBUTED_DEBUG`'
- en: With `TORCH_CPP_LOG_LEVEL=INFO`, the environment variable `TORCH_DISTRIBUTED_DEBUG`
    can be used to trigger additional useful logging and collective synchronization
    checks to ensure all ranks are synchronized appropriately. `TORCH_DISTRIBUTED_DEBUG`
    can be set to either `OFF` (default), `INFO`, or `DETAIL` depending on the debugging
    level required. Please note that the most verbose option, `DETAIL` may impact
    the application performance and thus should only be used when debugging issues.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`TORCH_CPP_LOG_LEVEL=INFO`，环境变量`TORCH_DISTRIBUTED_DEBUG`可以用来触发额外有用的日志记录和集体同步检查，以确保所有rank同步适当。`TORCH_DISTRIBUTED_DEBUG`可以设置为`OFF`（默认）、`INFO`或`DETAIL`，取决于所需的调试级别。请注意，最详细的选项`DETAIL`可能会影响应用程序性能，因此只有在调试问题时才应使用。
- en: 'Setting `TORCH_DISTRIBUTED_DEBUG=INFO` will result in additional debug logging
    when models trained with [`torch.nn.parallel.DistributedDataParallel()`](generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel
    "torch.nn.parallel.DistributedDataParallel") are initialized, and `TORCH_DISTRIBUTED_DEBUG=DETAIL`
    will additionally log runtime performance statistics a select number of iterations.
    These runtime statistics include data such as forward time, backward time, gradient
    communication time, etc. As an example, given the following application:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`TORCH_DISTRIBUTED_DEBUG=INFO`将导致在使用[`torch.nn.parallel.DistributedDataParallel()`](generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel
    "torch.nn.parallel.DistributedDataParallel")训练的模型初始化时产生额外的调试日志，而`TORCH_DISTRIBUTED_DEBUG=DETAIL`还将在选择的迭代次数中记录运行时性能统计信息。这些运行时统计信息包括前向时间、反向时间、梯度通信时间等。例如，考虑以下应用程序：
- en: '[PRE106]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The following logs are rendered at initialization time:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化时生成以下日志：
- en: '[PRE107]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The following logs are rendered during runtime (when `TORCH_DISTRIBUTED_DEBUG=DETAIL`
    is set):'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时（当设置`TORCH_DISTRIBUTED_DEBUG=DETAIL`时）生成以下日志：
- en: '[PRE108]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'In addition, `TORCH_DISTRIBUTED_DEBUG=INFO` enhances crash logging in [`torch.nn.parallel.DistributedDataParallel()`](generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel
    "torch.nn.parallel.DistributedDataParallel") due to unused parameters in the model.
    Currently, `find_unused_parameters=True` must be passed into [`torch.nn.parallel.DistributedDataParallel()`](generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel
    "torch.nn.parallel.DistributedDataParallel") initialization if there are parameters
    that may be unused in the forward pass, and as of v1.10, all model outputs are
    required to be used in loss computation as [`torch.nn.parallel.DistributedDataParallel()`](generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel
    "torch.nn.parallel.DistributedDataParallel") does not support unused parameters
    in the backwards pass. These constraints are challenging especially for larger
    models, thus when crashing with an error, [`torch.nn.parallel.DistributedDataParallel()`](generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel
    "torch.nn.parallel.DistributedDataParallel") will log the fully qualified name
    of all parameters that went unused. For example, in the above application, if
    we modify `loss` to be instead computed as `loss = output[1]`, then `TwoLinLayerNet.a`
    does not receive a gradient in the backwards pass, and thus results in `DDP` failing.
    On a crash, the user is passed information about parameters which went unused,
    which may be challenging to manually find for large models:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`TORCH_DISTRIBUTED_DEBUG=INFO` 增强了[`torch.nn.parallel.DistributedDataParallel()`](generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel
    "torch.nn.parallel.DistributedDataParallel")中的崩溃日志记录，因为模型中存在未使用的参数。目前，如果在前向传递中可能存在未使用的参数，则必须在[`torch.nn.parallel.DistributedDataParallel()`](generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel
    "torch.nn.parallel.DistributedDataParallel")初始化时传入 `find_unused_parameters=True`，并且从
    v1.10 开始，所有模型输出都必须在损失计算中使用，因为[`torch.nn.parallel.DistributedDataParallel()`](generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel
    "torch.nn.parallel.DistributedDataParallel")不支持在反向传递中使用未使用的参数。这些约束对于较大的模型来说是具有挑战性的，因此当出现错误时，[`torch.nn.parallel.DistributedDataParallel()`](generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel
    "torch.nn.parallel.DistributedDataParallel")将记录所有未使用的参数的完全限定名称。例如，在上述应用中，如果我们将
    `loss` 修改为 `loss = output[1]`，那么 `TwoLinLayerNet.a` 在反向传递中将不会接收到梯度，从而导致 `DDP`
    失败。在崩溃时，用户将获得有关未使用参数的信息，对于大型模型来说可能很难手动找到：
- en: '[PRE109]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Setting `TORCH_DISTRIBUTED_DEBUG=DETAIL` will trigger additional consistency
    and synchronization checks on every collective call issued by the user either
    directly or indirectly (such as DDP `allreduce`). This is done by creating a wrapper
    process group that wraps all process groups returned by [`torch.distributed.init_process_group()`](#torch.distributed.init_process_group
    "torch.distributed.init_process_group") and [`torch.distributed.new_group()`](#torch.distributed.new_group
    "torch.distributed.new_group") APIs. As a result, these APIs will return a wrapper
    process group that can be used exactly like a regular process group, but performs
    consistency checks before dispatching the collective to an underlying process
    group. Currently, these checks include a [`torch.distributed.monitored_barrier()`](#torch.distributed.monitored_barrier
    "torch.distributed.monitored_barrier"), which ensures all ranks complete their
    outstanding collective calls and reports ranks which are stuck. Next, the collective
    itself is checked for consistency by ensuring all collective functions match and
    are called with consistent tensor shapes. If this is not the case, a detailed
    error report is included when the application crashes, rather than a hang or uninformative
    error message. As an example, consider the following function which has mismatched
    input shapes into [`torch.distributed.all_reduce()`](#torch.distributed.all_reduce
    "torch.distributed.all_reduce"):'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `TORCH_DISTRIBUTED_DEBUG=DETAIL` 将触发用户发出的每个集体调用（直接或间接，如 DDP `allreduce`）上的额外一致性和同步检查。这是通过创建一个包装器进程组来实现的，该包装器进程组包装了由[`torch.distributed.init_process_group()`](#torch.distributed.init_process_group
    "torch.distributed.init_process_group")和[`torch.distributed.new_group()`](#torch.distributed.new_group
    "torch.distributed.new_group") API返回的所有进程组。因此，这些 API 将返回一个包装器进程组，可以像常规进程组一样使用，但在将集体调度到底层进程组之前执行一致性检查。目前，这些检查包括[`torch.distributed.monitored_barrier()`](#torch.distributed.monitored_barrier
    "torch.distributed.monitored_barrier")，它确保所有等级完成其未完成的集体调用，并报告卡住的等级。接下来，通过确保所有集体函数匹配并使用一致的张量形状来检查集体本身的一致性。如果不是这种情况，应用程序崩溃时将包括详细的错误报告，而不是挂起或无信息的错误消息。例如，考虑以下函数，其中输入形状不匹配到[`torch.distributed.all_reduce()`](#torch.distributed.all_reduce
    "torch.distributed.all_reduce")：
- en: '[PRE110]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'With the `NCCL` backend, such an application would likely result in a hang
    which can be challenging to root-cause in nontrivial scenarios. If the user enables
    `TORCH_DISTRIBUTED_DEBUG=DETAIL` and reruns the application, the following error
    message reveals the root cause:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `NCCL` 后端，这样的应用程序可能会导致挂起，在复杂情况下可能很难找到根本原因。如果用户启用 `TORCH_DISTRIBUTED_DEBUG=DETAIL`
    并重新运行应用程序，则以下错误消息将显示根本原因：
- en: '[PRE111]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Note
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For fine-grained control of the debug level during runtime the functions `torch.distributed.set_debug_level()`,
    `torch.distributed.set_debug_level_from_env()`, and `torch.distributed.get_debug_level()`
    can also be used.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在运行时对调试级别进行细粒度控制，还可以使用函数 `torch.distributed.set_debug_level()`、`torch.distributed.set_debug_level_from_env()`
    和 `torch.distributed.get_debug_level()`。
- en: In addition, TORCH_DISTRIBUTED_DEBUG=DETAIL can be used in conjunction with
    TORCH_SHOW_CPP_STACKTRACES=1 to log the entire callstack when a collective desynchronization
    is detected. These collective desynchronization checks will work for all applications
    that use `c10d` collective calls backed by process groups created with the [`torch.distributed.init_process_group()`](#torch.distributed.init_process_group
    "torch.distributed.init_process_group") and [`torch.distributed.new_group()`](#torch.distributed.new_group
    "torch.distributed.new_group") APIs.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，TORCH_DISTRIBUTED_DEBUG=DETAIL可以与TORCH_SHOW_CPP_STACKTRACES=1结合使用，以在检测到集体不同步时记录整个调用堆栈。这些集体不同步检查将适用于所有使用由[`torch.distributed.init_process_group()`](#torch.distributed.init_process_group
    "torch.distributed.init_process_group")和[`torch.distributed.new_group()`](#torch.distributed.new_group
    "torch.distributed.new_group") API创建的进程组支持的`c10d`集体调用的应用程序。
- en: Logging
  id: totrans-771
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志记录
- en: In addition to explicit debugging support via [`torch.distributed.monitored_barrier()`](#torch.distributed.monitored_barrier
    "torch.distributed.monitored_barrier") and `TORCH_DISTRIBUTED_DEBUG`, the underlying
    C++ library of `torch.distributed` also outputs log messages at various levels.
    These messages can be helpful to understand the execution state of a distributed
    training job and to troubleshoot problems such as network connection failures.
    The following matrix shows how the log level can be adjusted via the combination
    of `TORCH_CPP_LOG_LEVEL` and `TORCH_DISTRIBUTED_DEBUG` environment variables.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过[`torch.distributed.monitored_barrier()`](#torch.distributed.monitored_barrier
    "torch.distributed.monitored_barrier")和`TORCH_DISTRIBUTED_DEBUG`提供显式调试支持外，`torch.distributed`的基础C++库还会在各个级别输出日志消息。这些消息有助于了解分布式训练作业的执行状态，并用于解决诸如网络连接失败等问题。以下矩阵显示了如何通过`TORCH_CPP_LOG_LEVEL`和`TORCH_DISTRIBUTED_DEBUG`环境变量的组合来调整日志级别。
- en: '| `TORCH_CPP_LOG_LEVEL` | `TORCH_DISTRIBUTED_DEBUG` | Effective Log Level |'
  id: totrans-773
  prefs: []
  type: TYPE_TB
  zh: '| `TORCH_CPP_LOG_LEVEL` | `TORCH_DISTRIBUTED_DEBUG` | 有效日志级别 |'
- en: '| --- | --- | --- |'
  id: totrans-774
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `ERROR` | ignored | Error |'
  id: totrans-775
  prefs: []
  type: TYPE_TB
  zh: '| `ERROR` | 忽略 | 错误 |'
- en: '| `WARNING` | ignored | Warning |'
  id: totrans-776
  prefs: []
  type: TYPE_TB
  zh: '| `WARNING` | 忽略 | 警告 |'
- en: '| `INFO` | ignored | Info |'
  id: totrans-777
  prefs: []
  type: TYPE_TB
  zh: '| `INFO` | 忽略 | 信息 |'
- en: '| `INFO` | `INFO` | Debug |'
  id: totrans-778
  prefs: []
  type: TYPE_TB
  zh: '| `INFO` | `INFO` | 调试 |'
- en: '| `INFO` | `DETAIL` | Trace (a.k.a. All) |'
  id: totrans-779
  prefs: []
  type: TYPE_TB
  zh: '| `INFO` | `DETAIL` | 跟踪（全称） |'
- en: 'Distributed components raise custom Exception types derived from RuntimeError:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式组件引发从RuntimeError派生的自定义异常类型：
- en: 'torch.distributed.DistError: This is the base type of all distributed exceptions.'
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'torch.distributed.DistError: 这是所有分布式异常的基本类型。'
- en: 'torch.distributed.DistBackendError: This exception is thrown when a backend-specific
    error occurs. For example, if the NCCL backend is used and the user attempts to
    use a GPU that is not available to the NCCL library.'
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'torch.distributed.DistBackendError: 当发生特定于后端的错误时抛出此异常。例如，如果使用NCCL后端并且用户尝试使用NCCL库不可用的GPU。'
- en: 'torch.distributed.DistNetworkError: This exception is thrown when networking
    libraries encounter errors (ex: Connection reset by peer)'
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'torch.distributed.DistNetworkError: 当网络库遇到错误时抛出此异常（例如：对等方重置连接）'
- en: 'torch.distributed.DistStoreError: This exception is thrown when the Store encounters
    an error (ex: TCPStore timeout)'
  id: totrans-784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'torch.distributed.DistStoreError: 当存储遇到错误（例如：TCPStore超时）时抛出此异常'
- en: '[PRE112]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Exception raised when an error occurs in the distributed library
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式库中发生错误时引发异常
- en: '[PRE113]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Exception raised when a backend error occurs in distributed
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式中发生后端错误时引发异常
- en: '[PRE114]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Exception raised when a network error occurs in distributed
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式网络发生错误时引发异常
- en: '[PRE115]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Exception raised when an error occurs in the distributed store
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式存储中发生错误时引发异常
- en: 'If you are running single node training, it may be convenient to interactively
    breakpoint your script. We offer a way to conveniently breakpoint a single rank:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行单节点训练，可能会方便地在脚本中交互式设置断点。我们提供了一种方便地在单个rank上设置断点的方法：
- en: '[PRE116]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Set a breakpoint, but only on a single rank. All other ranks will wait for you
    to be done with the breakpoint before continuing. This calls `breakpoint()` under
    the hood, so you can customize it using the normal facilities, e.g., `PYTHONBREAKPOINT`
    environment variable.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 设置断点，但仅在单个rank上。所有其他rank将等待您完成断点后继续。这在底层调用了`breakpoint()`，因此您可以使用正常的工具进行自定义，例如，`PYTHONBREAKPOINT`环境变量。
- en: Parameters
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '**rank** ([*int*](https://docs.python.org/3/library/functions.html#int "(in
    Python v3.12)")) – Which rank to break on. Default: `0`'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '**rank**（[*int*](https://docs.python.org/3/library/functions.html#int "(在Python
    v3.12中)")） - 要在其上设置断点的rank。默认值：`0`'
